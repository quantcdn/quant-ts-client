/* tslint:disable */
/* eslint-disable */
/**
 * QuantCDN API
 * Unified API for QuantCDN Admin and QuantCloud Platform services
 *
 * The version of the OpenAPI document: 4.2.1
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError, operationServerMap } from './base';

/**
 * 
 * @export
 * @interface Application
 */
export interface Application {
    /**
     * Application name
     * @type {string}
     * @memberof Application
     */
    'appName': string;
    /**
     * Organisation machine name
     * @type {string}
     * @memberof Application
     */
    'organisation': string;
    /**
     * 
     * @type {ApplicationDatabase}
     * @memberof Application
     */
    'database'?: ApplicationDatabase | null;
    /**
     * 
     * @type {ApplicationFilesystem}
     * @memberof Application
     */
    'filesystem'?: ApplicationFilesystem | null;
    /**
     * 
     * @type {Compose}
     * @memberof Application
     */
    'composeDefinition'?: Compose;
    /**
     * Application status
     * @type {string}
     * @memberof Application
     */
    'status'?: string | null;
    /**
     * Deployment history
     * @type {Array<ApplicationDeploymentInformationInner>}
     * @memberof Application
     */
    'deploymentInformation'?: Array<ApplicationDeploymentInformationInner> | null;
    /**
     * 
     * @type {ApplicationImageReference}
     * @memberof Application
     */
    'imageReference'?: ApplicationImageReference | null;
    /**
     * List of container names
     * @type {Array<string>}
     * @memberof Application
     */
    'containerNames'?: Array<string> | null;
    /**
     * Minimum task count for auto-scaling
     * @type {number}
     * @memberof Application
     */
    'minCapacity'?: number | null;
    /**
     * Maximum task count for auto-scaling
     * @type {number}
     * @memberof Application
     */
    'maxCapacity'?: number | null;
    /**
     * Desired task count
     * @type {number}
     * @memberof Application
     */
    'desiredCount'?: number | null;
    /**
     * Currently running task count
     * @type {number}
     * @memberof Application
     */
    'runningCount'?: number | null;
    /**
     * List of environments
     * @type {Array<ApplicationEnvironmentsInner>}
     * @memberof Application
     */
    'environments'?: Array<ApplicationEnvironmentsInner> | null;
}
/**
 * Database configuration
 * @export
 * @interface ApplicationDatabase
 */
export interface ApplicationDatabase {
    /**
     * RDS instance identifier
     * @type {string}
     * @memberof ApplicationDatabase
     */
    'rdsInstanceIdentifier'?: string;
    /**
     * RDS instance endpoint address
     * @type {string}
     * @memberof ApplicationDatabase
     */
    'rdsInstanceEndpoint'?: string;
    /**
     * Database engine
     * @type {string}
     * @memberof ApplicationDatabase
     */
    'rdsInstanceEngine'?: ApplicationDatabaseRdsInstanceEngineEnum;
    /**
     * RDS instance status
     * @type {string}
     * @memberof ApplicationDatabase
     */
    'rdsInstanceStatus'?: string;
}

export const ApplicationDatabaseRdsInstanceEngineEnum = {
    Mysql: 'mysql',
    Postgres: 'postgres'
} as const;

export type ApplicationDatabaseRdsInstanceEngineEnum = typeof ApplicationDatabaseRdsInstanceEngineEnum[keyof typeof ApplicationDatabaseRdsInstanceEngineEnum];

/**
 * 
 * @export
 * @interface ApplicationDeploymentInformationInner
 */
export interface ApplicationDeploymentInformationInner {
    /**
     * Deployment identifier
     * @type {string}
     * @memberof ApplicationDeploymentInformationInner
     */
    'deploymentId'?: string;
    /**
     * Task definition ARN used
     * @type {string}
     * @memberof ApplicationDeploymentInformationInner
     */
    'taskDefinitionArn'?: string;
    /**
     * Deployment creation timestamp
     * @type {string}
     * @memberof ApplicationDeploymentInformationInner
     */
    'createdAt'?: string;
    /**
     * Deployment status
     * @type {string}
     * @memberof ApplicationDeploymentInformationInner
     */
    'status'?: string;
    /**
     * Image tag deployed
     * @type {string}
     * @memberof ApplicationDeploymentInformationInner
     */
    'imageTag'?: string;
}
/**
 * 
 * @export
 * @interface ApplicationEnvironmentsInner
 */
export interface ApplicationEnvironmentsInner {
    /**
     * Environment name
     * @type {string}
     * @memberof ApplicationEnvironmentsInner
     */
    'envName'?: string;
    /**
     * Environment status
     * @type {string}
     * @memberof ApplicationEnvironmentsInner
     */
    'status'?: string;
    /**
     * Running task count
     * @type {number}
     * @memberof ApplicationEnvironmentsInner
     */
    'runningCount'?: number;
    /**
     * Desired task count
     * @type {number}
     * @memberof ApplicationEnvironmentsInner
     */
    'desiredCount'?: number;
}
/**
 * Filesystem configuration
 * @export
 * @interface ApplicationFilesystem
 */
export interface ApplicationFilesystem {
    /**
     * EFS filesystem ID
     * @type {string}
     * @memberof ApplicationFilesystem
     */
    'filesystemId'?: string;
    /**
     * Default mount path in containers
     * @type {string}
     * @memberof ApplicationFilesystem
     */
    'mountPath'?: string;
}
/**
 * Image reference information
 * @export
 * @interface ApplicationImageReference
 */
export interface ApplicationImageReference {
    /**
     * Image type
     * @type {string}
     * @memberof ApplicationImageReference
     */
    'type'?: ApplicationImageReferenceTypeEnum;
    /**
     * Image identifier
     * @type {string}
     * @memberof ApplicationImageReference
     */
    'identifier'?: string;
}

export const ApplicationImageReferenceTypeEnum = {
    Internal: 'internal',
    External: 'external'
} as const;

export type ApplicationImageReferenceTypeEnum = typeof ApplicationImageReferenceTypeEnum[keyof typeof ApplicationImageReferenceTypeEnum];

/**
 * 
 * @export
 * @interface BulkSetEnvironmentVariablesRequest
 */
export interface BulkSetEnvironmentVariablesRequest {
    /**
     * 
     * @type {Array<BulkSetEnvironmentVariablesRequestEnvironmentInner>}
     * @memberof BulkSetEnvironmentVariablesRequest
     */
    'environment': Array<BulkSetEnvironmentVariablesRequestEnvironmentInner>;
}
/**
 * 
 * @export
 * @interface BulkSetEnvironmentVariablesRequestEnvironmentInner
 */
export interface BulkSetEnvironmentVariablesRequestEnvironmentInner {
    /**
     * 
     * @type {string}
     * @memberof BulkSetEnvironmentVariablesRequestEnvironmentInner
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof BulkSetEnvironmentVariablesRequestEnvironmentInner
     */
    'value': string;
}
/**
 * 
 * @export
 * @interface ChatInference200Response
 */
export interface ChatInference200Response {
    /**
     * 
     * @type {ChatInference200ResponseResponse}
     * @memberof ChatInference200Response
     */
    'response'?: ChatInference200ResponseResponse;
    /**
     * Model used for generation
     * @type {string}
     * @memberof ChatInference200Response
     */
    'model'?: string;
    /**
     * Unique request identifier
     * @type {string}
     * @memberof ChatInference200Response
     */
    'requestId'?: string;
    /**
     * Why the model stopped generating
     * @type {string}
     * @memberof ChatInference200Response
     */
    'finishReason'?: ChatInference200ResponseFinishReasonEnum;
    /**
     * 
     * @type {ChatInference200ResponseUsage}
     * @memberof ChatInference200Response
     */
    'usage'?: ChatInference200ResponseUsage;
}

export const ChatInference200ResponseFinishReasonEnum = {
    Stop: 'stop',
    Length: 'length',
    ContentFilter: 'content_filter',
    ToolUse: 'tool_use'
} as const;

export type ChatInference200ResponseFinishReasonEnum = typeof ChatInference200ResponseFinishReasonEnum[keyof typeof ChatInference200ResponseFinishReasonEnum];

/**
 * Assistant\'s response message. May contain text content and/or tool use requests.
 * @export
 * @interface ChatInference200ResponseResponse
 */
export interface ChatInference200ResponseResponse {
    /**
     * 
     * @type {string}
     * @memberof ChatInference200ResponseResponse
     */
    'role'?: ChatInference200ResponseResponseRoleEnum;
    /**
     * Text response content
     * @type {string}
     * @memberof ChatInference200ResponseResponse
     */
    'content'?: string;
    /**
     * 
     * @type {ChatInference200ResponseResponseToolUse}
     * @memberof ChatInference200ResponseResponse
     */
    'toolUse'?: ChatInference200ResponseResponseToolUse;
}

export const ChatInference200ResponseResponseRoleEnum = {
    Assistant: 'assistant'
} as const;

export type ChatInference200ResponseResponseRoleEnum = typeof ChatInference200ResponseResponseRoleEnum[keyof typeof ChatInference200ResponseResponseRoleEnum];

/**
 * @type ChatInference200ResponseResponseToolUse
 * Tool use request(s). Can be a single object or array of objects. Only present when AI requests tools.
 * @export
 */
export type ChatInference200ResponseResponseToolUse = Array<ChatInference200ResponseResponseToolUseOneOf1Inner> | ChatInference200ResponseResponseToolUseOneOf;

/**
 * Single tool request
 * @export
 * @interface ChatInference200ResponseResponseToolUseOneOf
 */
export interface ChatInference200ResponseResponseToolUseOneOf {
    /**
     * 
     * @type {string}
     * @memberof ChatInference200ResponseResponseToolUseOneOf
     */
    'toolUseId'?: string;
    /**
     * 
     * @type {string}
     * @memberof ChatInference200ResponseResponseToolUseOneOf
     */
    'name'?: string;
    /**
     * 
     * @type {object}
     * @memberof ChatInference200ResponseResponseToolUseOneOf
     */
    'input'?: object;
    /**
     * Present for async tools with autoExecute
     * @type {string}
     * @memberof ChatInference200ResponseResponseToolUseOneOf
     */
    'executionId'?: string;
    /**
     * Present for async tools with autoExecute
     * @type {string}
     * @memberof ChatInference200ResponseResponseToolUseOneOf
     */
    'status'?: ChatInference200ResponseResponseToolUseOneOfStatusEnum;
    /**
     * 
     * @type {ChatInference200ResponseResponseToolUseOneOfResult}
     * @memberof ChatInference200ResponseResponseToolUseOneOf
     */
    'result'?: ChatInference200ResponseResponseToolUseOneOfResult;
}

export const ChatInference200ResponseResponseToolUseOneOfStatusEnum = {
    Pending: 'pending',
    Running: 'running',
    Complete: 'complete',
    Failed: 'failed'
} as const;

export type ChatInference200ResponseResponseToolUseOneOfStatusEnum = typeof ChatInference200ResponseResponseToolUseOneOfStatusEnum[keyof typeof ChatInference200ResponseResponseToolUseOneOfStatusEnum];

/**
 * 
 * @export
 * @interface ChatInference200ResponseResponseToolUseOneOf1Inner
 */
export interface ChatInference200ResponseResponseToolUseOneOf1Inner {
    /**
     * 
     * @type {string}
     * @memberof ChatInference200ResponseResponseToolUseOneOf1Inner
     */
    'toolUseId'?: string;
    /**
     * 
     * @type {string}
     * @memberof ChatInference200ResponseResponseToolUseOneOf1Inner
     */
    'name'?: string;
    /**
     * 
     * @type {object}
     * @memberof ChatInference200ResponseResponseToolUseOneOf1Inner
     */
    'input'?: object;
    /**
     * Present for async tools with autoExecute
     * @type {string}
     * @memberof ChatInference200ResponseResponseToolUseOneOf1Inner
     */
    'executionId'?: string;
    /**
     * Present for async tools with autoExecute
     * @type {string}
     * @memberof ChatInference200ResponseResponseToolUseOneOf1Inner
     */
    'status'?: string;
    /**
     * Present when status=\'complete\' for sync tools
     * @type {object}
     * @memberof ChatInference200ResponseResponseToolUseOneOf1Inner
     */
    'result'?: object;
}
/**
 * Tool execution result (only present when status=\'complete\' for sync auto-executed tools). For async tools, poll /tools/executions/{executionId}
 * @export
 * @interface ChatInference200ResponseResponseToolUseOneOfResult
 */
export interface ChatInference200ResponseResponseToolUseOneOfResult {
    /**
     * Base64 data URIs for images
     * @type {Array<string>}
     * @memberof ChatInference200ResponseResponseToolUseOneOfResult
     */
    'images'?: Array<string>;
    /**
     * Signed S3 URLs for downloads
     * @type {Array<string>}
     * @memberof ChatInference200ResponseResponseToolUseOneOfResult
     */
    's3Urls'?: Array<string>;
}
/**
 * Token usage information
 * @export
 * @interface ChatInference200ResponseUsage
 */
export interface ChatInference200ResponseUsage {
    /**
     * Number of input tokens
     * @type {number}
     * @memberof ChatInference200ResponseUsage
     */
    'inputTokens'?: number;
    /**
     * Number of output tokens
     * @type {number}
     * @memberof ChatInference200ResponseUsage
     */
    'outputTokens'?: number;
    /**
     * Total tokens consumed
     * @type {number}
     * @memberof ChatInference200ResponseUsage
     */
    'totalTokens'?: number;
}
/**
 * 
 * @export
 * @interface ChatInferenceRequest
 */
export interface ChatInferenceRequest {
    /**
     * Array of chat messages. Content can be a simple string or an array of content blocks for multimodal input.
     * @type {Array<ChatInferenceRequestMessagesInner>}
     * @memberof ChatInferenceRequest
     */
    'messages': Array<ChatInferenceRequestMessagesInner>;
    /**
     * Model ID. Use Nova models for multimodal support.
     * @type {string}
     * @memberof ChatInferenceRequest
     */
    'modelId': string;
    /**
     * 
     * @type {number}
     * @memberof ChatInferenceRequest
     */
    'temperature'?: number;
    /**
     * 
     * @type {number}
     * @memberof ChatInferenceRequest
     */
    'maxTokens'?: number;
    /**
     * 
     * @type {number}
     * @memberof ChatInferenceRequest
     */
    'topP'?: number;
    /**
     * Ignored in buffered mode, always returns complete response
     * @type {boolean}
     * @memberof ChatInferenceRequest
     */
    'stream'?: boolean;
    /**
     * Optional custom system prompt. When tools are enabled, this is prepended with tool usage guidance.
     * @type {string}
     * @memberof ChatInferenceRequest
     */
    'systemPrompt'?: string;
    /**
     * Custom stop sequences
     * @type {Array<string>}
     * @memberof ChatInferenceRequest
     */
    'stopSequences'?: Array<string>;
    /**
     * 
     * @type {ChatInferenceRequestResponseFormat}
     * @memberof ChatInferenceRequest
     */
    'responseFormat'?: ChatInferenceRequestResponseFormat;
    /**
     * 
     * @type {ChatInferenceRequestToolConfig}
     * @memberof ChatInferenceRequest
     */
    'toolConfig'?: ChatInferenceRequestToolConfig;
}
/**
 * 
 * @export
 * @interface ChatInferenceRequestMessagesInner
 */
export interface ChatInferenceRequestMessagesInner {
    /**
     * 
     * @type {string}
     * @memberof ChatInferenceRequestMessagesInner
     */
    'role': ChatInferenceRequestMessagesInnerRoleEnum;
    /**
     * 
     * @type {ChatInferenceRequestMessagesInnerContent}
     * @memberof ChatInferenceRequestMessagesInner
     */
    'content': ChatInferenceRequestMessagesInnerContent;
}

export const ChatInferenceRequestMessagesInnerRoleEnum = {
    User: 'user',
    Assistant: 'assistant',
    System: 'system'
} as const;

export type ChatInferenceRequestMessagesInnerRoleEnum = typeof ChatInferenceRequestMessagesInnerRoleEnum[keyof typeof ChatInferenceRequestMessagesInnerRoleEnum];

/**
 * @type ChatInferenceRequestMessagesInnerContent
 * @export
 */
export type ChatInferenceRequestMessagesInnerContent = Array<ChatInferenceRequestMessagesInnerContentOneOfInner> | string;

/**
 * @type ChatInferenceRequestMessagesInnerContentOneOfInner
 * @export
 */
export type ChatInferenceRequestMessagesInnerContentOneOfInner = ChatInferenceRequestMessagesInnerContentOneOfInnerOneOf | ChatInferenceRequestMessagesInnerContentOneOfInnerOneOf1 | ChatInferenceRequestMessagesInnerContentOneOfInnerOneOf2 | ChatInferenceRequestMessagesInnerContentOneOfInnerOneOf3;

/**
 * 
 * @export
 * @interface ChatInferenceRequestMessagesInnerContentOneOfInnerOneOf
 */
export interface ChatInferenceRequestMessagesInnerContentOneOfInnerOneOf {
    /**
     * 
     * @type {string}
     * @memberof ChatInferenceRequestMessagesInnerContentOneOfInnerOneOf
     */
    'text': string;
}
/**
 * 
 * @export
 * @interface ChatInferenceRequestMessagesInnerContentOneOfInnerOneOf1
 */
export interface ChatInferenceRequestMessagesInnerContentOneOfInnerOneOf1 {
    /**
     * 
     * @type {ChatInferenceRequestMessagesInnerContentOneOfInnerOneOf1Image}
     * @memberof ChatInferenceRequestMessagesInnerContentOneOfInnerOneOf1
     */
    'image': ChatInferenceRequestMessagesInnerContentOneOfInnerOneOf1Image;
}
/**
 * 
 * @export
 * @interface ChatInferenceRequestMessagesInnerContentOneOfInnerOneOf1Image
 */
export interface ChatInferenceRequestMessagesInnerContentOneOfInnerOneOf1Image {
    /**
     * 
     * @type {string}
     * @memberof ChatInferenceRequestMessagesInnerContentOneOfInnerOneOf1Image
     */
    'format': ChatInferenceRequestMessagesInnerContentOneOfInnerOneOf1ImageFormatEnum;
    /**
     * 
     * @type {ChatInferenceRequestMessagesInnerContentOneOfInnerOneOf1ImageSource}
     * @memberof ChatInferenceRequestMessagesInnerContentOneOfInnerOneOf1Image
     */
    'source': ChatInferenceRequestMessagesInnerContentOneOfInnerOneOf1ImageSource;
}

export const ChatInferenceRequestMessagesInnerContentOneOfInnerOneOf1ImageFormatEnum = {
    Png: 'png',
    Jpeg: 'jpeg',
    Gif: 'gif',
    Webp: 'webp'
} as const;

export type ChatInferenceRequestMessagesInnerContentOneOfInnerOneOf1ImageFormatEnum = typeof ChatInferenceRequestMessagesInnerContentOneOfInnerOneOf1ImageFormatEnum[keyof typeof ChatInferenceRequestMessagesInnerContentOneOfInnerOneOf1ImageFormatEnum];

/**
 * 
 * @export
 * @interface ChatInferenceRequestMessagesInnerContentOneOfInnerOneOf1ImageSource
 */
export interface ChatInferenceRequestMessagesInnerContentOneOfInnerOneOf1ImageSource {
    /**
     * Base64-encoded image data
     * @type {string}
     * @memberof ChatInferenceRequestMessagesInnerContentOneOfInnerOneOf1ImageSource
     */
    'bytes': string;
}
/**
 * 
 * @export
 * @interface ChatInferenceRequestMessagesInnerContentOneOfInnerOneOf2
 */
export interface ChatInferenceRequestMessagesInnerContentOneOfInnerOneOf2 {
    /**
     * 
     * @type {ChatInferenceRequestMessagesInnerContentOneOfInnerOneOf2Video}
     * @memberof ChatInferenceRequestMessagesInnerContentOneOfInnerOneOf2
     */
    'video': ChatInferenceRequestMessagesInnerContentOneOfInnerOneOf2Video;
}
/**
 * 
 * @export
 * @interface ChatInferenceRequestMessagesInnerContentOneOfInnerOneOf2Video
 */
export interface ChatInferenceRequestMessagesInnerContentOneOfInnerOneOf2Video {
    /**
     * 
     * @type {string}
     * @memberof ChatInferenceRequestMessagesInnerContentOneOfInnerOneOf2Video
     */
    'format': ChatInferenceRequestMessagesInnerContentOneOfInnerOneOf2VideoFormatEnum;
    /**
     * 
     * @type {ChatInferenceRequestMessagesInnerContentOneOfInnerOneOf2VideoSource}
     * @memberof ChatInferenceRequestMessagesInnerContentOneOfInnerOneOf2Video
     */
    'source': ChatInferenceRequestMessagesInnerContentOneOfInnerOneOf2VideoSource;
}

export const ChatInferenceRequestMessagesInnerContentOneOfInnerOneOf2VideoFormatEnum = {
    Mp4: 'mp4',
    Mov: 'mov',
    Mkv: 'mkv',
    Webm: 'webm'
} as const;

export type ChatInferenceRequestMessagesInnerContentOneOfInnerOneOf2VideoFormatEnum = typeof ChatInferenceRequestMessagesInnerContentOneOfInnerOneOf2VideoFormatEnum[keyof typeof ChatInferenceRequestMessagesInnerContentOneOfInnerOneOf2VideoFormatEnum];

/**
 * 
 * @export
 * @interface ChatInferenceRequestMessagesInnerContentOneOfInnerOneOf2VideoSource
 */
export interface ChatInferenceRequestMessagesInnerContentOneOfInnerOneOf2VideoSource {
    /**
     * Base64-encoded video data
     * @type {string}
     * @memberof ChatInferenceRequestMessagesInnerContentOneOfInnerOneOf2VideoSource
     */
    'bytes': string;
}
/**
 * 
 * @export
 * @interface ChatInferenceRequestMessagesInnerContentOneOfInnerOneOf3
 */
export interface ChatInferenceRequestMessagesInnerContentOneOfInnerOneOf3 {
    /**
     * 
     * @type {ChatInferenceRequestMessagesInnerContentOneOfInnerOneOf3Document}
     * @memberof ChatInferenceRequestMessagesInnerContentOneOfInnerOneOf3
     */
    'document': ChatInferenceRequestMessagesInnerContentOneOfInnerOneOf3Document;
}
/**
 * 
 * @export
 * @interface ChatInferenceRequestMessagesInnerContentOneOfInnerOneOf3Document
 */
export interface ChatInferenceRequestMessagesInnerContentOneOfInnerOneOf3Document {
    /**
     * 
     * @type {string}
     * @memberof ChatInferenceRequestMessagesInnerContentOneOfInnerOneOf3Document
     */
    'format': ChatInferenceRequestMessagesInnerContentOneOfInnerOneOf3DocumentFormatEnum;
    /**
     * 
     * @type {string}
     * @memberof ChatInferenceRequestMessagesInnerContentOneOfInnerOneOf3Document
     */
    'name': string;
    /**
     * 
     * @type {ChatInferenceRequestMessagesInnerContentOneOfInnerOneOf3DocumentSource}
     * @memberof ChatInferenceRequestMessagesInnerContentOneOfInnerOneOf3Document
     */
    'source': ChatInferenceRequestMessagesInnerContentOneOfInnerOneOf3DocumentSource;
}

export const ChatInferenceRequestMessagesInnerContentOneOfInnerOneOf3DocumentFormatEnum = {
    Pdf: 'pdf',
    Csv: 'csv',
    Docx: 'docx',
    Xlsx: 'xlsx'
} as const;

export type ChatInferenceRequestMessagesInnerContentOneOfInnerOneOf3DocumentFormatEnum = typeof ChatInferenceRequestMessagesInnerContentOneOfInnerOneOf3DocumentFormatEnum[keyof typeof ChatInferenceRequestMessagesInnerContentOneOfInnerOneOf3DocumentFormatEnum];

/**
 * 
 * @export
 * @interface ChatInferenceRequestMessagesInnerContentOneOfInnerOneOf3DocumentSource
 */
export interface ChatInferenceRequestMessagesInnerContentOneOfInnerOneOf3DocumentSource {
    /**
     * Base64-encoded document data
     * @type {string}
     * @memberof ChatInferenceRequestMessagesInnerContentOneOfInnerOneOf3DocumentSource
     */
    'bytes': string;
}
/**
 * Structured JSON output (Claude 3.5 Sonnet v1/v2, Nova Pro)
 * @export
 * @interface ChatInferenceRequestResponseFormat
 */
export interface ChatInferenceRequestResponseFormat {
    /**
     * 
     * @type {string}
     * @memberof ChatInferenceRequestResponseFormat
     */
    'type'?: ChatInferenceRequestResponseFormatTypeEnum;
    /**
     * JSON Schema defining expected structure
     * @type {object}
     * @memberof ChatInferenceRequestResponseFormat
     */
    'jsonSchema'?: object;
}

export const ChatInferenceRequestResponseFormatTypeEnum = {
    Json: 'json'
} as const;

export type ChatInferenceRequestResponseFormatTypeEnum = typeof ChatInferenceRequestResponseFormatTypeEnum[keyof typeof ChatInferenceRequestResponseFormatTypeEnum];

/**
 * Function calling configuration (Claude 3+, Nova Pro)
 * @export
 * @interface ChatInferenceRequestToolConfig
 */
export interface ChatInferenceRequestToolConfig {
    /**
     * 
     * @type {Array<ChatInferenceRequestToolConfigToolsInner>}
     * @memberof ChatInferenceRequestToolConfig
     */
    'tools'?: Array<ChatInferenceRequestToolConfigToolsInner>;
    /**
     * When true, backend automatically executes tools and feeds results back to AI. For async tools (e.g., image generation), returns executionId for polling. Security: Use allowedTools to whitelist which tools can auto-execute.
     * @type {boolean}
     * @memberof ChatInferenceRequestToolConfig
     */
    'autoExecute'?: boolean;
    /**
     * Whitelist of tool names that can be auto-executed. Required when autoExecute is true for security. Example: [\'get_weather\', \'generate_image\']
     * @type {Array<string>}
     * @memberof ChatInferenceRequestToolConfig
     */
    'allowedTools'?: Array<string>;
}
/**
 * 
 * @export
 * @interface ChatInferenceRequestToolConfigToolsInner
 */
export interface ChatInferenceRequestToolConfigToolsInner {
    /**
     * 
     * @type {ChatInferenceRequestToolConfigToolsInnerToolSpec}
     * @memberof ChatInferenceRequestToolConfigToolsInner
     */
    'toolSpec'?: ChatInferenceRequestToolConfigToolsInnerToolSpec;
}
/**
 * 
 * @export
 * @interface ChatInferenceRequestToolConfigToolsInnerToolSpec
 */
export interface ChatInferenceRequestToolConfigToolsInnerToolSpec {
    /**
     * 
     * @type {string}
     * @memberof ChatInferenceRequestToolConfigToolsInnerToolSpec
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof ChatInferenceRequestToolConfigToolsInnerToolSpec
     */
    'description'?: string;
    /**
     * 
     * @type {ChatInferenceRequestToolConfigToolsInnerToolSpecInputSchema}
     * @memberof ChatInferenceRequestToolConfigToolsInnerToolSpec
     */
    'inputSchema'?: ChatInferenceRequestToolConfigToolsInnerToolSpecInputSchema;
}
/**
 * 
 * @export
 * @interface ChatInferenceRequestToolConfigToolsInnerToolSpecInputSchema
 */
export interface ChatInferenceRequestToolConfigToolsInnerToolSpecInputSchema {
    /**
     * JSON Schema for function parameters
     * @type {object}
     * @memberof ChatInferenceRequestToolConfigToolsInnerToolSpecInputSchema
     */
    'json'?: object;
}
/**
 * 
 * @export
 * @interface ChatInferenceStreamRequest
 */
export interface ChatInferenceStreamRequest {
    /**
     * Array of chat messages. Content can be a simple string or an array of content blocks for multimodal input.
     * @type {Array<ChatInferenceStreamRequestMessagesInner>}
     * @memberof ChatInferenceStreamRequest
     */
    'messages': Array<ChatInferenceStreamRequestMessagesInner>;
    /**
     * Model ID. Use Nova models for multimodal support.
     * @type {string}
     * @memberof ChatInferenceStreamRequest
     */
    'modelId': string;
    /**
     * 
     * @type {number}
     * @memberof ChatInferenceStreamRequest
     */
    'temperature'?: number;
    /**
     * 
     * @type {number}
     * @memberof ChatInferenceStreamRequest
     */
    'maxTokens'?: number;
    /**
     * 
     * @type {number}
     * @memberof ChatInferenceStreamRequest
     */
    'topP'?: number;
    /**
     * Optional custom system prompt. When tools are enabled, this is prepended with tool usage guidance.
     * @type {string}
     * @memberof ChatInferenceStreamRequest
     */
    'systemPrompt'?: string;
    /**
     * Custom stop sequences
     * @type {Array<string>}
     * @memberof ChatInferenceStreamRequest
     */
    'stopSequences'?: Array<string>;
    /**
     * 
     * @type {ChatInferenceRequestResponseFormat}
     * @memberof ChatInferenceStreamRequest
     */
    'responseFormat'?: ChatInferenceRequestResponseFormat;
    /**
     * 
     * @type {ChatInferenceRequestToolConfig}
     * @memberof ChatInferenceStreamRequest
     */
    'toolConfig'?: ChatInferenceRequestToolConfig;
}
/**
 * 
 * @export
 * @interface ChatInferenceStreamRequestMessagesInner
 */
export interface ChatInferenceStreamRequestMessagesInner {
    /**
     * 
     * @type {string}
     * @memberof ChatInferenceStreamRequestMessagesInner
     */
    'role': ChatInferenceStreamRequestMessagesInnerRoleEnum;
    /**
     * 
     * @type {ChatInferenceStreamRequestMessagesInnerContent}
     * @memberof ChatInferenceStreamRequestMessagesInner
     */
    'content': ChatInferenceStreamRequestMessagesInnerContent;
}

export const ChatInferenceStreamRequestMessagesInnerRoleEnum = {
    User: 'user',
    Assistant: 'assistant',
    System: 'system'
} as const;

export type ChatInferenceStreamRequestMessagesInnerRoleEnum = typeof ChatInferenceStreamRequestMessagesInnerRoleEnum[keyof typeof ChatInferenceStreamRequestMessagesInnerRoleEnum];

/**
 * @type ChatInferenceStreamRequestMessagesInnerContent
 * @export
 */
export type ChatInferenceStreamRequestMessagesInnerContent = Array<object> | string;

/**
 * 
 * @export
 * @interface Command
 */
export interface Command {
    /**
     * 
     * @type {string}
     * @memberof Command
     */
    'runId'?: string;
    /**
     * 
     * @type {string}
     * @memberof Command
     */
    'runType'?: string;
    /**
     * 
     * @type {string}
     * @memberof Command
     */
    'command'?: string;
    /**
     * 
     * @type {string}
     * @memberof Command
     */
    'status'?: string;
    /**
     * 
     * @type {string}
     * @memberof Command
     */
    'startTime'?: string;
    /**
     * 
     * @type {string}
     * @memberof Command
     */
    'endTime'?: string;
    /**
     * 
     * @type {number}
     * @memberof Command
     */
    'exitCode'?: number;
    /**
     * 
     * @type {Array<string>}
     * @memberof Command
     */
    'output'?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof Command
     */
    'scheduleName'?: string;
    /**
     * 
     * @type {string}
     * @memberof Command
     */
    'targetContainerName'?: string;
}
/**
 * 
 * @export
 * @interface Compose
 */
export interface Compose {
    /**
     * 
     * @type {Array<Container>}
     * @memberof Compose
     */
    'containers'?: Array<Container>;
    /**
     * CPU architecture (X86_64 or ARM64)
     * @type {string}
     * @memberof Compose
     */
    'architecture'?: string;
    /**
     * Task-level CPU units (e.g., 256, 512, 1024)
     * @type {number}
     * @memberof Compose
     */
    'taskCpu'?: number;
    /**
     * Task-level memory in MB
     * @type {number}
     * @memberof Compose
     */
    'taskMemory'?: number;
    /**
     * Minimum number of instances
     * @type {number}
     * @memberof Compose
     */
    'minCapacity'?: number;
    /**
     * Maximum number of instances
     * @type {number}
     * @memberof Compose
     */
    'maxCapacity'?: number;
    /**
     * 
     * @type {SpotConfiguration}
     * @memberof Compose
     */
    'spotConfiguration'?: SpotConfiguration;
}
/**
 * 
 * @export
 * @interface Container
 */
export interface Container {
    /**
     * Name of the container
     * @type {string}
     * @memberof Container
     */
    'name': string;
    /**
     * 
     * @type {ContainerImageReference}
     * @memberof Container
     */
    'imageReference': ContainerImageReference;
    /**
     * Container-level CPU units
     * @type {number}
     * @memberof Container
     */
    'cpu'?: number | null;
    /**
     * Container-level memory hard limit (MiB)
     * @type {number}
     * @memberof Container
     */
    'memory'?: number | null;
    /**
     * Container-level memory soft limit (MiB)
     * @type {number}
     * @memberof Container
     */
    'memoryReservation'?: number | null;
    /**
     * List of container ports to expose
     * @type {Array<number>}
     * @memberof Container
     */
    'exposedPorts'?: Array<number> | null;
    /**
     * 
     * @type {Array<ContainerMountPointsInner>}
     * @memberof Container
     */
    'mountPoints'?: Array<ContainerMountPointsInner> | null;
    /**
     * Environment variables specific to this container
     * @type {Array<ContainerEnvironmentInner>}
     * @memberof Container
     */
    'environment'?: Array<ContainerEnvironmentInner> | null;
    /**
     * Secrets mapped to environment variables
     * @type {Array<ContainerSecretsInner>}
     * @memberof Container
     */
    'secrets'?: Array<ContainerSecretsInner> | null;
    /**
     * 
     * @type {ContainerHealthCheck}
     * @memberof Container
     */
    'healthCheck'?: ContainerHealthCheck | null;
    /**
     * Container startup dependencies
     * @type {Array<ContainerDependsOnInner>}
     * @memberof Container
     */
    'dependsOn'?: Array<ContainerDependsOnInner> | null;
    /**
     * 
     * @type {Array<string>}
     * @memberof Container
     */
    'command'?: Array<string> | null;
    /**
     * 
     * @type {Array<string>}
     * @memberof Container
     */
    'entryPoint'?: Array<string> | null;
    /**
     * 
     * @type {string}
     * @memberof Container
     */
    'workingDirectory'?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof Container
     */
    'essential'?: boolean | null;
    /**
     * 
     * @type {boolean}
     * @memberof Container
     */
    'readonlyRootFilesystem'?: boolean | null;
    /**
     * 
     * @type {string}
     * @memberof Container
     */
    'user'?: string | null;
    /**
     * Enable origin protection for all exposed ports on this container
     * @type {boolean}
     * @memberof Container
     */
    'originProtection'?: boolean | null;
}
/**
 * 
 * @export
 * @interface ContainerDependsOnInner
 */
export interface ContainerDependsOnInner {
    /**
     * The name of the container this container depends on
     * @type {string}
     * @memberof ContainerDependsOnInner
     */
    'containerName': string;
    /**
     * The condition to wait for on the dependency
     * @type {string}
     * @memberof ContainerDependsOnInner
     */
    'condition'?: ContainerDependsOnInnerConditionEnum;
}

export const ContainerDependsOnInnerConditionEnum = {
    Start: 'START',
    Healthy: 'HEALTHY',
    Complete: 'COMPLETE',
    Success: 'SUCCESS'
} as const;

export type ContainerDependsOnInnerConditionEnum = typeof ContainerDependsOnInnerConditionEnum[keyof typeof ContainerDependsOnInnerConditionEnum];

/**
 * 
 * @export
 * @interface ContainerEnvironmentInner
 */
export interface ContainerEnvironmentInner {
    /**
     * Environment variable name
     * @type {string}
     * @memberof ContainerEnvironmentInner
     */
    'name': string;
    /**
     * Environment variable value
     * @type {string}
     * @memberof ContainerEnvironmentInner
     */
    'value': string;
}
/**
 * Container health check configuration
 * @export
 * @interface ContainerHealthCheck
 */
export interface ContainerHealthCheck {
    /**
     * The command to run to determine if the container is healthy
     * @type {Array<string>}
     * @memberof ContainerHealthCheck
     */
    'command'?: Array<string>;
    /**
     * Time period (seconds) between health checks
     * @type {number}
     * @memberof ContainerHealthCheck
     */
    'interval'?: number;
    /**
     * Time period (seconds) to wait for a health check to return
     * @type {number}
     * @memberof ContainerHealthCheck
     */
    'timeout'?: number;
    /**
     * Number of times to retry a failed health check
     * @type {number}
     * @memberof ContainerHealthCheck
     */
    'retries'?: number;
    /**
     * Grace period (seconds) to ignore unhealthy checks after container starts
     * @type {number}
     * @memberof ContainerHealthCheck
     */
    'startPeriod'?: number | null;
}
/**
 * 
 * @export
 * @interface ContainerImageReference
 */
export interface ContainerImageReference {
    /**
     * Specifies whether the image is internal (ECR) or external (e.g., Docker Hub)
     * @type {string}
     * @memberof ContainerImageReference
     */
    'type': ContainerImageReferenceTypeEnum;
    /**
     * The image identifier. For \'internal\' type, this is the image tag. For \'external\' type, this is the full image name.
     * @type {string}
     * @memberof ContainerImageReference
     */
    'identifier': string;
}

export const ContainerImageReferenceTypeEnum = {
    Internal: 'internal',
    External: 'external'
} as const;

export type ContainerImageReferenceTypeEnum = typeof ContainerImageReferenceTypeEnum[keyof typeof ContainerImageReferenceTypeEnum];

/**
 * 
 * @export
 * @interface ContainerMountPointsInner
 */
export interface ContainerMountPointsInner {
    /**
     * The name of the logical volume
     * @type {string}
     * @memberof ContainerMountPointsInner
     */
    'sourceVolume': string;
    /**
     * The path inside the container where the volume is mounted
     * @type {string}
     * @memberof ContainerMountPointsInner
     */
    'containerPath': string;
    /**
     * 
     * @type {boolean}
     * @memberof ContainerMountPointsInner
     */
    'readOnly'?: boolean;
}
/**
 * 
 * @export
 * @interface ContainerSecretsInner
 */
export interface ContainerSecretsInner {
    /**
     * The environment variable name to be set in the container
     * @type {string}
     * @memberof ContainerSecretsInner
     */
    'name': string;
    /**
     * The key of the secret in the environment\'s \'app-secrets\' store
     * @type {string}
     * @memberof ContainerSecretsInner
     */
    'valueFrom': string;
}
/**
 * 
 * @export
 * @interface CreateAISession201Response
 */
export interface CreateAISession201Response {
    /**
     * 
     * @type {string}
     * @memberof CreateAISession201Response
     */
    'sessionId'?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateAISession201Response
     */
    'status'?: CreateAISession201ResponseStatusEnum;
    /**
     * 
     * @type {string}
     * @memberof CreateAISession201Response
     */
    'expiresAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateAISession201Response
     */
    'createdAt'?: string;
}

export const CreateAISession201ResponseStatusEnum = {
    Active: 'active'
} as const;

export type CreateAISession201ResponseStatusEnum = typeof CreateAISession201ResponseStatusEnum[keyof typeof CreateAISession201ResponseStatusEnum];

/**
 * 
 * @export
 * @interface CreateAISessionRequest
 */
export interface CreateAISessionRequest {
    /**
     * User identifier for this session
     * @type {string}
     * @memberof CreateAISessionRequest
     */
    'userId': string;
    /**
     * Optional user-defined grouping identifier (e.g., app name, environment, tenant). Use any format that makes sense for your application.
     * @type {string}
     * @memberof CreateAISessionRequest
     */
    'sessionGroup'?: string;
    /**
     * Optional custom metadata for additional context
     * @type {{ [key: string]: any; }}
     * @memberof CreateAISessionRequest
     */
    'metadata'?: { [key: string]: any; };
    /**
     * Session expiration in minutes
     * @type {number}
     * @memberof CreateAISessionRequest
     */
    'expirationMinutes'?: number;
    /**
     * Initial conversation messages (e.g., system prompt)
     * @type {Array<CreateAISessionRequestInitialMessagesInner>}
     * @memberof CreateAISessionRequest
     */
    'initialMessages'?: Array<CreateAISessionRequestInitialMessagesInner>;
}
/**
 * 
 * @export
 * @interface CreateAISessionRequestInitialMessagesInner
 */
export interface CreateAISessionRequestInitialMessagesInner {
    /**
     * 
     * @type {string}
     * @memberof CreateAISessionRequestInitialMessagesInner
     */
    'role'?: CreateAISessionRequestInitialMessagesInnerRoleEnum;
    /**
     * 
     * @type {string}
     * @memberof CreateAISessionRequestInitialMessagesInner
     */
    'content'?: string;
}

export const CreateAISessionRequestInitialMessagesInnerRoleEnum = {
    System: 'system',
    User: 'user',
    Assistant: 'assistant'
} as const;

export type CreateAISessionRequestInitialMessagesInnerRoleEnum = typeof CreateAISessionRequestInitialMessagesInnerRoleEnum[keyof typeof CreateAISessionRequestInitialMessagesInnerRoleEnum];

/**
 * 
 * @export
 * @interface CreateApplicationRequest
 */
export interface CreateApplicationRequest {
    /**
     * Application name
     * @type {string}
     * @memberof CreateApplicationRequest
     */
    'appName': string;
    /**
     * 
     * @type {Compose}
     * @memberof CreateApplicationRequest
     */
    'composeDefinition': Compose;
    /**
     * Minimum task count for auto-scaling
     * @type {number}
     * @memberof CreateApplicationRequest
     */
    'minCapacity'?: number | null;
    /**
     * Maximum task count for auto-scaling
     * @type {number}
     * @memberof CreateApplicationRequest
     */
    'maxCapacity'?: number | null;
    /**
     * 
     * @type {CreateApplicationRequestDatabase}
     * @memberof CreateApplicationRequest
     */
    'database'?: CreateApplicationRequestDatabase | null;
    /**
     * 
     * @type {CreateApplicationRequestFilesystem}
     * @memberof CreateApplicationRequest
     */
    'filesystem'?: CreateApplicationRequestFilesystem | null;
}
/**
 * Optional database configuration
 * @export
 * @interface CreateApplicationRequestDatabase
 */
export interface CreateApplicationRequestDatabase {
    /**
     * Database engine type (MySQL 8.4, Postgres)
     * @type {string}
     * @memberof CreateApplicationRequestDatabase
     */
    'engine'?: CreateApplicationRequestDatabaseEngineEnum;
    /**
     * RDS instance class
     * @type {string}
     * @memberof CreateApplicationRequestDatabase
     */
    'instanceClass'?: string;
    /**
     * Allocated storage in GiB
     * @type {number}
     * @memberof CreateApplicationRequestDatabase
     */
    'storageGb'?: number;
    /**
     * Enable Multi-AZ deployment (higher availability and cost)
     * @type {boolean}
     * @memberof CreateApplicationRequestDatabase
     */
    'multiAz'?: boolean;
}

export const CreateApplicationRequestDatabaseEngineEnum = {
    Mysql: 'mysql',
    Postgres: 'postgres'
} as const;

export type CreateApplicationRequestDatabaseEngineEnum = typeof CreateApplicationRequestDatabaseEngineEnum[keyof typeof CreateApplicationRequestDatabaseEngineEnum];

/**
 * Optional filesystem configuration
 * @export
 * @interface CreateApplicationRequestFilesystem
 */
export interface CreateApplicationRequestFilesystem {
    /**
     * Whether to create a shared filesystem
     * @type {boolean}
     * @memberof CreateApplicationRequestFilesystem
     */
    'required'?: boolean;
    /**
     * Mount path inside containers
     * @type {string}
     * @memberof CreateApplicationRequestFilesystem
     */
    'mountPath'?: string;
}
/**
 * 
 * @export
 * @interface CreateBackup202Response
 */
export interface CreateBackup202Response {
    /**
     * 
     * @type {string}
     * @memberof CreateBackup202Response
     */
    'backupId'?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateBackup202Response
     */
    'status'?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateBackup202Response
     */
    'message'?: string;
}
/**
 * 
 * @export
 * @interface CreateBackupRequest
 */
export interface CreateBackupRequest {
    /**
     * Optional backup description
     * @type {string}
     * @memberof CreateBackupRequest
     */
    'description'?: string;
}
/**
 * 
 * @export
 * @interface CreateCommandRequest
 */
export interface CreateCommandRequest {
    /**
     * 
     * @type {string}
     * @memberof CreateCommandRequest
     */
    'command'?: string;
}
/**
 * 
 * @export
 * @interface CreateCronJob422Response
 */
export interface CreateCronJob422Response {
    /**
     * 
     * @type {string}
     * @memberof CreateCronJob422Response
     */
    'message'?: string;
    /**
     * 
     * @type {object}
     * @memberof CreateCronJob422Response
     */
    'errors'?: object;
}
/**
 * 
 * @export
 * @interface CreateCronJobRequest
 */
export interface CreateCronJobRequest {
    /**
     * 
     * @type {string}
     * @memberof CreateCronJobRequest
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof CreateCronJobRequest
     */
    'description'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof CreateCronJobRequest
     */
    'scheduleExpression': string;
    /**
     * 
     * @type {Array<string>}
     * @memberof CreateCronJobRequest
     */
    'command': Array<string>;
    /**
     * 
     * @type {string}
     * @memberof CreateCronJobRequest
     */
    'targetContainerName'?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof CreateCronJobRequest
     */
    'isEnabled'?: boolean | null;
}
/**
 * 
 * @export
 * @interface CreateEnvironmentRequest
 */
export interface CreateEnvironmentRequest {
    /**
     * Environment name (e.g., \'staging\', \'development\')
     * @type {string}
     * @memberof CreateEnvironmentRequest
     */
    'envName': string;
    /**
     * Minimum number of instances
     * @type {number}
     * @memberof CreateEnvironmentRequest
     */
    'minCapacity'?: number;
    /**
     * Maximum number of instances
     * @type {number}
     * @memberof CreateEnvironmentRequest
     */
    'maxCapacity'?: number;
    /**
     * Clone configuration from an existing environment
     * @type {string}
     * @memberof CreateEnvironmentRequest
     */
    'cloneConfigurationFrom'?: string;
    /**
     * 
     * @type {Compose}
     * @memberof CreateEnvironmentRequest
     */
    'composeDefinition'?: Compose;
    /**
     * Optional image tag suffix for cloning
     * @type {string}
     * @memberof CreateEnvironmentRequest
     */
    'imageSuffix'?: string;
    /**
     * 
     * @type {SpotConfiguration}
     * @memberof CreateEnvironmentRequest
     */
    'spotConfiguration'?: SpotConfiguration;
}
/**
 * 
 * @export
 * @interface Cron
 */
export interface Cron {
    /**
     * 
     * @type {string}
     * @memberof Cron
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof Cron
     */
    'schedule'?: string;
    /**
     * 
     * @type {string}
     * @memberof Cron
     */
    'command'?: string;
}
/**
 * 
 * @export
 * @interface CronRun
 */
export interface CronRun {
    /**
     * 
     * @type {string}
     * @memberof CronRun
     */
    'runId'?: string;
    /**
     * 
     * @type {string}
     * @memberof CronRun
     */
    'runType'?: CronRunRunTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof CronRun
     */
    'command'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof CronRun
     */
    'status'?: CronRunStatusEnum;
    /**
     * 
     * @type {string}
     * @memberof CronRun
     */
    'startTime'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof CronRun
     */
    'endTime'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof CronRun
     */
    'exitCode'?: number | null;
    /**
     * 
     * @type {Array<string>}
     * @memberof CronRun
     */
    'output'?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof CronRun
     */
    'scheduleName'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof CronRun
     */
    'targetContainerName'?: string | null;
}

export const CronRunRunTypeEnum = {
    Exec: 'EXEC',
    Cron: 'CRON'
} as const;

export type CronRunRunTypeEnum = typeof CronRunRunTypeEnum[keyof typeof CronRunRunTypeEnum];
export const CronRunStatusEnum = {
    Pending: 'PENDING',
    Running: 'RUNNING',
    Succeeded: 'SUCCEEDED',
    Failed: 'FAILED',
    TimedOut: 'TIMED_OUT',
    Unknown: 'UNKNOWN'
} as const;

export type CronRunStatusEnum = typeof CronRunStatusEnum[keyof typeof CronRunStatusEnum];

/**
 * 
 * @export
 * @interface DeleteAISession200Response
 */
export interface DeleteAISession200Response {
    /**
     * 
     * @type {string}
     * @memberof DeleteAISession200Response
     */
    'message'?: string;
}
/**
 * 
 * @export
 * @interface DeleteBackup200Response
 */
export interface DeleteBackup200Response {
    /**
     * 
     * @type {string}
     * @memberof DeleteBackup200Response
     */
    'message'?: string;
    /**
     * 
     * @type {string}
     * @memberof DeleteBackup200Response
     */
    'backupId'?: string;
}
/**
 * 
 * @export
 * @interface DownloadBackup200Response
 */
export interface DownloadBackup200Response {
    /**
     * Pre-signed S3 URL for download
     * @type {string}
     * @memberof DownloadBackup200Response
     */
    'downloadUrl'?: string;
    /**
     * URL expiration time
     * @type {string}
     * @memberof DownloadBackup200Response
     */
    'expiresAt'?: string;
    /**
     * Suggested filename for download
     * @type {string}
     * @memberof DownloadBackup200Response
     */
    'filename'?: string;
}
/**
 * 
 * @export
 * @interface Embeddings200Response
 */
export interface Embeddings200Response {
    /**
     * 
     * @type {Embeddings200ResponseEmbeddings}
     * @memberof Embeddings200Response
     */
    'embeddings': Embeddings200ResponseEmbeddings;
    /**
     * Model used to generate embeddings
     * @type {string}
     * @memberof Embeddings200Response
     */
    'model': string;
    /**
     * Dimensionality of each embedding vector
     * @type {number}
     * @memberof Embeddings200Response
     */
    'dimension': number;
    /**
     * 
     * @type {Embeddings200ResponseUsage}
     * @memberof Embeddings200Response
     */
    'usage': Embeddings200ResponseUsage;
}
/**
 * @type Embeddings200ResponseEmbeddings
 * Vector embeddings for the input text(s). Single array for string input, array of arrays for batch input.
 * @export
 */
export type Embeddings200ResponseEmbeddings = Array<Array<number>> | Array<number>;

/**
 * 
 * @export
 * @interface Embeddings200ResponseUsage
 */
export interface Embeddings200ResponseUsage {
    /**
     * Number of tokens in input text(s)
     * @type {number}
     * @memberof Embeddings200ResponseUsage
     */
    'inputTokens': number;
    /**
     * Total tokens (same as inputTokens for embeddings)
     * @type {number}
     * @memberof Embeddings200ResponseUsage
     */
    'totalTokens': number;
}
/**
 * 
 * @export
 * @interface EmbeddingsRequest
 */
export interface EmbeddingsRequest {
    /**
     * 
     * @type {EmbeddingsRequestInput}
     * @memberof EmbeddingsRequest
     */
    'input': EmbeddingsRequestInput;
    /**
     * Embedding model to use
     * @type {string}
     * @memberof EmbeddingsRequest
     */
    'modelId'?: string;
    /**
     * Output embedding dimensions. Titan v2 supports: 256, 512, 1024, 8192
     * @type {number}
     * @memberof EmbeddingsRequest
     */
    'dimensions'?: EmbeddingsRequestDimensionsEnum;
    /**
     * Normalize embeddings to unit length (magnitude = 1.0)
     * @type {boolean}
     * @memberof EmbeddingsRequest
     */
    'normalize'?: boolean;
}

export const EmbeddingsRequestDimensionsEnum = {
    NUMBER_256: 256,
    NUMBER_512: 512,
    NUMBER_1024: 1024,
    NUMBER_8192: 8192
} as const;

export type EmbeddingsRequestDimensionsEnum = typeof EmbeddingsRequestDimensionsEnum[keyof typeof EmbeddingsRequestDimensionsEnum];

/**
 * @type EmbeddingsRequestInput
 * Single text string or array of text strings to embed
 * @export
 */
export type EmbeddingsRequestInput = Array<string> | string;

/**
 * 
 * @export
 * @interface Environment
 */
export interface Environment {
    /**
     * 
     * @type {string}
     * @memberof Environment
     */
    'envName': string;
    /**
     * 
     * @type {string}
     * @memberof Environment
     */
    'status'?: string;
    /**
     * 
     * @type {number}
     * @memberof Environment
     */
    'runningCount'?: number;
    /**
     * 
     * @type {number}
     * @memberof Environment
     */
    'desiredCount'?: number;
    /**
     * 
     * @type {number}
     * @memberof Environment
     */
    'minCapacity'?: number;
    /**
     * 
     * @type {number}
     * @memberof Environment
     */
    'maxCapacity'?: number;
    /**
     * 
     * @type {string}
     * @memberof Environment
     */
    'cloneConfigurationFrom'?: string;
    /**
     * Image tag suffix for cloning
     * @type {string}
     * @memberof Environment
     */
    'imageSuffix'?: string;
    /**
     * 
     * @type {object}
     * @memberof Environment
     */
    'taskDefinition'?: object;
    /**
     * 
     * @type {object}
     * @memberof Environment
     */
    'service'?: object;
    /**
     * 
     * @type {object}
     * @memberof Environment
     */
    'loadBalancer'?: object;
    /**
     * 
     * @type {object}
     * @memberof Environment
     */
    'securityGroup'?: object;
    /**
     * 
     * @type {object}
     * @memberof Environment
     */
    'subnet'?: object;
    /**
     * 
     * @type {object}
     * @memberof Environment
     */
    'vpc'?: object;
    /**
     * 
     * @type {Array<Volume>}
     * @memberof Environment
     */
    'volumes'?: Array<Volume>;
    /**
     * 
     * @type {Array<Cron>}
     * @memberof Environment
     */
    'cron'?: Array<Cron>;
}
/**
 * 
 * @export
 * @interface GetAIConfig200Response
 */
export interface GetAIConfig200Response {
    /**
     * 
     * @type {Array<string>}
     * @memberof GetAIConfig200Response
     */
    'enabled_models'?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof GetAIConfig200Response
     */
    'default_model'?: string;
    /**
     * 
     * @type {number}
     * @memberof GetAIConfig200Response
     */
    'max_tokens'?: number;
    /**
     * 
     * @type {number}
     * @memberof GetAIConfig200Response
     */
    'temperature'?: number;
}
/**
 * 
 * @export
 * @interface GetAISession200Response
 */
export interface GetAISession200Response {
    /**
     * 
     * @type {string}
     * @memberof GetAISession200Response
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof GetAISession200Response
     */
    'title'?: string;
    /**
     * 
     * @type {string}
     * @memberof GetAISession200Response
     */
    'model'?: string;
    /**
     * 
     * @type {Array<object>}
     * @memberof GetAISession200Response
     */
    'messages'?: Array<object>;
    /**
     * 
     * @type {string}
     * @memberof GetAISession200Response
     */
    'created_at'?: string;
}
/**
 * 
 * @export
 * @interface GetAIUsageStats200Response
 */
export interface GetAIUsageStats200Response {
    /**
     * Total number of API requests
     * @type {number}
     * @memberof GetAIUsageStats200Response
     */
    'total_requests'?: number;
    /**
     * Total tokens consumed across all requests
     * @type {number}
     * @memberof GetAIUsageStats200Response
     */
    'total_tokens'?: number;
    /**
     * Usage breakdown by model ID
     * @type {{ [key: string]: GetAIUsageStats200ResponseByModelValue; }}
     * @memberof GetAIUsageStats200Response
     */
    'by_model'?: { [key: string]: GetAIUsageStats200ResponseByModelValue; };
}
/**
 * 
 * @export
 * @interface GetAIUsageStats200ResponseByModelValue
 */
export interface GetAIUsageStats200ResponseByModelValue {
    /**
     * Number of requests for this model
     * @type {number}
     * @memberof GetAIUsageStats200ResponseByModelValue
     */
    'requests'?: number;
    /**
     * Total tokens for this model
     * @type {number}
     * @memberof GetAIUsageStats200ResponseByModelValue
     */
    'tokens'?: number;
}
/**
 * 
 * @export
 * @interface GetEcrLoginCredentials200Response
 */
export interface GetEcrLoginCredentials200Response {
    /**
     * 
     * @type {string}
     * @memberof GetEcrLoginCredentials200Response
     */
    'username'?: string;
    /**
     * 
     * @type {string}
     * @memberof GetEcrLoginCredentials200Response
     */
    'password'?: string;
    /**
     * 
     * @type {string}
     * @memberof GetEcrLoginCredentials200Response
     */
    'expiresAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof GetEcrLoginCredentials200Response
     */
    'endpoint'?: string;
}
/**
 * 
 * @export
 * @interface GetEnvironmentLogs200Response
 */
export interface GetEnvironmentLogs200Response {
    /**
     * Array of log events
     * @type {Array<GetEnvironmentLogs200ResponseLogEventsInner>}
     * @memberof GetEnvironmentLogs200Response
     */
    'logEvents'?: Array<GetEnvironmentLogs200ResponseLogEventsInner>;
    /**
     * Token for fetching next page of results (null if no more pages)
     * @type {string}
     * @memberof GetEnvironmentLogs200Response
     */
    'nextToken'?: string | null;
}
/**
 * 
 * @export
 * @interface GetEnvironmentLogs200ResponseLogEventsInner
 */
export interface GetEnvironmentLogs200ResponseLogEventsInner {
    /**
     * Unix timestamp in milliseconds
     * @type {number}
     * @memberof GetEnvironmentLogs200ResponseLogEventsInner
     */
    'timestamp'?: number;
    /**
     * Log message content
     * @type {string}
     * @memberof GetEnvironmentLogs200ResponseLogEventsInner
     */
    'message'?: string;
}
/**
 * 
 * @export
 * @interface GetSshAccessCredentials200Response
 */
export interface GetSshAccessCredentials200Response {
    /**
     * 
     * @type {boolean}
     * @memberof GetSshAccessCredentials200Response
     */
    'success'?: boolean;
    /**
     * 
     * @type {GetSshAccessCredentials200ResponseCredentials}
     * @memberof GetSshAccessCredentials200Response
     */
    'credentials'?: GetSshAccessCredentials200ResponseCredentials;
    /**
     * 
     * @type {string}
     * @memberof GetSshAccessCredentials200Response
     */
    'clusterName'?: string;
    /**
     * 
     * @type {string}
     * @memberof GetSshAccessCredentials200Response
     */
    'taskArn'?: string;
    /**
     * 
     * @type {string}
     * @memberof GetSshAccessCredentials200Response
     */
    'taskId'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof GetSshAccessCredentials200Response
     */
    'containerNames'?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof GetSshAccessCredentials200Response
     */
    'region'?: string;
    /**
     * 
     * @type {number}
     * @memberof GetSshAccessCredentials200Response
     */
    'expiresIn'?: number;
    /**
     * 
     * @type {string}
     * @memberof GetSshAccessCredentials200Response
     */
    'organizationScope'?: string;
}
/**
 * 
 * @export
 * @interface GetSshAccessCredentials200ResponseCredentials
 */
export interface GetSshAccessCredentials200ResponseCredentials {
    /**
     * 
     * @type {string}
     * @memberof GetSshAccessCredentials200ResponseCredentials
     */
    'accessKeyId'?: string;
    /**
     * 
     * @type {string}
     * @memberof GetSshAccessCredentials200ResponseCredentials
     */
    'secretAccessKey'?: string;
    /**
     * 
     * @type {string}
     * @memberof GetSshAccessCredentials200ResponseCredentials
     */
    'sessionToken'?: string;
    /**
     * 
     * @type {string}
     * @memberof GetSshAccessCredentials200ResponseCredentials
     */
    'expiration'?: string;
}
/**
 * 
 * @export
 * @interface GetToolExecutionStatus200Response
 */
export interface GetToolExecutionStatus200Response {
    /**
     * 
     * @type {string}
     * @memberof GetToolExecutionStatus200Response
     */
    'executionId': string;
    /**
     * 
     * @type {string}
     * @memberof GetToolExecutionStatus200Response
     */
    'toolName': string;
    /**
     * 
     * @type {string}
     * @memberof GetToolExecutionStatus200Response
     */
    'status': GetToolExecutionStatus200ResponseStatusEnum;
    /**
     * 
     * @type {GetToolExecutionStatus200ResponseResult}
     * @memberof GetToolExecutionStatus200Response
     */
    'result'?: GetToolExecutionStatus200ResponseResult;
    /**
     * Error message (only present when status=\'failed\')
     * @type {string}
     * @memberof GetToolExecutionStatus200Response
     */
    'error'?: string;
    /**
     * Unix timestamp when execution was created
     * @type {number}
     * @memberof GetToolExecutionStatus200Response
     */
    'createdAt': number;
    /**
     * Unix timestamp when execution started (if status >= \'running\')
     * @type {number}
     * @memberof GetToolExecutionStatus200Response
     */
    'startedAt'?: number;
    /**
     * Unix timestamp when execution completed (if status in [\'complete\', \'failed\'])
     * @type {number}
     * @memberof GetToolExecutionStatus200Response
     */
    'completedAt'?: number;
    /**
     * Execution duration in seconds (if completed)
     * @type {number}
     * @memberof GetToolExecutionStatus200Response
     */
    'duration'?: number;
}

export const GetToolExecutionStatus200ResponseStatusEnum = {
    Pending: 'pending',
    Running: 'running',
    Complete: 'complete',
    Failed: 'failed'
} as const;

export type GetToolExecutionStatus200ResponseStatusEnum = typeof GetToolExecutionStatus200ResponseStatusEnum[keyof typeof GetToolExecutionStatus200ResponseStatusEnum];

/**
 * Tool execution result (only present when status=\'complete\'). Structure varies by tool type.
 * @export
 * @interface GetToolExecutionStatus200ResponseResult
 */
export interface GetToolExecutionStatus200ResponseResult {
    /**
     * For image generation: Array of base64-encoded data URIs for inline display/preview
     * @type {Array<string>}
     * @memberof GetToolExecutionStatus200ResponseResult
     */
    'images'?: Array<string>;
    /**
     * For image generation: Array of signed S3 URLs for high-quality downloads (expire after 1 hour)
     * @type {Array<string>}
     * @memberof GetToolExecutionStatus200ResponseResult
     */
    's3Urls'?: Array<string>;
}
/**
 * 
 * @export
 * @interface GetToolExecutionStatus404Response
 */
export interface GetToolExecutionStatus404Response {
    /**
     * 
     * @type {string}
     * @memberof GetToolExecutionStatus404Response
     */
    'error'?: string;
    /**
     * 
     * @type {string}
     * @memberof GetToolExecutionStatus404Response
     */
    'executionId'?: string;
}
/**
 * 
 * @export
 * @interface ImageGeneration200Response
 */
export interface ImageGeneration200Response {
    /**
     * Array of base64-encoded generated images
     * @type {Array<string>}
     * @memberof ImageGeneration200Response
     */
    'images': Array<string>;
    /**
     * Base64-encoded mask image (for virtual try-on)
     * @type {string}
     * @memberof ImageGeneration200Response
     */
    'maskImage'?: string;
    /**
     * Error message if any images were blocked by content moderation
     * @type {string}
     * @memberof ImageGeneration200Response
     */
    'error'?: string;
}
/**
 * 
 * @export
 * @interface ImageGenerationRequest
 */
export interface ImageGenerationRequest {
    /**
     * Model to use for image generation
     * @type {string}
     * @memberof ImageGenerationRequest
     */
    'modelId'?: string;
    /**
     * Type of image generation task
     * @type {string}
     * @memberof ImageGenerationRequest
     */
    'taskType': ImageGenerationRequestTaskTypeEnum;
    /**
     * 
     * @type {ImageGenerationRequestTextToImageParams}
     * @memberof ImageGenerationRequest
     */
    'textToImageParams'?: ImageGenerationRequestTextToImageParams;
    /**
     * 
     * @type {ImageGenerationRequestColorGuidedGenerationParams}
     * @memberof ImageGenerationRequest
     */
    'colorGuidedGenerationParams'?: ImageGenerationRequestColorGuidedGenerationParams;
    /**
     * 
     * @type {ImageGenerationRequestImageVariationParams}
     * @memberof ImageGenerationRequest
     */
    'imageVariationParams'?: ImageGenerationRequestImageVariationParams;
    /**
     * 
     * @type {ImageGenerationRequestInPaintingParams}
     * @memberof ImageGenerationRequest
     */
    'inPaintingParams'?: ImageGenerationRequestInPaintingParams;
    /**
     * 
     * @type {ImageGenerationRequestOutPaintingParams}
     * @memberof ImageGenerationRequest
     */
    'outPaintingParams'?: ImageGenerationRequestOutPaintingParams;
    /**
     * 
     * @type {ImageGenerationRequestBackgroundRemovalParams}
     * @memberof ImageGenerationRequest
     */
    'backgroundRemovalParams'?: ImageGenerationRequestBackgroundRemovalParams;
    /**
     * Parameters for VIRTUAL_TRY_ON task
     * @type {object}
     * @memberof ImageGenerationRequest
     */
    'virtualTryOnParams'?: object;
    /**
     * 
     * @type {ImageGenerationRequestImageGenerationConfig}
     * @memberof ImageGenerationRequest
     */
    'imageGenerationConfig'?: ImageGenerationRequestImageGenerationConfig;
    /**
     * AWS region for Nova Canvas
     * @type {string}
     * @memberof ImageGenerationRequest
     */
    'region'?: ImageGenerationRequestRegionEnum;
}

export const ImageGenerationRequestTaskTypeEnum = {
    TextImage: 'TEXT_IMAGE',
    ColorGuidedGeneration: 'COLOR_GUIDED_GENERATION',
    ImageVariation: 'IMAGE_VARIATION',
    Inpainting: 'INPAINTING',
    Outpainting: 'OUTPAINTING',
    BackgroundRemoval: 'BACKGROUND_REMOVAL',
    VirtualTryOn: 'VIRTUAL_TRY_ON'
} as const;

export type ImageGenerationRequestTaskTypeEnum = typeof ImageGenerationRequestTaskTypeEnum[keyof typeof ImageGenerationRequestTaskTypeEnum];
export const ImageGenerationRequestRegionEnum = {
    UsEast1: 'us-east-1',
    ApNortheast1: 'ap-northeast-1',
    EuWest1: 'eu-west-1'
} as const;

export type ImageGenerationRequestRegionEnum = typeof ImageGenerationRequestRegionEnum[keyof typeof ImageGenerationRequestRegionEnum];

/**
 * Parameters for BACKGROUND_REMOVAL task
 * @export
 * @interface ImageGenerationRequestBackgroundRemovalParams
 */
export interface ImageGenerationRequestBackgroundRemovalParams {
    /**
     * 
     * @type {string}
     * @memberof ImageGenerationRequestBackgroundRemovalParams
     */
    'image'?: string;
}
/**
 * Parameters for COLOR_GUIDED_GENERATION task
 * @export
 * @interface ImageGenerationRequestColorGuidedGenerationParams
 */
export interface ImageGenerationRequestColorGuidedGenerationParams {
    /**
     * 
     * @type {Array<string>}
     * @memberof ImageGenerationRequestColorGuidedGenerationParams
     */
    'colors'?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof ImageGenerationRequestColorGuidedGenerationParams
     */
    'referenceImage'?: string;
    /**
     * 
     * @type {string}
     * @memberof ImageGenerationRequestColorGuidedGenerationParams
     */
    'text'?: string;
    /**
     * 
     * @type {string}
     * @memberof ImageGenerationRequestColorGuidedGenerationParams
     */
    'negativeText'?: string;
}
/**
 * General image generation configuration
 * @export
 * @interface ImageGenerationRequestImageGenerationConfig
 */
export interface ImageGenerationRequestImageGenerationConfig {
    /**
     * 
     * @type {number}
     * @memberof ImageGenerationRequestImageGenerationConfig
     */
    'width'?: number;
    /**
     * 
     * @type {number}
     * @memberof ImageGenerationRequestImageGenerationConfig
     */
    'height'?: number;
    /**
     * 
     * @type {string}
     * @memberof ImageGenerationRequestImageGenerationConfig
     */
    'quality'?: ImageGenerationRequestImageGenerationConfigQualityEnum;
    /**
     * 
     * @type {number}
     * @memberof ImageGenerationRequestImageGenerationConfig
     */
    'cfgScale'?: number;
    /**
     * 
     * @type {number}
     * @memberof ImageGenerationRequestImageGenerationConfig
     */
    'seed'?: number;
    /**
     * 
     * @type {number}
     * @memberof ImageGenerationRequestImageGenerationConfig
     */
    'numberOfImages'?: number;
}

export const ImageGenerationRequestImageGenerationConfigQualityEnum = {
    Standard: 'standard',
    Premium: 'premium'
} as const;

export type ImageGenerationRequestImageGenerationConfigQualityEnum = typeof ImageGenerationRequestImageGenerationConfigQualityEnum[keyof typeof ImageGenerationRequestImageGenerationConfigQualityEnum];

/**
 * Parameters for IMAGE_VARIATION task
 * @export
 * @interface ImageGenerationRequestImageVariationParams
 */
export interface ImageGenerationRequestImageVariationParams {
    /**
     * 
     * @type {Array<string>}
     * @memberof ImageGenerationRequestImageVariationParams
     */
    'images'?: Array<string>;
    /**
     * 
     * @type {number}
     * @memberof ImageGenerationRequestImageVariationParams
     */
    'similarityStrength'?: number;
    /**
     * 
     * @type {string}
     * @memberof ImageGenerationRequestImageVariationParams
     */
    'text'?: string;
    /**
     * 
     * @type {string}
     * @memberof ImageGenerationRequestImageVariationParams
     */
    'negativeText'?: string;
}
/**
 * Parameters for INPAINTING task
 * @export
 * @interface ImageGenerationRequestInPaintingParams
 */
export interface ImageGenerationRequestInPaintingParams {
    /**
     * 
     * @type {string}
     * @memberof ImageGenerationRequestInPaintingParams
     */
    'image'?: string;
    /**
     * 
     * @type {string}
     * @memberof ImageGenerationRequestInPaintingParams
     */
    'maskImage'?: string;
    /**
     * 
     * @type {string}
     * @memberof ImageGenerationRequestInPaintingParams
     */
    'maskPrompt'?: string;
    /**
     * 
     * @type {string}
     * @memberof ImageGenerationRequestInPaintingParams
     */
    'text'?: string;
    /**
     * 
     * @type {string}
     * @memberof ImageGenerationRequestInPaintingParams
     */
    'negativeText'?: string;
}
/**
 * Parameters for OUTPAINTING task
 * @export
 * @interface ImageGenerationRequestOutPaintingParams
 */
export interface ImageGenerationRequestOutPaintingParams {
    /**
     * 
     * @type {string}
     * @memberof ImageGenerationRequestOutPaintingParams
     */
    'image'?: string;
    /**
     * 
     * @type {string}
     * @memberof ImageGenerationRequestOutPaintingParams
     */
    'maskImage'?: string;
    /**
     * 
     * @type {string}
     * @memberof ImageGenerationRequestOutPaintingParams
     */
    'maskPrompt'?: string;
    /**
     * 
     * @type {string}
     * @memberof ImageGenerationRequestOutPaintingParams
     */
    'outPaintingMode'?: ImageGenerationRequestOutPaintingParamsOutPaintingModeEnum;
    /**
     * 
     * @type {string}
     * @memberof ImageGenerationRequestOutPaintingParams
     */
    'text'?: string;
    /**
     * 
     * @type {string}
     * @memberof ImageGenerationRequestOutPaintingParams
     */
    'negativeText'?: string;
}

export const ImageGenerationRequestOutPaintingParamsOutPaintingModeEnum = {
    Precise: 'PRECISE',
    Default: 'DEFAULT'
} as const;

export type ImageGenerationRequestOutPaintingParamsOutPaintingModeEnum = typeof ImageGenerationRequestOutPaintingParamsOutPaintingModeEnum[keyof typeof ImageGenerationRequestOutPaintingParamsOutPaintingModeEnum];

/**
 * Parameters for TEXT_IMAGE task
 * @export
 * @interface ImageGenerationRequestTextToImageParams
 */
export interface ImageGenerationRequestTextToImageParams {
    /**
     * Text prompt
     * @type {string}
     * @memberof ImageGenerationRequestTextToImageParams
     */
    'text'?: string;
    /**
     * What NOT to include
     * @type {string}
     * @memberof ImageGenerationRequestTextToImageParams
     */
    'negativeText'?: string;
    /**
     * 
     * @type {string}
     * @memberof ImageGenerationRequestTextToImageParams
     */
    'style'?: ImageGenerationRequestTextToImageParamsStyleEnum;
    /**
     * Base64-encoded conditioning image
     * @type {string}
     * @memberof ImageGenerationRequestTextToImageParams
     */
    'conditionImage'?: string;
    /**
     * 
     * @type {string}
     * @memberof ImageGenerationRequestTextToImageParams
     */
    'controlMode'?: ImageGenerationRequestTextToImageParamsControlModeEnum;
    /**
     * 
     * @type {number}
     * @memberof ImageGenerationRequestTextToImageParams
     */
    'controlStrength'?: number;
}

export const ImageGenerationRequestTextToImageParamsStyleEnum = {
    _3DAnimatedFamilyFilm: '3D_ANIMATED_FAMILY_FILM',
    DesignSketch: 'DESIGN_SKETCH',
    FlatVectorIllustration: 'FLAT_VECTOR_ILLUSTRATION',
    GraphicNovelIllustration: 'GRAPHIC_NOVEL_ILLUSTRATION',
    Maximalism: 'MAXIMALISM',
    MidcenturyRetro: 'MIDCENTURY_RETRO',
    Photorealism: 'PHOTOREALISM',
    SoftDigitalPainting: 'SOFT_DIGITAL_PAINTING'
} as const;

export type ImageGenerationRequestTextToImageParamsStyleEnum = typeof ImageGenerationRequestTextToImageParamsStyleEnum[keyof typeof ImageGenerationRequestTextToImageParamsStyleEnum];
export const ImageGenerationRequestTextToImageParamsControlModeEnum = {
    CannyEdge: 'CANNY_EDGE',
    Segmentation: 'SEGMENTATION'
} as const;

export type ImageGenerationRequestTextToImageParamsControlModeEnum = typeof ImageGenerationRequestTextToImageParamsControlModeEnum[keyof typeof ImageGenerationRequestTextToImageParamsControlModeEnum];

/**
 * 
 * @export
 * @interface KVItemsCreate200Response
 */
export interface KVItemsCreate200Response {
    /**
     * 
     * @type {boolean}
     * @memberof KVItemsCreate200Response
     */
    'success'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof KVItemsCreate200Response
     */
    'key'?: string;
    /**
     * 
     * @type {string}
     * @memberof KVItemsCreate200Response
     */
    'value'?: string;
}
/**
 * 
 * @export
 * @interface KVItemsDelete200Response
 */
export interface KVItemsDelete200Response {
    /**
     * 
     * @type {boolean}
     * @memberof KVItemsDelete200Response
     */
    'success'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof KVItemsDelete200Response
     */
    'key'?: string;
}
/**
 * 
 * @export
 * @interface KVItemsShow200Response
 */
export interface KVItemsShow200Response {
    /**
     * 
     * @type {string}
     * @memberof KVItemsShow200Response
     */
    'key'?: string;
    /**
     * 
     * @type {KVItemsShow200ResponseValue}
     * @memberof KVItemsShow200Response
     */
    'value'?: KVItemsShow200ResponseValue;
}
/**
 * @type KVItemsShow200ResponseValue
 * Item value (decoded from JSON if applicable)
 * @export
 */
export type KVItemsShow200ResponseValue = object | string;

/**
 * 
 * @export
 * @interface ListAIModels200Response
 */
export interface ListAIModels200Response {
    /**
     * 
     * @type {number}
     * @memberof ListAIModels200Response
     */
    'count'?: number;
    /**
     * 
     * @type {Array<ListAIModels200ResponseModelsInner>}
     * @memberof ListAIModels200Response
     */
    'models'?: Array<ListAIModels200ResponseModelsInner>;
}
/**
 * 
 * @export
 * @interface ListAIModels200ResponseModelsInner
 */
export interface ListAIModels200ResponseModelsInner {
    /**
     * 
     * @type {string}
     * @memberof ListAIModels200ResponseModelsInner
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof ListAIModels200ResponseModelsInner
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof ListAIModels200ResponseModelsInner
     */
    'provider'?: string;
    /**
     * 
     * @type {ListAIModels200ResponseModelsInnerCapabilities}
     * @memberof ListAIModels200ResponseModelsInner
     */
    'capabilities'?: ListAIModels200ResponseModelsInnerCapabilities;
}
/**
 * Model capabilities and features
 * @export
 * @interface ListAIModels200ResponseModelsInnerCapabilities
 */
export interface ListAIModels200ResponseModelsInnerCapabilities {
    /**
     * Supports text generation
     * @type {boolean}
     * @memberof ListAIModels200ResponseModelsInnerCapabilities
     */
    'text'?: boolean;
    /**
     * Supports images/video
     * @type {boolean}
     * @memberof ListAIModels200ResponseModelsInnerCapabilities
     */
    'multimodal'?: boolean;
    /**
     * Supports embeddings
     * @type {boolean}
     * @memberof ListAIModels200ResponseModelsInnerCapabilities
     */
    'embeddings'?: boolean;
    /**
     * Supports streaming responses
     * @type {boolean}
     * @memberof ListAIModels200ResponseModelsInnerCapabilities
     */
    'streaming'?: boolean;
    /**
     * Supports function calling
     * @type {boolean}
     * @memberof ListAIModels200ResponseModelsInnerCapabilities
     */
    'toolUse'?: boolean;
}
/**
 * 
 * @export
 * @interface ListAISessions200ResponseInner
 */
export interface ListAISessions200ResponseInner {
    /**
     * 
     * @type {string}
     * @memberof ListAISessions200ResponseInner
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof ListAISessions200ResponseInner
     */
    'title'?: string;
    /**
     * 
     * @type {string}
     * @memberof ListAISessions200ResponseInner
     */
    'model'?: string;
    /**
     * 
     * @type {string}
     * @memberof ListAISessions200ResponseInner
     */
    'created_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof ListAISessions200ResponseInner
     */
    'updated_at'?: string;
}
/**
 * 
 * @export
 * @interface ListAIToolNames200Response
 */
export interface ListAIToolNames200Response {
    /**
     * Array of tool names
     * @type {Array<string>}
     * @memberof ListAIToolNames200Response
     */
    'tools': Array<string>;
    /**
     * Number of tools
     * @type {number}
     * @memberof ListAIToolNames200Response
     */
    'count': number;
}
/**
 * 
 * @export
 * @interface ListAITools200Response
 */
export interface ListAITools200Response {
    /**
     * Array of available tool specifications
     * @type {Array<ListAITools200ResponseToolsInner>}
     * @memberof ListAITools200Response
     */
    'tools': Array<ListAITools200ResponseToolsInner>;
    /**
     * Number of available tools
     * @type {number}
     * @memberof ListAITools200Response
     */
    'count': number;
}
/**
 * 
 * @export
 * @interface ListAITools200ResponseToolsInner
 */
export interface ListAITools200ResponseToolsInner {
    /**
     * 
     * @type {ListAITools200ResponseToolsInnerToolSpec}
     * @memberof ListAITools200ResponseToolsInner
     */
    'toolSpec'?: ListAITools200ResponseToolsInnerToolSpec;
}
/**
 * 
 * @export
 * @interface ListAITools200ResponseToolsInnerToolSpec
 */
export interface ListAITools200ResponseToolsInnerToolSpec {
    /**
     * 
     * @type {string}
     * @memberof ListAITools200ResponseToolsInnerToolSpec
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof ListAITools200ResponseToolsInnerToolSpec
     */
    'description'?: string;
    /**
     * 
     * @type {ListAITools200ResponseToolsInnerToolSpecInputSchema}
     * @memberof ListAITools200ResponseToolsInnerToolSpec
     */
    'inputSchema'?: ListAITools200ResponseToolsInnerToolSpecInputSchema;
}
/**
 * 
 * @export
 * @interface ListAITools200ResponseToolsInnerToolSpecInputSchema
 */
export interface ListAITools200ResponseToolsInnerToolSpecInputSchema {
    /**
     * JSON Schema defining function parameters
     * @type {object}
     * @memberof ListAITools200ResponseToolsInnerToolSpecInputSchema
     */
    'json'?: object;
}
/**
 * 
 * @export
 * @interface ListBackups200Response
 */
export interface ListBackups200Response {
    /**
     * 
     * @type {Array<ListBackups200ResponseBackupsInner>}
     * @memberof ListBackups200Response
     */
    'backups'?: Array<ListBackups200ResponseBackupsInner>;
    /**
     * 
     * @type {number}
     * @memberof ListBackups200Response
     */
    'count'?: number;
    /**
     * Token for retrieving the next page of results, if more data is available
     * @type {string}
     * @memberof ListBackups200Response
     */
    'nextToken'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ListBackups200Response
     */
    'message'?: string;
}
/**
 * 
 * @export
 * @interface ListBackups200ResponseBackupsInner
 */
export interface ListBackups200ResponseBackupsInner {
    /**
     * 
     * @type {string}
     * @memberof ListBackups200ResponseBackupsInner
     */
    'backupId'?: string;
    /**
     * 
     * @type {string}
     * @memberof ListBackups200ResponseBackupsInner
     */
    'status'?: string;
    /**
     * 
     * @type {string}
     * @memberof ListBackups200ResponseBackupsInner
     */
    'type'?: string;
    /**
     * 
     * @type {string}
     * @memberof ListBackups200ResponseBackupsInner
     */
    'engine'?: string;
    /**
     * 
     * @type {string}
     * @memberof ListBackups200ResponseBackupsInner
     */
    'description'?: string;
    /**
     * 
     * @type {string}
     * @memberof ListBackups200ResponseBackupsInner
     */
    'createdAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof ListBackups200ResponseBackupsInner
     */
    'updatedAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof ListBackups200ResponseBackupsInner
     */
    'taskArn'?: string;
    /**
     * 
     * @type {string}
     * @memberof ListBackups200ResponseBackupsInner
     */
    's3Key'?: string;
    /**
     * 
     * @type {string}
     * @memberof ListBackups200ResponseBackupsInner
     */
    'bucketName'?: string;
    /**
     * 
     * @type {number}
     * @memberof ListBackups200ResponseBackupsInner
     */
    'size'?: number;
    /**
     * 
     * @type {string}
     * @memberof ListBackups200ResponseBackupsInner
     */
    'sizeFormatted'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof ListBackups200ResponseBackupsInner
     */
    'fileExists'?: boolean;
}
/**
 * 
 * @export
 * @interface ListBackups422Response
 */
export interface ListBackups422Response {
    /**
     * 
     * @type {string}
     * @memberof ListBackups422Response
     */
    'error'?: string;
}
/**
 * 
 * @export
 * @interface ListToolExecutions200Response
 */
export interface ListToolExecutions200Response {
    /**
     * 
     * @type {Array<ListToolExecutions200ResponseExecutionsInner>}
     * @memberof ListToolExecutions200Response
     */
    'executions': Array<ListToolExecutions200ResponseExecutionsInner>;
    /**
     * Number of executions returned
     * @type {number}
     * @memberof ListToolExecutions200Response
     */
    'count': number;
    /**
     * Organization identifier
     * @type {string}
     * @memberof ListToolExecutions200Response
     */
    'orgId': string;
    /**
     * Filter applied (or \'all\')
     * @type {string}
     * @memberof ListToolExecutions200Response
     */
    'status'?: string;
}
/**
 * 
 * @export
 * @interface ListToolExecutions200ResponseExecutionsInner
 */
export interface ListToolExecutions200ResponseExecutionsInner {
    /**
     * 
     * @type {string}
     * @memberof ListToolExecutions200ResponseExecutionsInner
     */
    'executionId'?: string;
    /**
     * 
     * @type {string}
     * @memberof ListToolExecutions200ResponseExecutionsInner
     */
    'toolName'?: string;
    /**
     * 
     * @type {string}
     * @memberof ListToolExecutions200ResponseExecutionsInner
     */
    'status'?: ListToolExecutions200ResponseExecutionsInnerStatusEnum;
    /**
     * 
     * @type {string}
     * @memberof ListToolExecutions200ResponseExecutionsInner
     */
    'createdAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof ListToolExecutions200ResponseExecutionsInner
     */
    'completedAt'?: string;
}

export const ListToolExecutions200ResponseExecutionsInnerStatusEnum = {
    Pending: 'pending',
    Running: 'running',
    Complete: 'complete',
    Failed: 'failed'
} as const;

export type ListToolExecutions200ResponseExecutionsInnerStatusEnum = typeof ListToolExecutions200ResponseExecutionsInnerStatusEnum[keyof typeof ListToolExecutions200ResponseExecutionsInnerStatusEnum];

/**
 * 
 * @export
 * @interface OrganizationsList200ResponseInner
 */
export interface OrganizationsList200ResponseInner {
    /**
     * Organization name
     * @type {string}
     * @memberof OrganizationsList200ResponseInner
     */
    'name'?: string;
    /**
     * Organization machine name
     * @type {string}
     * @memberof OrganizationsList200ResponseInner
     */
    'machine_name'?: string;
}
/**
 * 
 * @export
 * @interface ProjectsList200ResponseInner
 */
export interface ProjectsList200ResponseInner {
    /**
     * Project name
     * @type {string}
     * @memberof ProjectsList200ResponseInner
     */
    'name': string;
    /**
     * Project machine name
     * @type {string}
     * @memberof ProjectsList200ResponseInner
     */
    'machine_name': string;
}
/**
 * 
 * @export
 * @interface PurgeCreateRequest
 */
export interface PurgeCreateRequest {
    /**
     * Cache keys to purge
     * @type {Array<string>}
     * @memberof PurgeCreateRequest
     */
    'cache_keys': Array<string>;
    /**
     * URLs to purge
     * @type {Array<string>}
     * @memberof PurgeCreateRequest
     */
    'urls'?: Array<string>;
    /**
     * Purge scope (org or project)
     * @type {string}
     * @memberof PurgeCreateRequest
     */
    'scope': string;
    /**
     * Soft purge
     * @type {boolean}
     * @memberof PurgeCreateRequest
     */
    'soft'?: boolean;
}
/**
 * 
 * @export
 * @interface ScalingPolicy
 */
export interface ScalingPolicy {
    /**
     * 
     * @type {string}
     * @memberof ScalingPolicy
     */
    'metric'?: ScalingPolicyMetricEnum;
    /**
     * 
     * @type {number}
     * @memberof ScalingPolicy
     */
    'targetValue'?: number;
    /**
     * 
     * @type {number}
     * @memberof ScalingPolicy
     */
    'scaleInCooldownSeconds'?: number;
    /**
     * 
     * @type {number}
     * @memberof ScalingPolicy
     */
    'scaleOutCooldownSeconds'?: number;
}

export const ScalingPolicyMetricEnum = {
    CpuUtilization: 'CPUUtilization',
    MemoryUtilization: 'MemoryUtilization',
    Rps: 'RPS'
} as const;

export type ScalingPolicyMetricEnum = typeof ScalingPolicyMetricEnum[keyof typeof ScalingPolicyMetricEnum];

/**
 * Spot instance strategy configuration for controlling cost vs reliability. Spot instances provide significant cost savings (~70%) but may be interrupted by AWS. Available for non-production environments.
 * @export
 * @interface SpotConfiguration
 */
export interface SpotConfiguration {
    /**
     * Spot instance strategy. \'off\' = On-Demand only (highest reliability, no savings). \'spot-only\' = 100% Spot instances (~70% savings, default for non-prod). \'mixed-safe\' = 50% Spot instances (~35% savings, requires multiple instances). \'mixed-aggressive\' = 80% Spot instances (~56% savings, requires multiple instances).
     * @type {string}
     * @memberof SpotConfiguration
     */
    'strategy': SpotConfigurationStrategyEnum;
}

export const SpotConfigurationStrategyEnum = {
    Off: 'off',
    SpotOnly: 'spot-only',
    MixedSafe: 'mixed-safe',
    MixedAggressive: 'mixed-aggressive'
} as const;

export type SpotConfigurationStrategyEnum = typeof SpotConfigurationStrategyEnum[keyof typeof SpotConfigurationStrategyEnum];

/**
 * 
 * @export
 * @interface SyncOperation
 */
export interface SyncOperation {
    /**
     * 
     * @type {string}
     * @memberof SyncOperation
     */
    'syncId'?: string;
    /**
     * 
     * @type {string}
     * @memberof SyncOperation
     */
    'syncType'?: string;
    /**
     * 
     * @type {string}
     * @memberof SyncOperation
     */
    'sourceEnvironment'?: string;
    /**
     * 
     * @type {string}
     * @memberof SyncOperation
     */
    'targetEnvironment'?: string;
    /**
     * 
     * @type {string}
     * @memberof SyncOperation
     */
    'status'?: string;
    /**
     * 
     * @type {string}
     * @memberof SyncOperation
     */
    'createdAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof SyncOperation
     */
    'completedAt'?: string;
}
/**
 * 
 * @export
 * @interface SyncToEnvironmentRequest
 */
export interface SyncToEnvironmentRequest {
    /**
     * 
     * @type {string}
     * @memberof SyncToEnvironmentRequest
     */
    'sourceEnvironment'?: string;
}
/**
 * 
 * @export
 * @interface UpdateAIConfigRequest
 */
export interface UpdateAIConfigRequest {
    /**
     * 
     * @type {Array<string>}
     * @memberof UpdateAIConfigRequest
     */
    'enabled_models'?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof UpdateAIConfigRequest
     */
    'default_model'?: string;
    /**
     * 
     * @type {number}
     * @memberof UpdateAIConfigRequest
     */
    'max_tokens'?: number;
    /**
     * 
     * @type {number}
     * @memberof UpdateAIConfigRequest
     */
    'temperature'?: number;
}
/**
 * 
 * @export
 * @interface UpdateCronJobRequest
 */
export interface UpdateCronJobRequest {
    /**
     * 
     * @type {string}
     * @memberof UpdateCronJobRequest
     */
    'description'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof UpdateCronJobRequest
     */
    'scheduleExpression'?: string | null;
    /**
     * 
     * @type {Array<string>}
     * @memberof UpdateCronJobRequest
     */
    'command'?: Array<string> | null;
    /**
     * 
     * @type {string}
     * @memberof UpdateCronJobRequest
     */
    'targetContainerName'?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof UpdateCronJobRequest
     */
    'isEnabled'?: boolean | null;
}
/**
 * 
 * @export
 * @interface UpdateEnvironmentRequest
 */
export interface UpdateEnvironmentRequest {
    /**
     * 
     * @type {Compose}
     * @memberof UpdateEnvironmentRequest
     */
    'composeDefinition': Compose;
    /**
     * Optional. Minimum number of tasks for auto-scaling. If provided at root level, will be merged into composeDefinition.
     * @type {number}
     * @memberof UpdateEnvironmentRequest
     */
    'minCapacity'?: number | null;
    /**
     * Optional. Maximum number of tasks for auto-scaling. If provided at root level, will be merged into composeDefinition.
     * @type {number}
     * @memberof UpdateEnvironmentRequest
     */
    'maxCapacity'?: number | null;
}
/**
 * 
 * @export
 * @interface UpdateEnvironmentStateRequest
 */
export interface UpdateEnvironmentStateRequest {
    /**
     * 
     * @type {string}
     * @memberof UpdateEnvironmentStateRequest
     */
    'action'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateEnvironmentStateRequest
     */
    'imageTag'?: string;
}
/**
 * 
 * @export
 * @interface UpdateEnvironmentVariableRequest
 */
export interface UpdateEnvironmentVariableRequest {
    /**
     * 
     * @type {string}
     * @memberof UpdateEnvironmentVariableRequest
     */
    'value'?: string;
}
/**
 * 
 * @export
 * @interface V1ContentItem
 */
export interface V1ContentItem {
    /**
     * 
     * @type {string}
     * @memberof V1ContentItem
     */
    'url': string;
    /**
     * 
     * @type {string}
     * @memberof V1ContentItem
     */
    'date_timestamp': string;
    /**
     * 
     * @type {string}
     * @memberof V1ContentItem
     */
    'published': string;
    /**
     * 
     * @type {number}
     * @memberof V1ContentItem
     */
    'revision_count': number;
    /**
     * 
     * @type {string}
     * @memberof V1ContentItem
     */
    'desc'?: string;
    /**
     * 
     * @type {string}
     * @memberof V1ContentItem
     */
    'uuid'?: string;
}
/**
 * 
 * @export
 * @interface V1ContentListResponse
 */
export interface V1ContentListResponse {
    /**
     * 
     * @type {number}
     * @memberof V1ContentListResponse
     */
    'draw': number;
    /**
     * 
     * @type {number}
     * @memberof V1ContentListResponse
     */
    'iTotalRecords': number;
    /**
     * 
     * @type {number}
     * @memberof V1ContentListResponse
     */
    'iTotalDisplayRecords': number;
    /**
     * 
     * @type {Array<V1ContentItem>}
     * @memberof V1ContentListResponse
     */
    'aaData': Array<V1ContentItem>;
}
/**
 * 
 * @export
 * @interface V1ContentRequest
 */
export interface V1ContentRequest {
    /**
     * The content URL. Must be relative and start with a leading \'/\'
     * @type {string}
     * @memberof V1ContentRequest
     */
    'url': string;
    /**
     * The content (e.g. html)
     * @type {string}
     * @memberof V1ContentRequest
     */
    'content': string;
    /**
     * If the asset should be published
     * @type {boolean}
     * @memberof V1ContentRequest
     */
    'published': boolean;
    /**
     * User defined timestamp for this content item
     * @type {number}
     * @memberof V1ContentRequest
     */
    'content_timestamp'?: number;
    /**
     * 
     * @type {V1Info}
     * @memberof V1ContentRequest
     */
    'info'?: V1Info;
    /**
     * 
     * @type {Array<V1Transition>}
     * @memberof V1ContentRequest
     */
    'transitions'?: Array<V1Transition>;
}
/**
 * 
 * @export
 * @interface V1DeleteResponse
 */
export interface V1DeleteResponse {
    /**
     * Indicates at least one error occurred
     * @type {boolean}
     * @memberof V1DeleteResponse
     */
    'error'?: boolean;
    /**
     * List of any errors
     * @type {Array<object>}
     * @memberof V1DeleteResponse
     */
    'errors'?: Array<object>;
    /**
     * 
     * @type {Array<V1Revision>}
     * @memberof V1DeleteResponse
     */
    'meta'?: Array<V1Revision>;
}
/**
 * 
 * @export
 * @interface V1Error
 */
export interface V1Error {
    /**
     * 
     * @type {boolean}
     * @memberof V1Error
     */
    'error': boolean;
    /**
     * 
     * @type {string}
     * @memberof V1Error
     */
    'message': string;
}
/**
 * 
 * @export
 * @interface V1FormSubmissionItem
 */
export interface V1FormSubmissionItem {
    /**
     * 
     * @type {string}
     * @memberof V1FormSubmissionItem
     */
    'uuid': string;
    /**
     * 
     * @type {string}
     * @memberof V1FormSubmissionItem
     */
    'country_ip': string;
    /**
     * 
     * @type {string}
     * @memberof V1FormSubmissionItem
     */
    'spam_score': string;
    /**
     * 
     * @type {string}
     * @memberof V1FormSubmissionItem
     */
    'data': string;
    /**
     * 
     * @type {number}
     * @memberof V1FormSubmissionItem
     */
    'file_count': number;
    /**
     * 
     * @type {string}
     * @memberof V1FormSubmissionItem
     */
    'date_submitted': string;
}
/**
 * 
 * @export
 * @interface V1FormSubmissionListResponse
 */
export interface V1FormSubmissionListResponse {
    /**
     * 
     * @type {number}
     * @memberof V1FormSubmissionListResponse
     */
    'draw': number;
    /**
     * 
     * @type {number}
     * @memberof V1FormSubmissionListResponse
     */
    'iTotalRecords': number;
    /**
     * 
     * @type {number}
     * @memberof V1FormSubmissionListResponse
     */
    'iTotalDisplayRecords': number;
    /**
     * 
     * @type {Array<V1FormSubmissionItem>}
     * @memberof V1FormSubmissionListResponse
     */
    'aaData': Array<V1FormSubmissionItem>;
}
/**
 * 
 * @export
 * @interface V1GetMetricSeriesResponse
 */
export interface V1GetMetricSeriesResponse {
    /**
     * 
     * @type {boolean}
     * @memberof V1GetMetricSeriesResponse
     */
    'success': boolean;
    /**
     * 
     * @type {V1GetMetricSeriesResponseData}
     * @memberof V1GetMetricSeriesResponse
     */
    'data': V1GetMetricSeriesResponseData;
}
/**
 * @type V1GetMetricSeriesResponseData
 * @export
 */
export type V1GetMetricSeriesResponseData = Array<V1SeriesPointDay> | Array<V1SeriesPointMonth> | { [key: string]: number; };

/**
 * 
 * @export
 * @interface V1GetMetricsResponse
 */
export interface V1GetMetricsResponse {
    /**
     * 
     * @type {boolean}
     * @memberof V1GetMetricsResponse
     */
    'success': boolean;
    /**
     * 
     * @type {V1GetMetricsResponseData}
     * @memberof V1GetMetricsResponse
     */
    'data': V1GetMetricsResponseData;
}
/**
 * @type V1GetMetricsResponseData
 * @export
 */
export type V1GetMetricsResponseData = { [key: string]: V1MetricDayStats; } | { [key: string]: V1MetricMinuteStats; } | { [key: string]: V1MetricMonthStats; };

/**
 * 
 * @export
 * @interface V1GlobalMetaResponse
 */
export interface V1GlobalMetaResponse {
    /**
     * 
     * @type {V1GlobalMetaResponseGlobalMeta}
     * @memberof V1GlobalMetaResponse
     */
    'global_meta'?: V1GlobalMetaResponseGlobalMeta;
    /**
     * 
     * @type {number}
     * @memberof V1GlobalMetaResponse
     */
    'total_records'?: number;
    /**
     * 
     * @type {number}
     * @memberof V1GlobalMetaResponse
     */
    'total_pages'?: number;
    /**
     * 
     * @type {number}
     * @memberof V1GlobalMetaResponse
     */
    'page'?: number;
    /**
     * 
     * @type {number}
     * @memberof V1GlobalMetaResponse
     */
    'page_size'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof V1GlobalMetaResponse
     */
    'refine_search'?: boolean;
}
/**
 * 
 * @export
 * @interface V1GlobalMetaResponseGlobalMeta
 */
export interface V1GlobalMetaResponseGlobalMeta {
    /**
     * 
     * @type {Array<object>}
     * @memberof V1GlobalMetaResponseGlobalMeta
     */
    'records'?: Array<object>;
}
/**
 * 
 * @export
 * @interface V1Info
 */
export interface V1Info {
    /**
     * 
     * @type {string}
     * @memberof V1Info
     */
    'author_user'?: string;
    /**
     * 
     * @type {string}
     * @memberof V1Info
     */
    'author_name'?: string;
    /**
     * 
     * @type {string}
     * @memberof V1Info
     */
    'author_email'?: string;
    /**
     * 
     * @type {string}
     * @memberof V1Info
     */
    'log'?: string;
    /**
     * 
     * @type {string}
     * @memberof V1Info
     */
    'custom_1'?: string;
    /**
     * 
     * @type {string}
     * @memberof V1Info
     */
    'custom_2'?: string;
    /**
     * 
     * @type {string}
     * @memberof V1Info
     */
    'source'?: string;
}
/**
 * 
 * @export
 * @interface V1Meta
 */
export interface V1Meta {
    /**
     * 
     * @type {string}
     * @memberof V1Meta
     */
    'url'?: string;
    /**
     * 
     * @type {string}
     * @memberof V1Meta
     */
    'type'?: string;
    /**
     * 
     * @type {number}
     * @memberof V1Meta
     */
    'seq_num'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof V1Meta
     */
    'published'?: boolean;
    /**
     * 
     * @type {number}
     * @memberof V1Meta
     */
    'published_revision'?: number;
    /**
     * 
     * @type {string}
     * @memberof V1Meta
     */
    'published_md5'?: string;
    /**
     * 
     * @type {number}
     * @memberof V1Meta
     */
    'byte_length'?: number;
    /**
     * 
     * @type {number}
     * @memberof V1Meta
     */
    'revision_count'?: number;
    /**
     * 
     * @type {number}
     * @memberof V1Meta
     */
    'highest_revision_number'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof V1Meta
     */
    'deleted'?: boolean;
    /**
     * 
     * @type {number}
     * @memberof V1Meta
     */
    'deleted_timestamp'?: number;
    /**
     * 
     * @type {string}
     * @memberof V1Meta
     */
    'md5'?: string;
    /**
     * 
     * @type {number}
     * @memberof V1Meta
     */
    'revision_number'?: number;
    /**
     * 
     * @type {number}
     * @memberof V1Meta
     */
    'date_timestamp'?: number;
}
/**
 * 
 * @export
 * @interface V1MetricDayStats
 */
export interface V1MetricDayStats {
    /**
     * 
     * @type {number}
     * @memberof V1MetricDayStats
     */
    'total': number;
    /**
     * 
     * @type {number}
     * @memberof V1MetricDayStats
     */
    'day_total': number;
    /**
     * 
     * @type {{ [key: string]: number; }}
     * @memberof V1MetricDayStats
     */
    'day_series': { [key: string]: number; };
    /**
     * 
     * @type {number}
     * @memberof V1MetricDayStats
     */
    'day_average': number;
}
/**
 * 
 * @export
 * @interface V1MetricMinuteStats
 */
export interface V1MetricMinuteStats {
    /**
     * 
     * @type {number}
     * @memberof V1MetricMinuteStats
     */
    'total': number;
    /**
     * 
     * @type {number}
     * @memberof V1MetricMinuteStats
     */
    'minute_total': number;
    /**
     * 
     * @type {{ [key: string]: number; }}
     * @memberof V1MetricMinuteStats
     */
    'minute_series': { [key: string]: number; };
    /**
     * 
     * @type {number}
     * @memberof V1MetricMinuteStats
     */
    'minute_average': number;
}
/**
 * 
 * @export
 * @interface V1MetricMonthStats
 */
export interface V1MetricMonthStats {
    /**
     * 
     * @type {number}
     * @memberof V1MetricMonthStats
     */
    'total': number;
    /**
     * 
     * @type {number}
     * @memberof V1MetricMonthStats
     */
    'month_total': number;
    /**
     * 
     * @type {{ [key: string]: number; }}
     * @memberof V1MetricMonthStats
     */
    'month_series': { [key: string]: number; };
    /**
     * 
     * @type {number}
     * @memberof V1MetricMonthStats
     */
    'month_average': number;
}
/**
 * 
 * @export
 * @interface V1PingResponse
 */
export interface V1PingResponse {
    /**
     * Configuration associated with a project
     * @type {object}
     * @memberof V1PingResponse
     */
    'config'?: object;
    /**
     * The project machine name
     * @type {string}
     * @memberof V1PingResponse
     */
    'project'?: string;
}
/**
 * 
 * @export
 * @interface V1ProxyItem
 */
export interface V1ProxyItem {
    /**
     * 
     * @type {string}
     * @memberof V1ProxyItem
     */
    'url': string;
    /**
     * 
     * @type {string}
     * @memberof V1ProxyItem
     */
    'proxy_url': string;
    /**
     * 
     * @type {string}
     * @memberof V1ProxyItem
     */
    'date_timestamp': string;
    /**
     * 
     * @type {string}
     * @memberof V1ProxyItem
     */
    'published': string;
    /**
     * 
     * @type {number}
     * @memberof V1ProxyItem
     */
    'revision_count': number;
}
/**
 * 
 * @export
 * @interface V1ProxyListResponse
 */
export interface V1ProxyListResponse {
    /**
     * 
     * @type {number}
     * @memberof V1ProxyListResponse
     */
    'draw': number;
    /**
     * 
     * @type {number}
     * @memberof V1ProxyListResponse
     */
    'iTotalRecords': number;
    /**
     * 
     * @type {number}
     * @memberof V1ProxyListResponse
     */
    'iTotalDisplayRecords': number;
    /**
     * 
     * @type {Array<V1ProxyItem>}
     * @memberof V1ProxyListResponse
     */
    'aaData': Array<V1ProxyItem>;
}
/**
 * 
 * @export
 * @interface V1RedirectItem
 */
export interface V1RedirectItem {
    /**
     * * @OA\\Schema(   schema=\"V1RedirectItem\",   type=\"object\",   required={\"url\",\"redirect_url\",\"redirect_http_code\",\"date_timestamp\",\"published\",\"revision_count\"},
     * @type {string}
     * @memberof V1RedirectItem
     */
    'url': string;
    /**
     * 
     * @type {string}
     * @memberof V1RedirectItem
     */
    'redirect_url': string;
    /**
     * 
     * @type {number}
     * @memberof V1RedirectItem
     */
    'redirect_http_code': number;
    /**
     * 
     * @type {string}
     * @memberof V1RedirectItem
     */
    'date_timestamp': string;
    /**
     * 
     * @type {string}
     * @memberof V1RedirectItem
     */
    'published': string;
    /**
     * 
     * @type {number}
     * @memberof V1RedirectItem
     */
    'revision_count': number;
}
/**
 * 
 * @export
 * @interface V1RedirectListResponse
 */
export interface V1RedirectListResponse {
    /**
     * 
     * @type {number}
     * @memberof V1RedirectListResponse
     */
    'draw': number;
    /**
     * 
     * @type {number}
     * @memberof V1RedirectListResponse
     */
    'iTotalRecords': number;
    /**
     * 
     * @type {number}
     * @memberof V1RedirectListResponse
     */
    'iTotalDisplayRecords': number;
    /**
     * 
     * @type {Array<V1RedirectItem>}
     * @memberof V1RedirectListResponse
     */
    'aaData': Array<V1RedirectItem>;
}
/**
 * 
 * @export
 * @interface V1RedirectRequest
 */
export interface V1RedirectRequest {
    /**
     * The redirect from URL
     * @type {string}
     * @memberof V1RedirectRequest
     */
    'url': string;
    /**
     * The destination URL
     * @type {string}
     * @memberof V1RedirectRequest
     */
    'redirect_url': string;
    /**
     * The HTTP code to send with the redirect
     * @type {number}
     * @memberof V1RedirectRequest
     */
    'redirect_http_code': number;
    /**
     * If the redirect is published
     * @type {boolean}
     * @memberof V1RedirectRequest
     */
    'published': boolean;
    /**
     * User defined timestamp for this content item
     * @type {number}
     * @memberof V1RedirectRequest
     */
    'content_timestamp'?: number;
    /**
     * 
     * @type {V1Info}
     * @memberof V1RedirectRequest
     */
    'info'?: V1Info;
    /**
     * 
     * @type {Array<V1Transition>}
     * @memberof V1RedirectRequest
     */
    'transitions'?: Array<V1Transition>;
}
/**
 * 
 * @export
 * @interface V1RedirectResponse
 */
export interface V1RedirectResponse {
    /**
     * 
     * @type {string}
     * @memberof V1RedirectResponse
     */
    'md5'?: string;
    /**
     * 
     * @type {string}
     * @memberof V1RedirectResponse
     */
    'type'?: string;
    /**
     * 
     * @type {number}
     * @memberof V1RedirectResponse
     */
    'byte_length'?: number;
    /**
     * 
     * @type {number}
     * @memberof V1RedirectResponse
     */
    'revision_number'?: number;
    /**
     * 
     * @type {number}
     * @memberof V1RedirectResponse
     */
    'date_timestamp'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof V1RedirectResponse
     */
    'deleted'?: boolean;
    /**
     * 
     * @type {number}
     * @memberof V1RedirectResponse
     */
    'deleted_timestamp'?: number;
    /**
     * 
     * @type {Array<V1Transition>}
     * @memberof V1RedirectResponse
     */
    'transitions'?: Array<V1Transition>;
    /**
     * 
     * @type {V1Info}
     * @memberof V1RedirectResponse
     */
    'info'?: V1Info;
    /**
     * The HTTP code
     * @type {number}
     * @memberof V1RedirectResponse
     */
    'redirect_http_code'?: number;
    /**
     * 
     * @type {string}
     * @memberof V1RedirectResponse
     */
    'highest_revision_number'?: string;
    /**
     * The redirect from URL
     * @type {string}
     * @memberof V1RedirectResponse
     */
    'url'?: string;
}
/**
 * 
 * @export
 * @interface V1Revision
 */
export interface V1Revision {
    /**
     * 
     * @type {string}
     * @memberof V1Revision
     */
    'md5'?: string;
    /**
     * 
     * @type {string}
     * @memberof V1Revision
     */
    'type'?: string;
    /**
     * 
     * @type {number}
     * @memberof V1Revision
     */
    'byte_length'?: number;
    /**
     * 
     * @type {number}
     * @memberof V1Revision
     */
    'revision_number'?: number;
    /**
     * 
     * @type {number}
     * @memberof V1Revision
     */
    'date_timestamp'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof V1Revision
     */
    'deleted'?: boolean;
    /**
     * 
     * @type {number}
     * @memberof V1Revision
     */
    'deleted_timestamp'?: number;
    /**
     * 
     * @type {Array<V1Transition>}
     * @memberof V1Revision
     */
    'transitions'?: Array<V1Transition>;
    /**
     * 
     * @type {V1Info}
     * @memberof V1Revision
     */
    'info'?: V1Info;
}
/**
 * 
 * @export
 * @interface V1RevisionsResponse
 */
export interface V1RevisionsResponse {
    /**
     * Revision objects, mapped by revision number
     * @type {object}
     * @memberof V1RevisionsResponse
     */
    'revisions'?: object;
    /**
     * The url of the asset
     * @type {string}
     * @memberof V1RevisionsResponse
     */
    'url'?: string;
    /**
     * Published state of the asset
     * @type {boolean}
     * @memberof V1RevisionsResponse
     */
    'published'?: boolean;
    /**
     * Published revision number of the asset
     * @type {number}
     * @memberof V1RevisionsResponse
     */
    'published_revision'?: number;
    /**
     * 
     * @type {Array<V1Transition>}
     * @memberof V1RevisionsResponse
     */
    'transitions'?: Array<V1Transition>;
    /**
     * Last revision number
     * @type {number}
     * @memberof V1RevisionsResponse
     */
    'highest_revision_number'?: number;
    /**
     * The transition number, if set
     * @type {number}
     * @memberof V1RevisionsResponse
     */
    'transition_revision'?: number;
}
/**
 * Generic search hit; fields vary by index
 * @export
 * @interface V1SearchHit
 */
export interface V1SearchHit {
    /**
     * The controller for managing Search integration.
     * @type {string}
     * @memberof V1SearchHit
     */
    'title'?: string;
    /**
     * 
     * @type {string}
     * @memberof V1SearchHit
     */
    'url'?: string;
    /**
     * 
     * @type {string}
     * @memberof V1SearchHit
     */
    'summary'?: string;
    /**
     * 
     * @type {string}
     * @memberof V1SearchHit
     */
    'content'?: string;
    /**
     * 
     * @type {string}
     * @memberof V1SearchHit
     */
    'image'?: string;
    /**
     * 
     * @type {string}
     * @memberof V1SearchHit
     */
    'objectID'?: string;
}
/**
 * 
 * @export
 * @interface V1SearchItemsResponse
 */
export interface V1SearchItemsResponse {
    /**
     * 
     * @type {Array<V1SearchHit>}
     * @memberof V1SearchItemsResponse
     */
    'hits'?: Array<V1SearchHit>;
    /**
     * 
     * @type {number}
     * @memberof V1SearchItemsResponse
     */
    'nbPages'?: number;
}
/**
 * 
 * @export
 * @interface V1SearchMutationResponse
 */
export interface V1SearchMutationResponse {
    /**
     * 
     * @type {boolean}
     * @memberof V1SearchMutationResponse
     */
    'success': boolean;
    /**
     * 
     * @type {string}
     * @memberof V1SearchMutationResponse
     */
    'message': string;
    /**
     * 
     * @type {object}
     * @memberof V1SearchMutationResponse
     */
    'result'?: object;
}
/**
 * 
 * @export
 * @interface V1SearchRecord
 */
export interface V1SearchRecord {
    /**
     * 
     * @type {string}
     * @memberof V1SearchRecord
     */
    'title'?: string;
    /**
     * 
     * @type {string}
     * @memberof V1SearchRecord
     */
    'content'?: string;
    /**
     * 
     * @type {string}
     * @memberof V1SearchRecord
     */
    'url'?: string;
    /**
     * 
     * @type {string}
     * @memberof V1SearchRecord
     */
    'summary'?: string;
}
/**
 * 
 * @export
 * @interface V1SearchResponse
 */
export interface V1SearchResponse {
    /**
     * Search configuration for the index
     * @type {object}
     * @memberof V1SearchResponse
     */
    'settings'?: object;
    /**
     * Detail related to index size and status
     * @type {object}
     * @memberof V1SearchResponse
     */
    'index'?: object;
}
/**
 * 
 * @export
 * @interface V1SeriesPointDay
 */
export interface V1SeriesPointDay {
    /**
     * 
     * @type {string}
     * @memberof V1SeriesPointDay
     */
    'x': string;
    /**
     * 
     * @type {number}
     * @memberof V1SeriesPointDay
     */
    'y': number;
}
/**
 * 
 * @export
 * @interface V1SeriesPointMonth
 */
export interface V1SeriesPointMonth {
    /**
     * 
     * @type {string}
     * @memberof V1SeriesPointMonth
     */
    'x': string;
    /**
     * 
     * @type {number}
     * @memberof V1SeriesPointMonth
     */
    'y': number;
}
/**
 * 
 * @export
 * @interface V1Transition
 */
export interface V1Transition {
    /**
     * 
     * @type {string}
     * @memberof V1Transition
     */
    'state'?: V1TransitionStateEnum;
    /**
     * 
     * @type {number}
     * @memberof V1Transition
     */
    'date_timestamp'?: number;
}

export const V1TransitionStateEnum = {
    Published: 'published',
    Unpublished: 'unpublished'
} as const;

export type V1TransitionStateEnum = typeof V1TransitionStateEnum[keyof typeof V1TransitionStateEnum];

/**
 * 
 * @export
 * @interface V1UploadResponse
 */
export interface V1UploadResponse {
    /**
     * 
     * @type {boolean}
     * @memberof V1UploadResponse
     */
    'success': boolean;
    /**
     * 
     * @type {string}
     * @memberof V1UploadResponse
     */
    'url': string;
}
/**
 * 
 * @export
 * @interface V1UrlMetaRequest
 */
export interface V1UrlMetaRequest {
    /**
     * 
     * @type {Array<string>}
     * @memberof V1UrlMetaRequest
     */
    'Quant-Url': Array<string>;
}
/**
 * 
 * @export
 * @interface V1UrlMetaResponse
 */
export interface V1UrlMetaResponse {
    /**
     * 
     * @type {V1GlobalMetaResponseGlobalMeta}
     * @memberof V1UrlMetaResponse
     */
    'global_meta'?: V1GlobalMetaResponseGlobalMeta;
}
/**
 * 
 * @export
 * @interface V1WafLogItem
 */
export interface V1WafLogItem {
    /**
     * 
     * @type {string}
     * @memberof V1WafLogItem
     */
    'timestamp': string;
    /**
     * 
     * @type {string}
     * @memberof V1WafLogItem
     */
    'ip_address': string;
    /**
     * 
     * @type {string}
     * @memberof V1WafLogItem
     */
    'location': string;
    /**
     * 
     * @type {string}
     * @memberof V1WafLogItem
     */
    'asn': string;
    /**
     * 
     * @type {string}
     * @memberof V1WafLogItem
     */
    'type': string;
    /**
     * 
     * @type {string}
     * @memberof V1WafLogItem
     */
    'mode': string;
    /**
     * 
     * @type {string}
     * @memberof V1WafLogItem
     */
    'rule_id': string;
    /**
     * 
     * @type {string}
     * @memberof V1WafLogItem
     */
    'domain': string;
    /**
     * 
     * @type {string}
     * @memberof V1WafLogItem
     */
    'url': string;
    /**
     * 
     * @type {string}
     * @memberof V1WafLogItem
     */
    'method': string;
    /**
     * 
     * @type {string}
     * @memberof V1WafLogItem
     */
    'user_agent': string;
}
/**
 * 
 * @export
 * @interface V1WafLogListResponse
 */
export interface V1WafLogListResponse {
    /**
     * 
     * @type {number}
     * @memberof V1WafLogListResponse
     */
    'draw': number;
    /**
     * 
     * @type {number}
     * @memberof V1WafLogListResponse
     */
    'iTotalRecords': number;
    /**
     * 
     * @type {number}
     * @memberof V1WafLogListResponse
     */
    'iTotalDisplayRecords': number;
    /**
     * 
     * @type {Array<V1WafLogItem>}
     * @memberof V1WafLogListResponse
     */
    'aaData': Array<V1WafLogItem>;
}
/**
 * 
 * @export
 * @interface V2Crawler
 */
export interface V2Crawler {
    /**
     * Crawler ID
     * @type {number}
     * @memberof V2Crawler
     */
    'id': number;
    /**
     * Crawler name
     * @type {string}
     * @memberof V2Crawler
     */
    'name'?: string;
    /**
     * Project ID
     * @type {number}
     * @memberof V2Crawler
     */
    'project_id': number;
    /**
     * Crawler UUID
     * @type {string}
     * @memberof V2Crawler
     */
    'uuid': string;
    /**
     * Crawler configuration (YAML)
     * @type {string}
     * @memberof V2Crawler
     */
    'config': string;
    /**
     * Crawler domain
     * @type {string}
     * @memberof V2Crawler
     */
    'domain': string;
    /**
     * Domain verification status
     * @type {number}
     * @memberof V2Crawler
     */
    'domain_verified'?: number;
    /**
     * URLs list (YAML)
     * @type {string}
     * @memberof V2Crawler
     */
    'urls_list'?: string;
    /**
     * Creation timestamp
     * @type {string}
     * @memberof V2Crawler
     */
    'created_at'?: string;
    /**
     * Last update timestamp
     * @type {string}
     * @memberof V2Crawler
     */
    'updated_at'?: string;
    /**
     * Deletion timestamp
     * @type {string}
     * @memberof V2Crawler
     */
    'deleted_at'?: string;
}
/**
 * 
 * @export
 * @interface V2CrawlerRequest
 */
export interface V2CrawlerRequest {
    /**
     * Crawler name
     * @type {string}
     * @memberof V2CrawlerRequest
     */
    'name'?: string;
    /**
     * Domain to crawl
     * @type {string}
     * @memberof V2CrawlerRequest
     */
    'domain': string;
    /**
     * Enable browser mode
     * @type {boolean}
     * @memberof V2CrawlerRequest
     */
    'browser_mode'?: boolean;
    /**
     * Execute JavaScript during asset collection (only when browser_mode is enabled)
     * @type {boolean}
     * @memberof V2CrawlerRequest
     */
    'execute_js'?: boolean;
    /**
     * URLs to crawl
     * @type {Array<string>}
     * @memberof V2CrawlerRequest
     */
    'urls'?: Array<string>;
    /**
     * Starting URLs for crawl
     * @type {Array<string>}
     * @memberof V2CrawlerRequest
     */
    'start_urls'?: Array<string>;
    /**
     * Custom headers
     * @type {{ [key: string]: string; }}
     * @memberof V2CrawlerRequest
     */
    'headers'?: { [key: string]: string; };
    /**
     * URL patterns to exclude (regex)
     * @type {Array<string>}
     * @memberof V2CrawlerRequest
     */
    'exclude'?: Array<string>;
    /**
     * URL patterns to include (regex)
     * @type {Array<string>}
     * @memberof V2CrawlerRequest
     */
    'include'?: Array<string>;
    /**
     * Webhook URL for notifications
     * @type {string}
     * @memberof V2CrawlerRequest
     */
    'webhook_url'?: string;
    /**
     * Authorization header for webhook
     * @type {string}
     * @memberof V2CrawlerRequest
     */
    'webhook_auth_header'?: string;
    /**
     * Extra variables for webhook
     * @type {string}
     * @memberof V2CrawlerRequest
     */
    'webhook_extra_vars'?: string;
    /**
     * Number of concurrent workers (verified domains only)
     * @type {number}
     * @memberof V2CrawlerRequest
     */
    'workers'?: number;
    /**
     * Delay between requests in seconds (verified domains only)
     * @type {number}
     * @memberof V2CrawlerRequest
     */
    'delay'?: number;
    /**
     * Maximum crawl depth, -1 for unlimited (verified domains only)
     * @type {number}
     * @memberof V2CrawlerRequest
     */
    'depth'?: number;
    /**
     * Maximum total requests, 0 for unlimited (verified domains only)
     * @type {number}
     * @memberof V2CrawlerRequest
     */
    'max_hits'?: number;
    /**
     * Maximum HTML pages, 0 for unlimited (verified domains only)
     * @type {number}
     * @memberof V2CrawlerRequest
     */
    'max_html'?: number;
    /**
     * HTTP status codes that will result in content being captured and pushed to Quant (verified domains only)
     * @type {Array<number>}
     * @memberof V2CrawlerRequest
     */
    'status_ok'?: Array<number>;
    /**
     * Sitemap configuration (verified domains only)
     * @type {Array<object>}
     * @memberof V2CrawlerRequest
     */
    'sitemap'?: Array<object>;
    /**
     * Allowed domains for multi-domain crawling, automatically enables merge_domains (verified domains only)
     * @type {Array<string>}
     * @memberof V2CrawlerRequest
     */
    'allowed_domains'?: Array<string>;
    /**
     * Custom user agent, only when browser_mode is false (verified domains only)
     * @type {string}
     * @memberof V2CrawlerRequest
     */
    'user_agent'?: string;
    /**
     * Asset harvesting configuration (verified domains only)
     * @type {object}
     * @memberof V2CrawlerRequest
     */
    'assets'?: object;
    /**
     * Maximum errors before stopping crawl (verified domains only)
     * @type {number}
     * @memberof V2CrawlerRequest
     */
    'max_errors'?: number;
}
/**
 * 
 * @export
 * @interface V2CrawlerSchedule
 */
export interface V2CrawlerSchedule {
    /**
     * Error message
     * @type {string}
     * @memberof V2CrawlerSchedule
     */
    'message': string;
    /**
     * Error flag
     * @type {boolean}
     * @memberof V2CrawlerSchedule
     */
    'error': boolean;
    /**
     * Schedule ID
     * @type {number}
     * @memberof V2CrawlerSchedule
     */
    'id': number;
    /**
     * Schedule name
     * @type {string}
     * @memberof V2CrawlerSchedule
     */
    'name'?: string;
    /**
     * Crawler config ID
     * @type {number}
     * @memberof V2CrawlerSchedule
     */
    'crawler_config_id': number;
    /**
     * Project ID
     * @type {number}
     * @memberof V2CrawlerSchedule
     */
    'project_id': number;
    /**
     * Last run ID
     * @type {number}
     * @memberof V2CrawlerSchedule
     */
    'crawler_last_run_id': number;
    /**
     * Cron schedule string
     * @type {string}
     * @memberof V2CrawlerSchedule
     */
    'schedule_cron_string': string;
    /**
     * Creation timestamp
     * @type {string}
     * @memberof V2CrawlerSchedule
     */
    'created_at'?: string;
    /**
     * Last update timestamp
     * @type {string}
     * @memberof V2CrawlerSchedule
     */
    'updated_at'?: string;
}
/**
 * 
 * @export
 * @interface V2CrawlerScheduleRequest
 */
export interface V2CrawlerScheduleRequest {
    /**
     * Error message
     * @type {string}
     * @memberof V2CrawlerScheduleRequest
     */
    'message': string;
    /**
     * Error flag
     * @type {boolean}
     * @memberof V2CrawlerScheduleRequest
     */
    'error': boolean;
    /**
     * Schedule name
     * @type {string}
     * @memberof V2CrawlerScheduleRequest
     */
    'name': string;
    /**
     * Cron schedule string
     * @type {string}
     * @memberof V2CrawlerScheduleRequest
     */
    'schedule_cron_string': string;
}
/**
 * 
 * @export
 * @interface V2CustomHeaderRequest
 */
export interface V2CustomHeaderRequest {
    /**
     * Custom headers
     * @type {{ [key: string]: string; }}
     * @memberof V2CustomHeaderRequest
     */
    'headers': { [key: string]: string; };
}
/**
 * 
 * @export
 * @interface V2Domain
 */
export interface V2Domain {
    /**
     * Error message
     * @type {string}
     * @memberof V2Domain
     */
    'message': string;
    /**
     * Error flag
     * @type {boolean}
     * @memberof V2Domain
     */
    'error': boolean;
    /**
     * Domain ID
     * @type {number}
     * @memberof V2Domain
     */
    'id': number;
    /**
     * Domain name
     * @type {string}
     * @memberof V2Domain
     */
    'domain': string;
    /**
     * DNS engagement status
     * @type {number}
     * @memberof V2Domain
     */
    'dns_engaged': number;
}
/**
 * 
 * @export
 * @interface V2DomainRequest
 */
export interface V2DomainRequest {
    /**
     * Error message
     * @type {string}
     * @memberof V2DomainRequest
     */
    'message': string;
    /**
     * Error flag
     * @type {boolean}
     * @memberof V2DomainRequest
     */
    'error': boolean;
    /**
     * Domain name
     * @type {string}
     * @memberof V2DomainRequest
     */
    'domain': string;
}
/**
 * 
 * @export
 * @interface V2Error
 */
export interface V2Error {
    /**
     * Error message
     * @type {string}
     * @memberof V2Error
     */
    'message': string;
    /**
     * Error flag
     * @type {boolean}
     * @memberof V2Error
     */
    'error': boolean;
}
/**
 * 
 * @export
 * @interface V2Organization
 */
export interface V2Organization {
    /**
     * Error message
     * @type {string}
     * @memberof V2Organization
     */
    'message': string;
    /**
     * Error flag
     * @type {boolean}
     * @memberof V2Organization
     */
    'error': boolean;
    /**
     * Organization name
     * @type {string}
     * @memberof V2Organization
     */
    'name': string;
    /**
     * Organization machine name
     * @type {string}
     * @memberof V2Organization
     */
    'machine_name': string;
    /**
     * Organization type
     * @type {string}
     * @memberof V2Organization
     */
    'type'?: string;
    /**
     * Organization region
     * @type {string}
     * @memberof V2Organization
     */
    'region'?: string;
    /**
     * Subscription type
     * @type {string}
     * @memberof V2Organization
     */
    'subscription'?: string;
    /**
     * Creation timestamp
     * @type {string}
     * @memberof V2Organization
     */
    'created_at'?: string;
    /**
     * Last update timestamp
     * @type {string}
     * @memberof V2Organization
     */
    'updated_at'?: string;
}
/**
 * 
 * @export
 * @interface V2OrganizationRequest
 */
export interface V2OrganizationRequest {
    /**
     * Error message
     * @type {string}
     * @memberof V2OrganizationRequest
     */
    'message': string;
    /**
     * Error flag
     * @type {boolean}
     * @memberof V2OrganizationRequest
     */
    'error': boolean;
    /**
     * Organization name
     * @type {string}
     * @memberof V2OrganizationRequest
     */
    'name': string;
    /**
     * Organization machine name
     * @type {string}
     * @memberof V2OrganizationRequest
     */
    'machine_name': string;
}
/**
 * 
 * @export
 * @interface V2Project
 */
export interface V2Project {
    /**
     * Error message
     * @type {string}
     * @memberof V2Project
     */
    'message': string;
    /**
     * Error flag
     * @type {boolean}
     * @memberof V2Project
     */
    'error': boolean;
    /**
     * Project name
     * @type {string}
     * @memberof V2Project
     */
    'name': string;
    /**
     * Project machine name
     * @type {string}
     * @memberof V2Project
     */
    'machine_name': string;
}
/**
 * 
 * @export
 * @interface V2ProjectRequest
 */
export interface V2ProjectRequest {
    /**
     * Error message
     * @type {string}
     * @memberof V2ProjectRequest
     */
    'message': string;
    /**
     * Error flag
     * @type {boolean}
     * @memberof V2ProjectRequest
     */
    'error': boolean;
    /**
     * Project name
     * @type {string}
     * @memberof V2ProjectRequest
     */
    'name': string;
    /**
     * Project machine name
     * @type {string}
     * @memberof V2ProjectRequest
     */
    'machine_name': string;
    /**
     * Project region
     * @type {string}
     * @memberof V2ProjectRequest
     */
    'region'?: string;
    /**
     * Allow query parameters
     * @type {boolean}
     * @memberof V2ProjectRequest
     */
    'allow_query_params'?: boolean;
    /**
     * Disable revisions
     * @type {boolean}
     * @memberof V2ProjectRequest
     */
    'disable_revisions'?: boolean;
    /**
     * Basic auth username
     * @type {string}
     * @memberof V2ProjectRequest
     */
    'basic_auth_username'?: string;
    /**
     * Basic auth password
     * @type {string}
     * @memberof V2ProjectRequest
     */
    'basic_auth_password'?: string;
}
/**
 * 
 * @export
 * @interface V2Rule
 */
export interface V2Rule {
    /**
     * Error message
     * @type {string}
     * @memberof V2Rule
     */
    'message': string;
    /**
     * Error flag
     * @type {boolean}
     * @memberof V2Rule
     */
    'error': boolean;
    /**
     * Rule name
     * @type {string}
     * @memberof V2Rule
     */
    'name'?: string;
    /**
     * Rule UUID
     * @type {string}
     * @memberof V2Rule
     */
    'uuid': string;
    /**
     * Rule ID
     * @type {string}
     * @memberof V2Rule
     */
    'rule_id'?: string;
    /**
     * Rule weight
     * @type {number}
     * @memberof V2Rule
     */
    'weight'?: number;
    /**
     * URL patterns
     * @type {Array<string>}
     * @memberof V2Rule
     */
    'url'?: Array<string>;
    /**
     * Domain patterns
     * @type {Array<string>}
     * @memberof V2Rule
     */
    'domain'?: Array<string>;
    /**
     * Whether rule is disabled
     * @type {boolean}
     * @memberof V2Rule
     */
    'disabled': boolean;
    /**
     * Only apply with cookie
     * @type {string}
     * @memberof V2Rule
     */
    'only_with_cookie'?: string;
    /**
     * HTTP method
     * @type {string}
     * @memberof V2Rule
     */
    'method'?: string;
    /**
     * Allowed HTTP methods
     * @type {Array<string>}
     * @memberof V2Rule
     */
    'method_is'?: Array<string>;
    /**
     * Excluded HTTP methods
     * @type {Array<string>}
     * @memberof V2Rule
     */
    'method_is_not'?: Array<string>;
    /**
     * IP address
     * @type {string}
     * @memberof V2Rule
     */
    'ip'?: string;
    /**
     * Allowed IP addresses
     * @type {Array<string>}
     * @memberof V2Rule
     */
    'ip_is'?: Array<string>;
    /**
     * Excluded IP addresses
     * @type {Array<string>}
     * @memberof V2Rule
     */
    'ip_is_not'?: Array<string>;
    /**
     * Country code
     * @type {string}
     * @memberof V2Rule
     */
    'country'?: string;
    /**
     * Allowed countries
     * @type {Array<string>}
     * @memberof V2Rule
     */
    'country_is'?: Array<string>;
    /**
     * Excluded countries
     * @type {Array<string>}
     * @memberof V2Rule
     */
    'country_is_not'?: Array<string>;
    /**
     * Rule action
     * @type {string}
     * @memberof V2Rule
     */
    'action': string;
}
/**
 * 
 * @export
 * @interface V2RuleAuth
 */
export interface V2RuleAuth {
    /**
     * Error message
     * @type {string}
     * @memberof V2RuleAuth
     */
    'message': string;
    /**
     * Error flag
     * @type {boolean}
     * @memberof V2RuleAuth
     */
    'error': boolean;
    /**
     * Rule name
     * @type {string}
     * @memberof V2RuleAuth
     */
    'name'?: string;
    /**
     * Rule UUID
     * @type {string}
     * @memberof V2RuleAuth
     */
    'uuid': string;
    /**
     * Rule ID
     * @type {string}
     * @memberof V2RuleAuth
     */
    'rule_id'?: string;
    /**
     * Rule weight
     * @type {number}
     * @memberof V2RuleAuth
     */
    'weight'?: number;
    /**
     * URL patterns
     * @type {Array<string>}
     * @memberof V2RuleAuth
     */
    'url'?: Array<string>;
    /**
     * Domain patterns
     * @type {Array<string>}
     * @memberof V2RuleAuth
     */
    'domain'?: Array<string>;
    /**
     * Whether rule is disabled
     * @type {boolean}
     * @memberof V2RuleAuth
     */
    'disabled': boolean;
    /**
     * Only apply with cookie
     * @type {string}
     * @memberof V2RuleAuth
     */
    'only_with_cookie'?: string;
    /**
     * HTTP method
     * @type {string}
     * @memberof V2RuleAuth
     */
    'method'?: string;
    /**
     * Allowed HTTP methods
     * @type {Array<string>}
     * @memberof V2RuleAuth
     */
    'method_is'?: Array<string>;
    /**
     * Excluded HTTP methods
     * @type {Array<string>}
     * @memberof V2RuleAuth
     */
    'method_is_not'?: Array<string>;
    /**
     * IP address
     * @type {string}
     * @memberof V2RuleAuth
     */
    'ip'?: string;
    /**
     * Allowed IP addresses
     * @type {Array<string>}
     * @memberof V2RuleAuth
     */
    'ip_is'?: Array<string>;
    /**
     * Excluded IP addresses
     * @type {Array<string>}
     * @memberof V2RuleAuth
     */
    'ip_is_not'?: Array<string>;
    /**
     * Country code
     * @type {string}
     * @memberof V2RuleAuth
     */
    'country'?: string;
    /**
     * Allowed countries
     * @type {Array<string>}
     * @memberof V2RuleAuth
     */
    'country_is'?: Array<string>;
    /**
     * Excluded countries
     * @type {Array<string>}
     * @memberof V2RuleAuth
     */
    'country_is_not'?: Array<string>;
    /**
     * Rule action
     * @type {string}
     * @memberof V2RuleAuth
     */
    'action': string;
    /**
     * Target URL to proxy to
     * @type {string}
     * @memberof V2RuleAuth
     */
    'to': string;
    /**
     * Host header override
     * @type {string}
     * @memberof V2RuleAuth
     */
    'host'?: string;
    /**
     * Basic auth username
     * @type {string}
     * @memberof V2RuleAuth
     */
    'auth_user'?: string;
    /**
     * Basic auth password
     * @type {string}
     * @memberof V2RuleAuth
     */
    'auth_pass'?: string;
    /**
     * Disable SSL verification
     * @type {boolean}
     * @memberof V2RuleAuth
     */
    'disable_ssl_verify'?: boolean;
    /**
     * Cache lifetime
     * @type {string}
     * @memberof V2RuleAuth
     */
    'cache_lifetime'?: string | null;
    /**
     * Only proxy 404 responses
     * @type {boolean}
     * @memberof V2RuleAuth
     */
    'only_proxy_404'?: boolean;
    /**
     * Headers to inject
     * @type {{ [key: string]: string; }}
     * @memberof V2RuleAuth
     */
    'inject_headers'?: { [key: string]: string; } | null;
    /**
     * Headers to strip from response
     * @type {Array<string>}
     * @memberof V2RuleAuth
     */
    'proxy_strip_headers'?: Array<string>;
    /**
     * Headers to strip from request
     * @type {Array<string>}
     * @memberof V2RuleAuth
     */
    'proxy_strip_request_headers'?: Array<string>;
    /**
     * Origin timeout
     * @type {string}
     * @memberof V2RuleAuth
     */
    'origin_timeout'?: string;
    /**
     * Enable failover mode
     * @type {boolean}
     * @memberof V2RuleAuth
     */
    'failover_mode'?: boolean;
    /**
     * Failover TTFB threshold
     * @type {string}
     * @memberof V2RuleAuth
     */
    'failover_origin_ttfb'?: string;
    /**
     * Status codes for failover (default: 200,404,301,302,304)
     * @type {Array<string>}
     * @memberof V2RuleAuth
     */
    'failover_origin_status_codes'?: Array<string>;
    /**
     * Failover cache lifetime
     * @type {string}
     * @memberof V2RuleAuth
     */
    'failover_lifetime'?: string;
    /**
     * Notification type (none, slack)
     * @type {string}
     * @memberof V2RuleAuth
     */
    'notify'?: V2RuleAuthNotifyEnum;
    /**
     * 
     * @type {V2RuleProxyActionAllOfNotifyConfig}
     * @memberof V2RuleAuth
     */
    'notify_config'?: V2RuleProxyActionAllOfNotifyConfig | null;
    /**
     * WAF enabled
     * @type {boolean}
     * @memberof V2RuleAuth
     */
    'waf_enabled'?: boolean;
    /**
     * 
     * @type {WafConfig}
     * @memberof V2RuleAuth
     */
    'waf_config'?: WafConfig;
    /**
     * Proxy alert enabled
     * @type {boolean}
     * @memberof V2RuleAuth
     */
    'proxy_alert_enabled'?: boolean;
    /**
     * Proxy inline function enabled
     * @type {boolean}
     * @memberof V2RuleAuth
     */
    'proxy_inline_fn_enabled'?: boolean;
    /**
     * 
     * @type {V2RuleProxyActionAllOfQuantCloudSelection}
     * @memberof V2RuleAuth
     */
    'quant_cloud_selection'?: V2RuleProxyActionAllOfQuantCloudSelection | null;
    /**
     * 
     * @type {V2RuleAuthAction}
     * @memberof V2RuleAuth
     */
    'action_config': V2RuleAuthAction;
}

export const V2RuleAuthNotifyEnum = {
    None: 'none',
    Slack: 'slack'
} as const;

export type V2RuleAuthNotifyEnum = typeof V2RuleAuthNotifyEnum[keyof typeof V2RuleAuthNotifyEnum];

/**
 * 
 * @export
 * @interface V2RuleAuthAction
 */
export interface V2RuleAuthAction {
    /**
     * Error message
     * @type {string}
     * @memberof V2RuleAuthAction
     */
    'message': string;
    /**
     * Error flag
     * @type {boolean}
     * @memberof V2RuleAuthAction
     */
    'error': boolean;
    /**
     * Target URL to proxy to
     * @type {string}
     * @memberof V2RuleAuthAction
     */
    'to': string;
    /**
     * Host header override
     * @type {string}
     * @memberof V2RuleAuthAction
     */
    'host'?: string;
    /**
     * Authentication username
     * @type {string}
     * @memberof V2RuleAuthAction
     */
    'auth_user': string;
    /**
     * Authentication password
     * @type {string}
     * @memberof V2RuleAuthAction
     */
    'auth_pass': string;
    /**
     * Disable SSL verification
     * @type {boolean}
     * @memberof V2RuleAuthAction
     */
    'disable_ssl_verify'?: boolean;
    /**
     * Cache lifetime
     * @type {string}
     * @memberof V2RuleAuthAction
     */
    'cache_lifetime'?: string | null;
    /**
     * Only proxy 404 responses
     * @type {boolean}
     * @memberof V2RuleAuthAction
     */
    'only_proxy_404'?: boolean;
    /**
     * Headers to inject
     * @type {{ [key: string]: string; }}
     * @memberof V2RuleAuthAction
     */
    'inject_headers'?: { [key: string]: string; } | null;
    /**
     * Headers to strip from response
     * @type {Array<string>}
     * @memberof V2RuleAuthAction
     */
    'proxy_strip_headers'?: Array<string>;
    /**
     * Headers to strip from request
     * @type {Array<string>}
     * @memberof V2RuleAuthAction
     */
    'proxy_strip_request_headers'?: Array<string>;
    /**
     * Origin timeout
     * @type {string}
     * @memberof V2RuleAuthAction
     */
    'origin_timeout'?: string;
    /**
     * Enable failover mode
     * @type {boolean}
     * @memberof V2RuleAuthAction
     */
    'failover_mode'?: boolean;
    /**
     * Failover TTFB threshold
     * @type {string}
     * @memberof V2RuleAuthAction
     */
    'failover_origin_ttfb'?: string;
    /**
     * Status codes for failover (default: 200,404,301,302,304)
     * @type {Array<string>}
     * @memberof V2RuleAuthAction
     */
    'failover_origin_status_codes'?: Array<string>;
    /**
     * Failover cache lifetime
     * @type {string}
     * @memberof V2RuleAuthAction
     */
    'failover_lifetime'?: string;
    /**
     * Notification type (none, slack)
     * @type {string}
     * @memberof V2RuleAuthAction
     */
    'notify'?: V2RuleAuthActionNotifyEnum;
    /**
     * 
     * @type {V2RuleProxyActionAllOfNotifyConfig}
     * @memberof V2RuleAuthAction
     */
    'notify_config'?: V2RuleProxyActionAllOfNotifyConfig | null;
    /**
     * WAF enabled
     * @type {boolean}
     * @memberof V2RuleAuthAction
     */
    'waf_enabled'?: boolean;
    /**
     * 
     * @type {WafConfig}
     * @memberof V2RuleAuthAction
     */
    'waf_config'?: WafConfig;
    /**
     * Proxy alert enabled
     * @type {boolean}
     * @memberof V2RuleAuthAction
     */
    'proxy_alert_enabled'?: boolean;
    /**
     * Proxy inline function enabled
     * @type {boolean}
     * @memberof V2RuleAuthAction
     */
    'proxy_inline_fn_enabled'?: boolean;
    /**
     * 
     * @type {V2RuleProxyActionAllOfQuantCloudSelection}
     * @memberof V2RuleAuthAction
     */
    'quant_cloud_selection'?: V2RuleProxyActionAllOfQuantCloudSelection | null;
}

export const V2RuleAuthActionNotifyEnum = {
    None: 'none',
    Slack: 'slack'
} as const;

export type V2RuleAuthActionNotifyEnum = typeof V2RuleAuthActionNotifyEnum[keyof typeof V2RuleAuthActionNotifyEnum];

/**
 * 
 * @export
 * @interface V2RuleAuthRequest
 */
export interface V2RuleAuthRequest {
    /**
     * Error message
     * @type {string}
     * @memberof V2RuleAuthRequest
     */
    'message': string;
    /**
     * Error flag
     * @type {boolean}
     * @memberof V2RuleAuthRequest
     */
    'error': boolean;
    /**
     * Domain patterns (default: any)
     * @type {Array<string>}
     * @memberof V2RuleAuthRequest
     */
    'domain': Array<string>;
    /**
     * Rule name
     * @type {string}
     * @memberof V2RuleAuthRequest
     */
    'name'?: string;
    /**
     * Rule UUID
     * @type {string}
     * @memberof V2RuleAuthRequest
     */
    'uuid'?: string;
    /**
     * Rule weight
     * @type {number}
     * @memberof V2RuleAuthRequest
     */
    'weight'?: number;
    /**
     * Whether rule is disabled
     * @type {boolean}
     * @memberof V2RuleAuthRequest
     */
    'disabled'?: boolean;
    /**
     * URL patterns
     * @type {Array<string>}
     * @memberof V2RuleAuthRequest
     */
    'url': Array<string>;
    /**
     * Country filter type (country_is, country_is_not, any)
     * @type {string}
     * @memberof V2RuleAuthRequest
     */
    'country'?: string;
    /**
     * Allowed countries
     * @type {Array<string>}
     * @memberof V2RuleAuthRequest
     */
    'country_is'?: Array<string>;
    /**
     * Excluded countries
     * @type {Array<string>}
     * @memberof V2RuleAuthRequest
     */
    'country_is_not'?: Array<string>;
    /**
     * Method filter type (method_is, method_is_not, any)
     * @type {string}
     * @memberof V2RuleAuthRequest
     */
    'method'?: string;
    /**
     * Allowed HTTP methods
     * @type {Array<string>}
     * @memberof V2RuleAuthRequest
     */
    'method_is'?: Array<string>;
    /**
     * Excluded HTTP methods
     * @type {Array<string>}
     * @memberof V2RuleAuthRequest
     */
    'method_is_not'?: Array<string>;
    /**
     * IP filter type (ip_is, ip_is_not, any)
     * @type {string}
     * @memberof V2RuleAuthRequest
     */
    'ip'?: string;
    /**
     * Allowed IP addresses
     * @type {Array<string>}
     * @memberof V2RuleAuthRequest
     */
    'ip_is'?: Array<string>;
    /**
     * Excluded IP addresses
     * @type {Array<string>}
     * @memberof V2RuleAuthRequest
     */
    'ip_is_not'?: Array<string>;
    /**
     * Target URL to proxy to
     * @type {string}
     * @memberof V2RuleAuthRequest
     */
    'to': string;
    /**
     * Host header override
     * @type {string}
     * @memberof V2RuleAuthRequest
     */
    'host'?: string;
    /**
     * Authentication username
     * @type {string}
     * @memberof V2RuleAuthRequest
     */
    'auth_user': string;
    /**
     * Authentication password
     * @type {string}
     * @memberof V2RuleAuthRequest
     */
    'auth_pass': string;
    /**
     * Disable SSL verification
     * @type {boolean}
     * @memberof V2RuleAuthRequest
     */
    'disable_ssl_verify'?: boolean;
    /**
     * Cache lifetime
     * @type {string}
     * @memberof V2RuleAuthRequest
     */
    'cache_lifetime'?: string | null;
    /**
     * Only proxy 404 responses
     * @type {boolean}
     * @memberof V2RuleAuthRequest
     */
    'only_proxy_404'?: boolean;
    /**
     * Headers to inject
     * @type {{ [key: string]: string; }}
     * @memberof V2RuleAuthRequest
     */
    'inject_headers'?: { [key: string]: string; } | null;
    /**
     * Headers to strip from response
     * @type {Array<string>}
     * @memberof V2RuleAuthRequest
     */
    'proxy_strip_headers'?: Array<string>;
    /**
     * Headers to strip from request
     * @type {Array<string>}
     * @memberof V2RuleAuthRequest
     */
    'proxy_strip_request_headers'?: Array<string>;
    /**
     * Origin timeout
     * @type {string}
     * @memberof V2RuleAuthRequest
     */
    'origin_timeout'?: string;
    /**
     * Enable failover mode
     * @type {boolean}
     * @memberof V2RuleAuthRequest
     */
    'failover_mode'?: boolean;
    /**
     * Failover TTFB threshold
     * @type {string}
     * @memberof V2RuleAuthRequest
     */
    'failover_origin_ttfb'?: string;
    /**
     * Status codes for failover (default: 200,404,301,302,304)
     * @type {Array<string>}
     * @memberof V2RuleAuthRequest
     */
    'failover_origin_status_codes'?: Array<string>;
    /**
     * Failover cache lifetime
     * @type {string}
     * @memberof V2RuleAuthRequest
     */
    'failover_lifetime'?: string;
    /**
     * Notification type (none, slack)
     * @type {string}
     * @memberof V2RuleAuthRequest
     */
    'notify'?: V2RuleAuthRequestNotifyEnum;
    /**
     * 
     * @type {V2RuleProxyActionAllOfNotifyConfig}
     * @memberof V2RuleAuthRequest
     */
    'notify_config'?: V2RuleProxyActionAllOfNotifyConfig | null;
    /**
     * WAF enabled
     * @type {boolean}
     * @memberof V2RuleAuthRequest
     */
    'waf_enabled'?: boolean;
    /**
     * 
     * @type {WafConfig}
     * @memberof V2RuleAuthRequest
     */
    'waf_config'?: WafConfig;
    /**
     * Proxy alert enabled
     * @type {boolean}
     * @memberof V2RuleAuthRequest
     */
    'proxy_alert_enabled'?: boolean;
    /**
     * Proxy inline function enabled
     * @type {boolean}
     * @memberof V2RuleAuthRequest
     */
    'proxy_inline_fn_enabled'?: boolean;
    /**
     * 
     * @type {V2RuleProxyActionAllOfQuantCloudSelection}
     * @memberof V2RuleAuthRequest
     */
    'quant_cloud_selection'?: V2RuleProxyActionAllOfQuantCloudSelection | null;
}

export const V2RuleAuthRequestNotifyEnum = {
    None: 'none',
    Slack: 'slack'
} as const;

export type V2RuleAuthRequestNotifyEnum = typeof V2RuleAuthRequestNotifyEnum[keyof typeof V2RuleAuthRequestNotifyEnum];

/**
 * 
 * @export
 * @interface V2RuleBotChallenge
 */
export interface V2RuleBotChallenge {
    /**
     * Error message
     * @type {string}
     * @memberof V2RuleBotChallenge
     */
    'message': string;
    /**
     * Error flag
     * @type {boolean}
     * @memberof V2RuleBotChallenge
     */
    'error': boolean;
    /**
     * Rule name
     * @type {string}
     * @memberof V2RuleBotChallenge
     */
    'name'?: string;
    /**
     * Rule UUID
     * @type {string}
     * @memberof V2RuleBotChallenge
     */
    'uuid': string;
    /**
     * Rule ID
     * @type {string}
     * @memberof V2RuleBotChallenge
     */
    'rule_id'?: string;
    /**
     * Rule weight
     * @type {number}
     * @memberof V2RuleBotChallenge
     */
    'weight'?: number;
    /**
     * URL patterns
     * @type {Array<string>}
     * @memberof V2RuleBotChallenge
     */
    'url'?: Array<string>;
    /**
     * Domain patterns
     * @type {Array<string>}
     * @memberof V2RuleBotChallenge
     */
    'domain'?: Array<string>;
    /**
     * Whether rule is disabled
     * @type {boolean}
     * @memberof V2RuleBotChallenge
     */
    'disabled': boolean;
    /**
     * Only apply with cookie
     * @type {string}
     * @memberof V2RuleBotChallenge
     */
    'only_with_cookie'?: string;
    /**
     * HTTP method
     * @type {string}
     * @memberof V2RuleBotChallenge
     */
    'method'?: string;
    /**
     * Allowed HTTP methods
     * @type {Array<string>}
     * @memberof V2RuleBotChallenge
     */
    'method_is'?: Array<string>;
    /**
     * Excluded HTTP methods
     * @type {Array<string>}
     * @memberof V2RuleBotChallenge
     */
    'method_is_not'?: Array<string>;
    /**
     * IP address
     * @type {string}
     * @memberof V2RuleBotChallenge
     */
    'ip'?: string;
    /**
     * Allowed IP addresses
     * @type {Array<string>}
     * @memberof V2RuleBotChallenge
     */
    'ip_is'?: Array<string>;
    /**
     * Excluded IP addresses
     * @type {Array<string>}
     * @memberof V2RuleBotChallenge
     */
    'ip_is_not'?: Array<string>;
    /**
     * Country code
     * @type {string}
     * @memberof V2RuleBotChallenge
     */
    'country'?: string;
    /**
     * Allowed countries
     * @type {Array<string>}
     * @memberof V2RuleBotChallenge
     */
    'country_is'?: Array<string>;
    /**
     * Excluded countries
     * @type {Array<string>}
     * @memberof V2RuleBotChallenge
     */
    'country_is_not'?: Array<string>;
    /**
     * Rule action
     * @type {string}
     * @memberof V2RuleBotChallenge
     */
    'action': string;
    /**
     * Target URL to proxy to
     * @type {string}
     * @memberof V2RuleBotChallenge
     */
    'to': string;
    /**
     * Host header override
     * @type {string}
     * @memberof V2RuleBotChallenge
     */
    'host'?: string;
    /**
     * Basic auth username
     * @type {string}
     * @memberof V2RuleBotChallenge
     */
    'auth_user'?: string;
    /**
     * Basic auth password
     * @type {string}
     * @memberof V2RuleBotChallenge
     */
    'auth_pass'?: string;
    /**
     * Disable SSL verification
     * @type {boolean}
     * @memberof V2RuleBotChallenge
     */
    'disable_ssl_verify'?: boolean;
    /**
     * Cache lifetime
     * @type {string}
     * @memberof V2RuleBotChallenge
     */
    'cache_lifetime'?: string | null;
    /**
     * Only proxy 404 responses
     * @type {boolean}
     * @memberof V2RuleBotChallenge
     */
    'only_proxy_404'?: boolean;
    /**
     * Headers to inject
     * @type {{ [key: string]: string; }}
     * @memberof V2RuleBotChallenge
     */
    'inject_headers'?: { [key: string]: string; } | null;
    /**
     * Headers to strip from response
     * @type {Array<string>}
     * @memberof V2RuleBotChallenge
     */
    'proxy_strip_headers'?: Array<string>;
    /**
     * Headers to strip from request
     * @type {Array<string>}
     * @memberof V2RuleBotChallenge
     */
    'proxy_strip_request_headers'?: Array<string>;
    /**
     * Origin timeout
     * @type {string}
     * @memberof V2RuleBotChallenge
     */
    'origin_timeout'?: string;
    /**
     * Enable failover mode
     * @type {boolean}
     * @memberof V2RuleBotChallenge
     */
    'failover_mode'?: boolean;
    /**
     * Failover TTFB threshold
     * @type {string}
     * @memberof V2RuleBotChallenge
     */
    'failover_origin_ttfb'?: string;
    /**
     * Status codes for failover (default: 200,404,301,302,304)
     * @type {Array<string>}
     * @memberof V2RuleBotChallenge
     */
    'failover_origin_status_codes'?: Array<string>;
    /**
     * Failover cache lifetime
     * @type {string}
     * @memberof V2RuleBotChallenge
     */
    'failover_lifetime'?: string;
    /**
     * Notification type (none, slack)
     * @type {string}
     * @memberof V2RuleBotChallenge
     */
    'notify'?: V2RuleBotChallengeNotifyEnum;
    /**
     * 
     * @type {V2RuleProxyActionAllOfNotifyConfig}
     * @memberof V2RuleBotChallenge
     */
    'notify_config'?: V2RuleProxyActionAllOfNotifyConfig | null;
    /**
     * WAF enabled
     * @type {boolean}
     * @memberof V2RuleBotChallenge
     */
    'waf_enabled'?: boolean;
    /**
     * 
     * @type {WafConfig}
     * @memberof V2RuleBotChallenge
     */
    'waf_config'?: WafConfig;
    /**
     * Proxy alert enabled
     * @type {boolean}
     * @memberof V2RuleBotChallenge
     */
    'proxy_alert_enabled'?: boolean;
    /**
     * Proxy inline function enabled
     * @type {boolean}
     * @memberof V2RuleBotChallenge
     */
    'proxy_inline_fn_enabled'?: boolean;
    /**
     * 
     * @type {V2RuleProxyActionAllOfQuantCloudSelection}
     * @memberof V2RuleBotChallenge
     */
    'quant_cloud_selection'?: V2RuleProxyActionAllOfQuantCloudSelection | null;
    /**
     * 
     * @type {V2RuleBotChallengeAction}
     * @memberof V2RuleBotChallenge
     */
    'action_config': V2RuleBotChallengeAction;
}

export const V2RuleBotChallengeNotifyEnum = {
    None: 'none',
    Slack: 'slack'
} as const;

export type V2RuleBotChallengeNotifyEnum = typeof V2RuleBotChallengeNotifyEnum[keyof typeof V2RuleBotChallengeNotifyEnum];

/**
 * 
 * @export
 * @interface V2RuleBotChallengeAction
 */
export interface V2RuleBotChallengeAction {
    /**
     * Error message
     * @type {string}
     * @memberof V2RuleBotChallengeAction
     */
    'message': string;
    /**
     * Error flag
     * @type {boolean}
     * @memberof V2RuleBotChallengeAction
     */
    'error': boolean;
    /**
     * Target URL to proxy to
     * @type {string}
     * @memberof V2RuleBotChallengeAction
     */
    'to': string;
    /**
     * Host header override
     * @type {string}
     * @memberof V2RuleBotChallengeAction
     */
    'host'?: string;
    /**
     * Basic auth username
     * @type {string}
     * @memberof V2RuleBotChallengeAction
     */
    'auth_user'?: string;
    /**
     * Basic auth password
     * @type {string}
     * @memberof V2RuleBotChallengeAction
     */
    'auth_pass'?: string;
    /**
     * Disable SSL verification
     * @type {boolean}
     * @memberof V2RuleBotChallengeAction
     */
    'disable_ssl_verify'?: boolean;
    /**
     * Cache lifetime
     * @type {string}
     * @memberof V2RuleBotChallengeAction
     */
    'cache_lifetime'?: string | null;
    /**
     * Only proxy 404 responses
     * @type {boolean}
     * @memberof V2RuleBotChallengeAction
     */
    'only_proxy_404'?: boolean;
    /**
     * Headers to inject
     * @type {{ [key: string]: string; }}
     * @memberof V2RuleBotChallengeAction
     */
    'inject_headers'?: { [key: string]: string; } | null;
    /**
     * Headers to strip from response
     * @type {Array<string>}
     * @memberof V2RuleBotChallengeAction
     */
    'proxy_strip_headers'?: Array<string>;
    /**
     * Headers to strip from request
     * @type {Array<string>}
     * @memberof V2RuleBotChallengeAction
     */
    'proxy_strip_request_headers'?: Array<string>;
    /**
     * Origin timeout
     * @type {string}
     * @memberof V2RuleBotChallengeAction
     */
    'origin_timeout'?: string;
    /**
     * Enable failover mode
     * @type {boolean}
     * @memberof V2RuleBotChallengeAction
     */
    'failover_mode'?: boolean;
    /**
     * Failover TTFB threshold
     * @type {string}
     * @memberof V2RuleBotChallengeAction
     */
    'failover_origin_ttfb'?: string;
    /**
     * Status codes for failover (default: 200,404,301,302,304)
     * @type {Array<string>}
     * @memberof V2RuleBotChallengeAction
     */
    'failover_origin_status_codes'?: Array<string>;
    /**
     * Failover cache lifetime
     * @type {string}
     * @memberof V2RuleBotChallengeAction
     */
    'failover_lifetime'?: string;
    /**
     * Notification type (none, slack)
     * @type {string}
     * @memberof V2RuleBotChallengeAction
     */
    'notify'?: V2RuleBotChallengeActionNotifyEnum;
    /**
     * 
     * @type {V2RuleProxyActionAllOfNotifyConfig}
     * @memberof V2RuleBotChallengeAction
     */
    'notify_config'?: V2RuleProxyActionAllOfNotifyConfig | null;
    /**
     * WAF enabled
     * @type {boolean}
     * @memberof V2RuleBotChallengeAction
     */
    'waf_enabled'?: boolean;
    /**
     * 
     * @type {WafConfig}
     * @memberof V2RuleBotChallengeAction
     */
    'waf_config'?: WafConfig;
    /**
     * Proxy alert enabled
     * @type {boolean}
     * @memberof V2RuleBotChallengeAction
     */
    'proxy_alert_enabled'?: boolean;
    /**
     * Proxy inline function enabled
     * @type {boolean}
     * @memberof V2RuleBotChallengeAction
     */
    'proxy_inline_fn_enabled'?: boolean;
    /**
     * 
     * @type {V2RuleProxyActionAllOfQuantCloudSelection}
     * @memberof V2RuleBotChallengeAction
     */
    'quant_cloud_selection'?: V2RuleProxyActionAllOfQuantCloudSelection | null;
    /**
     * Challenge type (invisible or checkbox)
     * @type {string}
     * @memberof V2RuleBotChallengeAction
     */
    'robot_challenge_type': string;
    /**
     * Verification TTL in seconds
     * @type {number}
     * @memberof V2RuleBotChallengeAction
     */
    'robot_challenge_verification_ttl'?: number;
    /**
     * Challenge TTL in seconds
     * @type {number}
     * @memberof V2RuleBotChallengeAction
     */
    'robot_challenge_challenge_ttl'?: number;
}

export const V2RuleBotChallengeActionNotifyEnum = {
    None: 'none',
    Slack: 'slack'
} as const;

export type V2RuleBotChallengeActionNotifyEnum = typeof V2RuleBotChallengeActionNotifyEnum[keyof typeof V2RuleBotChallengeActionNotifyEnum];

/**
 * 
 * @export
 * @interface V2RuleBotChallengeRequest
 */
export interface V2RuleBotChallengeRequest {
    /**
     * Error message
     * @type {string}
     * @memberof V2RuleBotChallengeRequest
     */
    'message': string;
    /**
     * Error flag
     * @type {boolean}
     * @memberof V2RuleBotChallengeRequest
     */
    'error': boolean;
    /**
     * Domain patterns (default: any)
     * @type {Array<string>}
     * @memberof V2RuleBotChallengeRequest
     */
    'domain': Array<string>;
    /**
     * Rule name
     * @type {string}
     * @memberof V2RuleBotChallengeRequest
     */
    'name'?: string;
    /**
     * Rule UUID
     * @type {string}
     * @memberof V2RuleBotChallengeRequest
     */
    'uuid'?: string;
    /**
     * Rule weight
     * @type {number}
     * @memberof V2RuleBotChallengeRequest
     */
    'weight'?: number;
    /**
     * Whether rule is disabled
     * @type {boolean}
     * @memberof V2RuleBotChallengeRequest
     */
    'disabled'?: boolean;
    /**
     * URL patterns
     * @type {Array<string>}
     * @memberof V2RuleBotChallengeRequest
     */
    'url': Array<string>;
    /**
     * Country filter type (country_is, country_is_not, any)
     * @type {string}
     * @memberof V2RuleBotChallengeRequest
     */
    'country'?: string;
    /**
     * Allowed countries
     * @type {Array<string>}
     * @memberof V2RuleBotChallengeRequest
     */
    'country_is'?: Array<string>;
    /**
     * Excluded countries
     * @type {Array<string>}
     * @memberof V2RuleBotChallengeRequest
     */
    'country_is_not'?: Array<string>;
    /**
     * Method filter type (method_is, method_is_not, any)
     * @type {string}
     * @memberof V2RuleBotChallengeRequest
     */
    'method'?: string;
    /**
     * Allowed HTTP methods
     * @type {Array<string>}
     * @memberof V2RuleBotChallengeRequest
     */
    'method_is'?: Array<string>;
    /**
     * Excluded HTTP methods
     * @type {Array<string>}
     * @memberof V2RuleBotChallengeRequest
     */
    'method_is_not'?: Array<string>;
    /**
     * IP filter type (ip_is, ip_is_not, any)
     * @type {string}
     * @memberof V2RuleBotChallengeRequest
     */
    'ip'?: string;
    /**
     * Allowed IP addresses
     * @type {Array<string>}
     * @memberof V2RuleBotChallengeRequest
     */
    'ip_is'?: Array<string>;
    /**
     * Excluded IP addresses
     * @type {Array<string>}
     * @memberof V2RuleBotChallengeRequest
     */
    'ip_is_not'?: Array<string>;
    /**
     * Target URL to proxy to
     * @type {string}
     * @memberof V2RuleBotChallengeRequest
     */
    'to': string;
    /**
     * Host header override
     * @type {string}
     * @memberof V2RuleBotChallengeRequest
     */
    'host'?: string;
    /**
     * Basic auth username
     * @type {string}
     * @memberof V2RuleBotChallengeRequest
     */
    'auth_user'?: string;
    /**
     * Basic auth password
     * @type {string}
     * @memberof V2RuleBotChallengeRequest
     */
    'auth_pass'?: string;
    /**
     * Disable SSL verification
     * @type {boolean}
     * @memberof V2RuleBotChallengeRequest
     */
    'disable_ssl_verify'?: boolean;
    /**
     * Cache lifetime
     * @type {string}
     * @memberof V2RuleBotChallengeRequest
     */
    'cache_lifetime'?: string | null;
    /**
     * Only proxy 404 responses
     * @type {boolean}
     * @memberof V2RuleBotChallengeRequest
     */
    'only_proxy_404'?: boolean;
    /**
     * Headers to inject
     * @type {{ [key: string]: string; }}
     * @memberof V2RuleBotChallengeRequest
     */
    'inject_headers'?: { [key: string]: string; } | null;
    /**
     * Headers to strip from response
     * @type {Array<string>}
     * @memberof V2RuleBotChallengeRequest
     */
    'proxy_strip_headers'?: Array<string>;
    /**
     * Headers to strip from request
     * @type {Array<string>}
     * @memberof V2RuleBotChallengeRequest
     */
    'proxy_strip_request_headers'?: Array<string>;
    /**
     * Origin timeout
     * @type {string}
     * @memberof V2RuleBotChallengeRequest
     */
    'origin_timeout'?: string;
    /**
     * Enable failover mode
     * @type {boolean}
     * @memberof V2RuleBotChallengeRequest
     */
    'failover_mode'?: boolean;
    /**
     * Failover TTFB threshold
     * @type {string}
     * @memberof V2RuleBotChallengeRequest
     */
    'failover_origin_ttfb'?: string;
    /**
     * Status codes for failover (default: 200,404,301,302,304)
     * @type {Array<string>}
     * @memberof V2RuleBotChallengeRequest
     */
    'failover_origin_status_codes'?: Array<string>;
    /**
     * Failover cache lifetime
     * @type {string}
     * @memberof V2RuleBotChallengeRequest
     */
    'failover_lifetime'?: string;
    /**
     * Notification type (none, slack)
     * @type {string}
     * @memberof V2RuleBotChallengeRequest
     */
    'notify'?: V2RuleBotChallengeRequestNotifyEnum;
    /**
     * 
     * @type {V2RuleProxyActionAllOfNotifyConfig}
     * @memberof V2RuleBotChallengeRequest
     */
    'notify_config'?: V2RuleProxyActionAllOfNotifyConfig | null;
    /**
     * WAF enabled
     * @type {boolean}
     * @memberof V2RuleBotChallengeRequest
     */
    'waf_enabled'?: boolean;
    /**
     * 
     * @type {WafConfig}
     * @memberof V2RuleBotChallengeRequest
     */
    'waf_config'?: WafConfig;
    /**
     * Proxy alert enabled
     * @type {boolean}
     * @memberof V2RuleBotChallengeRequest
     */
    'proxy_alert_enabled'?: boolean;
    /**
     * Proxy inline function enabled
     * @type {boolean}
     * @memberof V2RuleBotChallengeRequest
     */
    'proxy_inline_fn_enabled'?: boolean;
    /**
     * 
     * @type {V2RuleProxyActionAllOfQuantCloudSelection}
     * @memberof V2RuleBotChallengeRequest
     */
    'quant_cloud_selection'?: V2RuleProxyActionAllOfQuantCloudSelection | null;
    /**
     * Challenge type (invisible or checkbox)
     * @type {string}
     * @memberof V2RuleBotChallengeRequest
     */
    'robot_challenge_type': string;
    /**
     * Verification TTL in seconds
     * @type {number}
     * @memberof V2RuleBotChallengeRequest
     */
    'robot_challenge_verification_ttl'?: number;
    /**
     * Challenge TTL in seconds
     * @type {number}
     * @memberof V2RuleBotChallengeRequest
     */
    'robot_challenge_challenge_ttl'?: number;
}

export const V2RuleBotChallengeRequestNotifyEnum = {
    None: 'none',
    Slack: 'slack'
} as const;

export type V2RuleBotChallengeRequestNotifyEnum = typeof V2RuleBotChallengeRequestNotifyEnum[keyof typeof V2RuleBotChallengeRequestNotifyEnum];

/**
 * 
 * @export
 * @interface V2RuleContentFilter
 */
export interface V2RuleContentFilter {
    /**
     * Error message
     * @type {string}
     * @memberof V2RuleContentFilter
     */
    'message': string;
    /**
     * Error flag
     * @type {boolean}
     * @memberof V2RuleContentFilter
     */
    'error': boolean;
    /**
     * Rule name
     * @type {string}
     * @memberof V2RuleContentFilter
     */
    'name'?: string;
    /**
     * Rule UUID
     * @type {string}
     * @memberof V2RuleContentFilter
     */
    'uuid': string;
    /**
     * Rule ID
     * @type {string}
     * @memberof V2RuleContentFilter
     */
    'rule_id'?: string;
    /**
     * Rule weight
     * @type {number}
     * @memberof V2RuleContentFilter
     */
    'weight'?: number;
    /**
     * URL patterns
     * @type {Array<string>}
     * @memberof V2RuleContentFilter
     */
    'url'?: Array<string>;
    /**
     * Domain patterns
     * @type {Array<string>}
     * @memberof V2RuleContentFilter
     */
    'domain'?: Array<string>;
    /**
     * Whether rule is disabled
     * @type {boolean}
     * @memberof V2RuleContentFilter
     */
    'disabled': boolean;
    /**
     * Only apply with cookie
     * @type {string}
     * @memberof V2RuleContentFilter
     */
    'only_with_cookie'?: string;
    /**
     * HTTP method
     * @type {string}
     * @memberof V2RuleContentFilter
     */
    'method'?: string;
    /**
     * Allowed HTTP methods
     * @type {Array<string>}
     * @memberof V2RuleContentFilter
     */
    'method_is'?: Array<string>;
    /**
     * Excluded HTTP methods
     * @type {Array<string>}
     * @memberof V2RuleContentFilter
     */
    'method_is_not'?: Array<string>;
    /**
     * IP address
     * @type {string}
     * @memberof V2RuleContentFilter
     */
    'ip'?: string;
    /**
     * Allowed IP addresses
     * @type {Array<string>}
     * @memberof V2RuleContentFilter
     */
    'ip_is'?: Array<string>;
    /**
     * Excluded IP addresses
     * @type {Array<string>}
     * @memberof V2RuleContentFilter
     */
    'ip_is_not'?: Array<string>;
    /**
     * Country code
     * @type {string}
     * @memberof V2RuleContentFilter
     */
    'country'?: string;
    /**
     * Allowed countries
     * @type {Array<string>}
     * @memberof V2RuleContentFilter
     */
    'country_is'?: Array<string>;
    /**
     * Excluded countries
     * @type {Array<string>}
     * @memberof V2RuleContentFilter
     */
    'country_is_not'?: Array<string>;
    /**
     * Rule action
     * @type {string}
     * @memberof V2RuleContentFilter
     */
    'action': string;
    /**
     * Target URL to proxy to
     * @type {string}
     * @memberof V2RuleContentFilter
     */
    'to': string;
    /**
     * Host header override
     * @type {string}
     * @memberof V2RuleContentFilter
     */
    'host'?: string;
    /**
     * Basic auth username
     * @type {string}
     * @memberof V2RuleContentFilter
     */
    'auth_user'?: string;
    /**
     * Basic auth password
     * @type {string}
     * @memberof V2RuleContentFilter
     */
    'auth_pass'?: string;
    /**
     * Disable SSL verification
     * @type {boolean}
     * @memberof V2RuleContentFilter
     */
    'disable_ssl_verify'?: boolean;
    /**
     * Cache lifetime
     * @type {string}
     * @memberof V2RuleContentFilter
     */
    'cache_lifetime'?: string | null;
    /**
     * Only proxy 404 responses
     * @type {boolean}
     * @memberof V2RuleContentFilter
     */
    'only_proxy_404'?: boolean;
    /**
     * Headers to inject
     * @type {{ [key: string]: string; }}
     * @memberof V2RuleContentFilter
     */
    'inject_headers'?: { [key: string]: string; } | null;
    /**
     * Headers to strip from response
     * @type {Array<string>}
     * @memberof V2RuleContentFilter
     */
    'proxy_strip_headers'?: Array<string>;
    /**
     * Headers to strip from request
     * @type {Array<string>}
     * @memberof V2RuleContentFilter
     */
    'proxy_strip_request_headers'?: Array<string>;
    /**
     * Origin timeout
     * @type {string}
     * @memberof V2RuleContentFilter
     */
    'origin_timeout'?: string;
    /**
     * Enable failover mode
     * @type {boolean}
     * @memberof V2RuleContentFilter
     */
    'failover_mode'?: boolean;
    /**
     * Failover TTFB threshold
     * @type {string}
     * @memberof V2RuleContentFilter
     */
    'failover_origin_ttfb'?: string;
    /**
     * Status codes for failover (default: 200,404,301,302,304)
     * @type {Array<string>}
     * @memberof V2RuleContentFilter
     */
    'failover_origin_status_codes'?: Array<string>;
    /**
     * Failover cache lifetime
     * @type {string}
     * @memberof V2RuleContentFilter
     */
    'failover_lifetime'?: string;
    /**
     * Notification type (none, slack)
     * @type {string}
     * @memberof V2RuleContentFilter
     */
    'notify'?: V2RuleContentFilterNotifyEnum;
    /**
     * 
     * @type {V2RuleProxyActionAllOfNotifyConfig}
     * @memberof V2RuleContentFilter
     */
    'notify_config'?: V2RuleProxyActionAllOfNotifyConfig | null;
    /**
     * WAF enabled
     * @type {boolean}
     * @memberof V2RuleContentFilter
     */
    'waf_enabled'?: boolean;
    /**
     * 
     * @type {WafConfig}
     * @memberof V2RuleContentFilter
     */
    'waf_config'?: WafConfig;
    /**
     * Proxy alert enabled
     * @type {boolean}
     * @memberof V2RuleContentFilter
     */
    'proxy_alert_enabled'?: boolean;
    /**
     * Proxy inline function enabled
     * @type {boolean}
     * @memberof V2RuleContentFilter
     */
    'proxy_inline_fn_enabled'?: boolean;
    /**
     * 
     * @type {V2RuleProxyActionAllOfQuantCloudSelection}
     * @memberof V2RuleContentFilter
     */
    'quant_cloud_selection'?: V2RuleProxyActionAllOfQuantCloudSelection | null;
    /**
     * 
     * @type {V2RuleContentFilterAction}
     * @memberof V2RuleContentFilter
     */
    'action_config': V2RuleContentFilterAction;
}

export const V2RuleContentFilterNotifyEnum = {
    None: 'none',
    Slack: 'slack'
} as const;

export type V2RuleContentFilterNotifyEnum = typeof V2RuleContentFilterNotifyEnum[keyof typeof V2RuleContentFilterNotifyEnum];

/**
 * 
 * @export
 * @interface V2RuleContentFilterAction
 */
export interface V2RuleContentFilterAction {
    /**
     * Error message
     * @type {string}
     * @memberof V2RuleContentFilterAction
     */
    'message': string;
    /**
     * Error flag
     * @type {boolean}
     * @memberof V2RuleContentFilterAction
     */
    'error': boolean;
    /**
     * Target URL to proxy to
     * @type {string}
     * @memberof V2RuleContentFilterAction
     */
    'to': string;
    /**
     * Host header override
     * @type {string}
     * @memberof V2RuleContentFilterAction
     */
    'host'?: string;
    /**
     * Basic auth username
     * @type {string}
     * @memberof V2RuleContentFilterAction
     */
    'auth_user'?: string;
    /**
     * Basic auth password
     * @type {string}
     * @memberof V2RuleContentFilterAction
     */
    'auth_pass'?: string;
    /**
     * Disable SSL verification
     * @type {boolean}
     * @memberof V2RuleContentFilterAction
     */
    'disable_ssl_verify'?: boolean;
    /**
     * Cache lifetime
     * @type {string}
     * @memberof V2RuleContentFilterAction
     */
    'cache_lifetime'?: string | null;
    /**
     * Only proxy 404 responses
     * @type {boolean}
     * @memberof V2RuleContentFilterAction
     */
    'only_proxy_404'?: boolean;
    /**
     * Headers to inject
     * @type {{ [key: string]: string; }}
     * @memberof V2RuleContentFilterAction
     */
    'inject_headers'?: { [key: string]: string; } | null;
    /**
     * Headers to strip from response
     * @type {Array<string>}
     * @memberof V2RuleContentFilterAction
     */
    'proxy_strip_headers'?: Array<string>;
    /**
     * Headers to strip from request
     * @type {Array<string>}
     * @memberof V2RuleContentFilterAction
     */
    'proxy_strip_request_headers'?: Array<string>;
    /**
     * Origin timeout
     * @type {string}
     * @memberof V2RuleContentFilterAction
     */
    'origin_timeout'?: string;
    /**
     * Enable failover mode
     * @type {boolean}
     * @memberof V2RuleContentFilterAction
     */
    'failover_mode'?: boolean;
    /**
     * Failover TTFB threshold
     * @type {string}
     * @memberof V2RuleContentFilterAction
     */
    'failover_origin_ttfb'?: string;
    /**
     * Status codes for failover (default: 200,404,301,302,304)
     * @type {Array<string>}
     * @memberof V2RuleContentFilterAction
     */
    'failover_origin_status_codes'?: Array<string>;
    /**
     * Failover cache lifetime
     * @type {string}
     * @memberof V2RuleContentFilterAction
     */
    'failover_lifetime'?: string;
    /**
     * Notification type (none, slack)
     * @type {string}
     * @memberof V2RuleContentFilterAction
     */
    'notify'?: V2RuleContentFilterActionNotifyEnum;
    /**
     * 
     * @type {V2RuleProxyActionAllOfNotifyConfig}
     * @memberof V2RuleContentFilterAction
     */
    'notify_config'?: V2RuleProxyActionAllOfNotifyConfig | null;
    /**
     * WAF enabled
     * @type {boolean}
     * @memberof V2RuleContentFilterAction
     */
    'waf_enabled'?: boolean;
    /**
     * 
     * @type {WafConfig}
     * @memberof V2RuleContentFilterAction
     */
    'waf_config'?: WafConfig;
    /**
     * Proxy alert enabled
     * @type {boolean}
     * @memberof V2RuleContentFilterAction
     */
    'proxy_alert_enabled'?: boolean;
    /**
     * Proxy inline function enabled
     * @type {boolean}
     * @memberof V2RuleContentFilterAction
     */
    'proxy_inline_fn_enabled'?: boolean;
    /**
     * 
     * @type {V2RuleProxyActionAllOfQuantCloudSelection}
     * @memberof V2RuleContentFilterAction
     */
    'quant_cloud_selection'?: V2RuleProxyActionAllOfQuantCloudSelection | null;
    /**
     * Function UUID
     * @type {string}
     * @memberof V2RuleContentFilterAction
     */
    'fn_uuid': string;
}

export const V2RuleContentFilterActionNotifyEnum = {
    None: 'none',
    Slack: 'slack'
} as const;

export type V2RuleContentFilterActionNotifyEnum = typeof V2RuleContentFilterActionNotifyEnum[keyof typeof V2RuleContentFilterActionNotifyEnum];

/**
 * 
 * @export
 * @interface V2RuleContentFilterRequest
 */
export interface V2RuleContentFilterRequest {
    /**
     * Error message
     * @type {string}
     * @memberof V2RuleContentFilterRequest
     */
    'message': string;
    /**
     * Error flag
     * @type {boolean}
     * @memberof V2RuleContentFilterRequest
     */
    'error': boolean;
    /**
     * Domain patterns (default: any)
     * @type {Array<string>}
     * @memberof V2RuleContentFilterRequest
     */
    'domain': Array<string>;
    /**
     * Rule name
     * @type {string}
     * @memberof V2RuleContentFilterRequest
     */
    'name'?: string;
    /**
     * Rule UUID
     * @type {string}
     * @memberof V2RuleContentFilterRequest
     */
    'uuid'?: string;
    /**
     * Rule weight
     * @type {number}
     * @memberof V2RuleContentFilterRequest
     */
    'weight'?: number;
    /**
     * Whether rule is disabled
     * @type {boolean}
     * @memberof V2RuleContentFilterRequest
     */
    'disabled'?: boolean;
    /**
     * URL patterns
     * @type {Array<string>}
     * @memberof V2RuleContentFilterRequest
     */
    'url': Array<string>;
    /**
     * Country filter type (country_is, country_is_not, any)
     * @type {string}
     * @memberof V2RuleContentFilterRequest
     */
    'country'?: string;
    /**
     * Allowed countries
     * @type {Array<string>}
     * @memberof V2RuleContentFilterRequest
     */
    'country_is'?: Array<string>;
    /**
     * Excluded countries
     * @type {Array<string>}
     * @memberof V2RuleContentFilterRequest
     */
    'country_is_not'?: Array<string>;
    /**
     * Method filter type (method_is, method_is_not, any)
     * @type {string}
     * @memberof V2RuleContentFilterRequest
     */
    'method'?: string;
    /**
     * Allowed HTTP methods
     * @type {Array<string>}
     * @memberof V2RuleContentFilterRequest
     */
    'method_is'?: Array<string>;
    /**
     * Excluded HTTP methods
     * @type {Array<string>}
     * @memberof V2RuleContentFilterRequest
     */
    'method_is_not'?: Array<string>;
    /**
     * IP filter type (ip_is, ip_is_not, any)
     * @type {string}
     * @memberof V2RuleContentFilterRequest
     */
    'ip'?: string;
    /**
     * Allowed IP addresses
     * @type {Array<string>}
     * @memberof V2RuleContentFilterRequest
     */
    'ip_is'?: Array<string>;
    /**
     * Excluded IP addresses
     * @type {Array<string>}
     * @memberof V2RuleContentFilterRequest
     */
    'ip_is_not'?: Array<string>;
    /**
     * Target URL to proxy to
     * @type {string}
     * @memberof V2RuleContentFilterRequest
     */
    'to': string;
    /**
     * Host header override
     * @type {string}
     * @memberof V2RuleContentFilterRequest
     */
    'host'?: string;
    /**
     * Basic auth username
     * @type {string}
     * @memberof V2RuleContentFilterRequest
     */
    'auth_user'?: string;
    /**
     * Basic auth password
     * @type {string}
     * @memberof V2RuleContentFilterRequest
     */
    'auth_pass'?: string;
    /**
     * Disable SSL verification
     * @type {boolean}
     * @memberof V2RuleContentFilterRequest
     */
    'disable_ssl_verify'?: boolean;
    /**
     * Cache lifetime
     * @type {string}
     * @memberof V2RuleContentFilterRequest
     */
    'cache_lifetime'?: string | null;
    /**
     * Only proxy 404 responses
     * @type {boolean}
     * @memberof V2RuleContentFilterRequest
     */
    'only_proxy_404'?: boolean;
    /**
     * Headers to inject
     * @type {{ [key: string]: string; }}
     * @memberof V2RuleContentFilterRequest
     */
    'inject_headers'?: { [key: string]: string; } | null;
    /**
     * Headers to strip from response
     * @type {Array<string>}
     * @memberof V2RuleContentFilterRequest
     */
    'proxy_strip_headers'?: Array<string>;
    /**
     * Headers to strip from request
     * @type {Array<string>}
     * @memberof V2RuleContentFilterRequest
     */
    'proxy_strip_request_headers'?: Array<string>;
    /**
     * Origin timeout
     * @type {string}
     * @memberof V2RuleContentFilterRequest
     */
    'origin_timeout'?: string;
    /**
     * Enable failover mode
     * @type {boolean}
     * @memberof V2RuleContentFilterRequest
     */
    'failover_mode'?: boolean;
    /**
     * Failover TTFB threshold
     * @type {string}
     * @memberof V2RuleContentFilterRequest
     */
    'failover_origin_ttfb'?: string;
    /**
     * Status codes for failover (default: 200,404,301,302,304)
     * @type {Array<string>}
     * @memberof V2RuleContentFilterRequest
     */
    'failover_origin_status_codes'?: Array<string>;
    /**
     * Failover cache lifetime
     * @type {string}
     * @memberof V2RuleContentFilterRequest
     */
    'failover_lifetime'?: string;
    /**
     * Notification type (none, slack)
     * @type {string}
     * @memberof V2RuleContentFilterRequest
     */
    'notify'?: V2RuleContentFilterRequestNotifyEnum;
    /**
     * 
     * @type {V2RuleProxyActionAllOfNotifyConfig}
     * @memberof V2RuleContentFilterRequest
     */
    'notify_config'?: V2RuleProxyActionAllOfNotifyConfig | null;
    /**
     * WAF enabled
     * @type {boolean}
     * @memberof V2RuleContentFilterRequest
     */
    'waf_enabled'?: boolean;
    /**
     * 
     * @type {WafConfig}
     * @memberof V2RuleContentFilterRequest
     */
    'waf_config'?: WafConfig;
    /**
     * Proxy alert enabled
     * @type {boolean}
     * @memberof V2RuleContentFilterRequest
     */
    'proxy_alert_enabled'?: boolean;
    /**
     * Proxy inline function enabled
     * @type {boolean}
     * @memberof V2RuleContentFilterRequest
     */
    'proxy_inline_fn_enabled'?: boolean;
    /**
     * 
     * @type {V2RuleProxyActionAllOfQuantCloudSelection}
     * @memberof V2RuleContentFilterRequest
     */
    'quant_cloud_selection'?: V2RuleProxyActionAllOfQuantCloudSelection | null;
    /**
     * Function UUID
     * @type {string}
     * @memberof V2RuleContentFilterRequest
     */
    'fn_uuid': string;
}

export const V2RuleContentFilterRequestNotifyEnum = {
    None: 'none',
    Slack: 'slack'
} as const;

export type V2RuleContentFilterRequestNotifyEnum = typeof V2RuleContentFilterRequestNotifyEnum[keyof typeof V2RuleContentFilterRequestNotifyEnum];

/**
 * 
 * @export
 * @interface V2RuleCustomResponse
 */
export interface V2RuleCustomResponse {
    /**
     * Error message
     * @type {string}
     * @memberof V2RuleCustomResponse
     */
    'message': string;
    /**
     * Error flag
     * @type {boolean}
     * @memberof V2RuleCustomResponse
     */
    'error': boolean;
    /**
     * Rule name
     * @type {string}
     * @memberof V2RuleCustomResponse
     */
    'name'?: string;
    /**
     * Rule UUID
     * @type {string}
     * @memberof V2RuleCustomResponse
     */
    'uuid': string;
    /**
     * Rule ID
     * @type {string}
     * @memberof V2RuleCustomResponse
     */
    'rule_id'?: string;
    /**
     * Rule weight
     * @type {number}
     * @memberof V2RuleCustomResponse
     */
    'weight'?: number;
    /**
     * URL patterns
     * @type {Array<string>}
     * @memberof V2RuleCustomResponse
     */
    'url'?: Array<string>;
    /**
     * Domain patterns
     * @type {Array<string>}
     * @memberof V2RuleCustomResponse
     */
    'domain'?: Array<string>;
    /**
     * Whether rule is disabled
     * @type {boolean}
     * @memberof V2RuleCustomResponse
     */
    'disabled': boolean;
    /**
     * Only apply with cookie
     * @type {string}
     * @memberof V2RuleCustomResponse
     */
    'only_with_cookie'?: string;
    /**
     * HTTP method
     * @type {string}
     * @memberof V2RuleCustomResponse
     */
    'method'?: string;
    /**
     * Allowed HTTP methods
     * @type {Array<string>}
     * @memberof V2RuleCustomResponse
     */
    'method_is'?: Array<string>;
    /**
     * Excluded HTTP methods
     * @type {Array<string>}
     * @memberof V2RuleCustomResponse
     */
    'method_is_not'?: Array<string>;
    /**
     * IP address
     * @type {string}
     * @memberof V2RuleCustomResponse
     */
    'ip'?: string;
    /**
     * Allowed IP addresses
     * @type {Array<string>}
     * @memberof V2RuleCustomResponse
     */
    'ip_is'?: Array<string>;
    /**
     * Excluded IP addresses
     * @type {Array<string>}
     * @memberof V2RuleCustomResponse
     */
    'ip_is_not'?: Array<string>;
    /**
     * Country code
     * @type {string}
     * @memberof V2RuleCustomResponse
     */
    'country'?: string;
    /**
     * Allowed countries
     * @type {Array<string>}
     * @memberof V2RuleCustomResponse
     */
    'country_is'?: Array<string>;
    /**
     * Excluded countries
     * @type {Array<string>}
     * @memberof V2RuleCustomResponse
     */
    'country_is_not'?: Array<string>;
    /**
     * Rule action
     * @type {string}
     * @memberof V2RuleCustomResponse
     */
    'action': string;
    /**
     * Target URL to proxy to
     * @type {string}
     * @memberof V2RuleCustomResponse
     */
    'to': string;
    /**
     * Host header override
     * @type {string}
     * @memberof V2RuleCustomResponse
     */
    'host'?: string;
    /**
     * Basic auth username
     * @type {string}
     * @memberof V2RuleCustomResponse
     */
    'auth_user'?: string;
    /**
     * Basic auth password
     * @type {string}
     * @memberof V2RuleCustomResponse
     */
    'auth_pass'?: string;
    /**
     * Disable SSL verification
     * @type {boolean}
     * @memberof V2RuleCustomResponse
     */
    'disable_ssl_verify'?: boolean;
    /**
     * Cache lifetime
     * @type {string}
     * @memberof V2RuleCustomResponse
     */
    'cache_lifetime'?: string | null;
    /**
     * Only proxy 404 responses
     * @type {boolean}
     * @memberof V2RuleCustomResponse
     */
    'only_proxy_404'?: boolean;
    /**
     * Headers to inject
     * @type {{ [key: string]: string; }}
     * @memberof V2RuleCustomResponse
     */
    'inject_headers'?: { [key: string]: string; } | null;
    /**
     * Headers to strip from response
     * @type {Array<string>}
     * @memberof V2RuleCustomResponse
     */
    'proxy_strip_headers'?: Array<string>;
    /**
     * Headers to strip from request
     * @type {Array<string>}
     * @memberof V2RuleCustomResponse
     */
    'proxy_strip_request_headers'?: Array<string>;
    /**
     * Origin timeout
     * @type {string}
     * @memberof V2RuleCustomResponse
     */
    'origin_timeout'?: string;
    /**
     * Enable failover mode
     * @type {boolean}
     * @memberof V2RuleCustomResponse
     */
    'failover_mode'?: boolean;
    /**
     * Failover TTFB threshold
     * @type {string}
     * @memberof V2RuleCustomResponse
     */
    'failover_origin_ttfb'?: string;
    /**
     * Status codes for failover (default: 200,404,301,302,304)
     * @type {Array<string>}
     * @memberof V2RuleCustomResponse
     */
    'failover_origin_status_codes'?: Array<string>;
    /**
     * Failover cache lifetime
     * @type {string}
     * @memberof V2RuleCustomResponse
     */
    'failover_lifetime'?: string;
    /**
     * Notification type (none, slack)
     * @type {string}
     * @memberof V2RuleCustomResponse
     */
    'notify'?: V2RuleCustomResponseNotifyEnum;
    /**
     * 
     * @type {V2RuleProxyActionAllOfNotifyConfig}
     * @memberof V2RuleCustomResponse
     */
    'notify_config'?: V2RuleProxyActionAllOfNotifyConfig | null;
    /**
     * WAF enabled
     * @type {boolean}
     * @memberof V2RuleCustomResponse
     */
    'waf_enabled'?: boolean;
    /**
     * 
     * @type {WafConfig}
     * @memberof V2RuleCustomResponse
     */
    'waf_config'?: WafConfig;
    /**
     * Proxy alert enabled
     * @type {boolean}
     * @memberof V2RuleCustomResponse
     */
    'proxy_alert_enabled'?: boolean;
    /**
     * Proxy inline function enabled
     * @type {boolean}
     * @memberof V2RuleCustomResponse
     */
    'proxy_inline_fn_enabled'?: boolean;
    /**
     * 
     * @type {V2RuleProxyActionAllOfQuantCloudSelection}
     * @memberof V2RuleCustomResponse
     */
    'quant_cloud_selection'?: V2RuleProxyActionAllOfQuantCloudSelection | null;
    /**
     * 
     * @type {V2RuleCustomResponseAction}
     * @memberof V2RuleCustomResponse
     */
    'action_config'?: V2RuleCustomResponseAction;
}

export const V2RuleCustomResponseNotifyEnum = {
    None: 'none',
    Slack: 'slack'
} as const;

export type V2RuleCustomResponseNotifyEnum = typeof V2RuleCustomResponseNotifyEnum[keyof typeof V2RuleCustomResponseNotifyEnum];

/**
 * 
 * @export
 * @interface V2RuleCustomResponseAction
 */
export interface V2RuleCustomResponseAction {
    /**
     * Error message
     * @type {string}
     * @memberof V2RuleCustomResponseAction
     */
    'message': string;
    /**
     * Error flag
     * @type {boolean}
     * @memberof V2RuleCustomResponseAction
     */
    'error': boolean;
    /**
     * Target URL to proxy to
     * @type {string}
     * @memberof V2RuleCustomResponseAction
     */
    'to': string;
    /**
     * Host header override
     * @type {string}
     * @memberof V2RuleCustomResponseAction
     */
    'host'?: string;
    /**
     * Basic auth username
     * @type {string}
     * @memberof V2RuleCustomResponseAction
     */
    'auth_user'?: string;
    /**
     * Basic auth password
     * @type {string}
     * @memberof V2RuleCustomResponseAction
     */
    'auth_pass'?: string;
    /**
     * Disable SSL verification
     * @type {boolean}
     * @memberof V2RuleCustomResponseAction
     */
    'disable_ssl_verify'?: boolean;
    /**
     * Cache lifetime
     * @type {string}
     * @memberof V2RuleCustomResponseAction
     */
    'cache_lifetime'?: string | null;
    /**
     * Only proxy 404 responses
     * @type {boolean}
     * @memberof V2RuleCustomResponseAction
     */
    'only_proxy_404'?: boolean;
    /**
     * Headers to inject
     * @type {{ [key: string]: string; }}
     * @memberof V2RuleCustomResponseAction
     */
    'inject_headers'?: { [key: string]: string; } | null;
    /**
     * Headers to strip from response
     * @type {Array<string>}
     * @memberof V2RuleCustomResponseAction
     */
    'proxy_strip_headers'?: Array<string>;
    /**
     * Headers to strip from request
     * @type {Array<string>}
     * @memberof V2RuleCustomResponseAction
     */
    'proxy_strip_request_headers'?: Array<string>;
    /**
     * Origin timeout
     * @type {string}
     * @memberof V2RuleCustomResponseAction
     */
    'origin_timeout'?: string;
    /**
     * Enable failover mode
     * @type {boolean}
     * @memberof V2RuleCustomResponseAction
     */
    'failover_mode'?: boolean;
    /**
     * Failover TTFB threshold
     * @type {string}
     * @memberof V2RuleCustomResponseAction
     */
    'failover_origin_ttfb'?: string;
    /**
     * Status codes for failover (default: 200,404,301,302,304)
     * @type {Array<string>}
     * @memberof V2RuleCustomResponseAction
     */
    'failover_origin_status_codes'?: Array<string>;
    /**
     * Failover cache lifetime
     * @type {string}
     * @memberof V2RuleCustomResponseAction
     */
    'failover_lifetime'?: string;
    /**
     * Notification type (none, slack)
     * @type {string}
     * @memberof V2RuleCustomResponseAction
     */
    'notify'?: V2RuleCustomResponseActionNotifyEnum;
    /**
     * 
     * @type {V2RuleProxyActionAllOfNotifyConfig}
     * @memberof V2RuleCustomResponseAction
     */
    'notify_config'?: V2RuleProxyActionAllOfNotifyConfig | null;
    /**
     * WAF enabled
     * @type {boolean}
     * @memberof V2RuleCustomResponseAction
     */
    'waf_enabled'?: boolean;
    /**
     * 
     * @type {WafConfig}
     * @memberof V2RuleCustomResponseAction
     */
    'waf_config'?: WafConfig;
    /**
     * Proxy alert enabled
     * @type {boolean}
     * @memberof V2RuleCustomResponseAction
     */
    'proxy_alert_enabled'?: boolean;
    /**
     * Proxy inline function enabled
     * @type {boolean}
     * @memberof V2RuleCustomResponseAction
     */
    'proxy_inline_fn_enabled'?: boolean;
    /**
     * 
     * @type {V2RuleProxyActionAllOfQuantCloudSelection}
     * @memberof V2RuleCustomResponseAction
     */
    'quant_cloud_selection'?: V2RuleProxyActionAllOfQuantCloudSelection | null;
    /**
     * Custom response body content
     * @type {string}
     * @memberof V2RuleCustomResponseAction
     */
    'custom_response_body': string;
    /**
     * HTTP status code for custom response
     * @type {number}
     * @memberof V2RuleCustomResponseAction
     */
    'custom_response_status_code'?: number;
}

export const V2RuleCustomResponseActionNotifyEnum = {
    None: 'none',
    Slack: 'slack'
} as const;

export type V2RuleCustomResponseActionNotifyEnum = typeof V2RuleCustomResponseActionNotifyEnum[keyof typeof V2RuleCustomResponseActionNotifyEnum];

/**
 * 
 * @export
 * @interface V2RuleCustomResponseRequest
 */
export interface V2RuleCustomResponseRequest {
    /**
     * Error message
     * @type {string}
     * @memberof V2RuleCustomResponseRequest
     */
    'message': string;
    /**
     * Error flag
     * @type {boolean}
     * @memberof V2RuleCustomResponseRequest
     */
    'error': boolean;
    /**
     * Domain patterns (default: any)
     * @type {Array<string>}
     * @memberof V2RuleCustomResponseRequest
     */
    'domain': Array<string>;
    /**
     * Rule name
     * @type {string}
     * @memberof V2RuleCustomResponseRequest
     */
    'name'?: string;
    /**
     * Rule UUID
     * @type {string}
     * @memberof V2RuleCustomResponseRequest
     */
    'uuid'?: string;
    /**
     * Rule weight
     * @type {number}
     * @memberof V2RuleCustomResponseRequest
     */
    'weight'?: number;
    /**
     * Whether rule is disabled
     * @type {boolean}
     * @memberof V2RuleCustomResponseRequest
     */
    'disabled'?: boolean;
    /**
     * URL patterns
     * @type {Array<string>}
     * @memberof V2RuleCustomResponseRequest
     */
    'url': Array<string>;
    /**
     * Country filter type (country_is, country_is_not, any)
     * @type {string}
     * @memberof V2RuleCustomResponseRequest
     */
    'country'?: string;
    /**
     * Allowed countries
     * @type {Array<string>}
     * @memberof V2RuleCustomResponseRequest
     */
    'country_is'?: Array<string>;
    /**
     * Excluded countries
     * @type {Array<string>}
     * @memberof V2RuleCustomResponseRequest
     */
    'country_is_not'?: Array<string>;
    /**
     * Method filter type (method_is, method_is_not, any)
     * @type {string}
     * @memberof V2RuleCustomResponseRequest
     */
    'method'?: string;
    /**
     * Allowed HTTP methods
     * @type {Array<string>}
     * @memberof V2RuleCustomResponseRequest
     */
    'method_is'?: Array<string>;
    /**
     * Excluded HTTP methods
     * @type {Array<string>}
     * @memberof V2RuleCustomResponseRequest
     */
    'method_is_not'?: Array<string>;
    /**
     * IP filter type (ip_is, ip_is_not, any)
     * @type {string}
     * @memberof V2RuleCustomResponseRequest
     */
    'ip'?: string;
    /**
     * Allowed IP addresses
     * @type {Array<string>}
     * @memberof V2RuleCustomResponseRequest
     */
    'ip_is'?: Array<string>;
    /**
     * Excluded IP addresses
     * @type {Array<string>}
     * @memberof V2RuleCustomResponseRequest
     */
    'ip_is_not'?: Array<string>;
    /**
     * Target URL to proxy to
     * @type {string}
     * @memberof V2RuleCustomResponseRequest
     */
    'to': string;
    /**
     * Host header override
     * @type {string}
     * @memberof V2RuleCustomResponseRequest
     */
    'host'?: string;
    /**
     * Basic auth username
     * @type {string}
     * @memberof V2RuleCustomResponseRequest
     */
    'auth_user'?: string;
    /**
     * Basic auth password
     * @type {string}
     * @memberof V2RuleCustomResponseRequest
     */
    'auth_pass'?: string;
    /**
     * Disable SSL verification
     * @type {boolean}
     * @memberof V2RuleCustomResponseRequest
     */
    'disable_ssl_verify'?: boolean;
    /**
     * Cache lifetime
     * @type {string}
     * @memberof V2RuleCustomResponseRequest
     */
    'cache_lifetime'?: string | null;
    /**
     * Only proxy 404 responses
     * @type {boolean}
     * @memberof V2RuleCustomResponseRequest
     */
    'only_proxy_404'?: boolean;
    /**
     * Headers to inject
     * @type {{ [key: string]: string; }}
     * @memberof V2RuleCustomResponseRequest
     */
    'inject_headers'?: { [key: string]: string; } | null;
    /**
     * Headers to strip from response
     * @type {Array<string>}
     * @memberof V2RuleCustomResponseRequest
     */
    'proxy_strip_headers'?: Array<string>;
    /**
     * Headers to strip from request
     * @type {Array<string>}
     * @memberof V2RuleCustomResponseRequest
     */
    'proxy_strip_request_headers'?: Array<string>;
    /**
     * Origin timeout
     * @type {string}
     * @memberof V2RuleCustomResponseRequest
     */
    'origin_timeout'?: string;
    /**
     * Enable failover mode
     * @type {boolean}
     * @memberof V2RuleCustomResponseRequest
     */
    'failover_mode'?: boolean;
    /**
     * Failover TTFB threshold
     * @type {string}
     * @memberof V2RuleCustomResponseRequest
     */
    'failover_origin_ttfb'?: string;
    /**
     * Status codes for failover (default: 200,404,301,302,304)
     * @type {Array<string>}
     * @memberof V2RuleCustomResponseRequest
     */
    'failover_origin_status_codes'?: Array<string>;
    /**
     * Failover cache lifetime
     * @type {string}
     * @memberof V2RuleCustomResponseRequest
     */
    'failover_lifetime'?: string;
    /**
     * Notification type (none, slack)
     * @type {string}
     * @memberof V2RuleCustomResponseRequest
     */
    'notify'?: V2RuleCustomResponseRequestNotifyEnum;
    /**
     * 
     * @type {V2RuleProxyActionAllOfNotifyConfig}
     * @memberof V2RuleCustomResponseRequest
     */
    'notify_config'?: V2RuleProxyActionAllOfNotifyConfig | null;
    /**
     * WAF enabled
     * @type {boolean}
     * @memberof V2RuleCustomResponseRequest
     */
    'waf_enabled'?: boolean;
    /**
     * 
     * @type {WafConfig}
     * @memberof V2RuleCustomResponseRequest
     */
    'waf_config'?: WafConfig;
    /**
     * Proxy alert enabled
     * @type {boolean}
     * @memberof V2RuleCustomResponseRequest
     */
    'proxy_alert_enabled'?: boolean;
    /**
     * Proxy inline function enabled
     * @type {boolean}
     * @memberof V2RuleCustomResponseRequest
     */
    'proxy_inline_fn_enabled'?: boolean;
    /**
     * 
     * @type {V2RuleProxyActionAllOfQuantCloudSelection}
     * @memberof V2RuleCustomResponseRequest
     */
    'quant_cloud_selection'?: V2RuleProxyActionAllOfQuantCloudSelection | null;
    /**
     * Custom response body content
     * @type {string}
     * @memberof V2RuleCustomResponseRequest
     */
    'custom_response_body': string;
    /**
     * HTTP status code for custom response
     * @type {number}
     * @memberof V2RuleCustomResponseRequest
     */
    'custom_response_status_code'?: number;
    /**
     * Legacy field for status code (deprecated)
     * @type {number}
     * @memberof V2RuleCustomResponseRequest
     */
    'status_code'?: number;
    /**
     * Legacy field for response body (deprecated)
     * @type {string}
     * @memberof V2RuleCustomResponseRequest
     */
    'body'?: string;
}

export const V2RuleCustomResponseRequestNotifyEnum = {
    None: 'none',
    Slack: 'slack'
} as const;

export type V2RuleCustomResponseRequestNotifyEnum = typeof V2RuleCustomResponseRequestNotifyEnum[keyof typeof V2RuleCustomResponseRequestNotifyEnum];

/**
 * 
 * @export
 * @interface V2RuleFunction
 */
export interface V2RuleFunction {
    /**
     * Error message
     * @type {string}
     * @memberof V2RuleFunction
     */
    'message': string;
    /**
     * Error flag
     * @type {boolean}
     * @memberof V2RuleFunction
     */
    'error': boolean;
    /**
     * Rule name
     * @type {string}
     * @memberof V2RuleFunction
     */
    'name'?: string;
    /**
     * Rule UUID
     * @type {string}
     * @memberof V2RuleFunction
     */
    'uuid': string;
    /**
     * Rule ID
     * @type {string}
     * @memberof V2RuleFunction
     */
    'rule_id'?: string;
    /**
     * Rule weight
     * @type {number}
     * @memberof V2RuleFunction
     */
    'weight'?: number;
    /**
     * URL patterns
     * @type {Array<string>}
     * @memberof V2RuleFunction
     */
    'url'?: Array<string>;
    /**
     * Domain patterns
     * @type {Array<string>}
     * @memberof V2RuleFunction
     */
    'domain'?: Array<string>;
    /**
     * Whether rule is disabled
     * @type {boolean}
     * @memberof V2RuleFunction
     */
    'disabled': boolean;
    /**
     * Only apply with cookie
     * @type {string}
     * @memberof V2RuleFunction
     */
    'only_with_cookie'?: string;
    /**
     * HTTP method
     * @type {string}
     * @memberof V2RuleFunction
     */
    'method'?: string;
    /**
     * Allowed HTTP methods
     * @type {Array<string>}
     * @memberof V2RuleFunction
     */
    'method_is'?: Array<string>;
    /**
     * Excluded HTTP methods
     * @type {Array<string>}
     * @memberof V2RuleFunction
     */
    'method_is_not'?: Array<string>;
    /**
     * IP address
     * @type {string}
     * @memberof V2RuleFunction
     */
    'ip'?: string;
    /**
     * Allowed IP addresses
     * @type {Array<string>}
     * @memberof V2RuleFunction
     */
    'ip_is'?: Array<string>;
    /**
     * Excluded IP addresses
     * @type {Array<string>}
     * @memberof V2RuleFunction
     */
    'ip_is_not'?: Array<string>;
    /**
     * Country code
     * @type {string}
     * @memberof V2RuleFunction
     */
    'country'?: string;
    /**
     * Allowed countries
     * @type {Array<string>}
     * @memberof V2RuleFunction
     */
    'country_is'?: Array<string>;
    /**
     * Excluded countries
     * @type {Array<string>}
     * @memberof V2RuleFunction
     */
    'country_is_not'?: Array<string>;
    /**
     * Rule action
     * @type {string}
     * @memberof V2RuleFunction
     */
    'action': string;
    /**
     * Target URL to proxy to
     * @type {string}
     * @memberof V2RuleFunction
     */
    'to': string;
    /**
     * Host header override
     * @type {string}
     * @memberof V2RuleFunction
     */
    'host'?: string;
    /**
     * Basic auth username
     * @type {string}
     * @memberof V2RuleFunction
     */
    'auth_user'?: string;
    /**
     * Basic auth password
     * @type {string}
     * @memberof V2RuleFunction
     */
    'auth_pass'?: string;
    /**
     * Disable SSL verification
     * @type {boolean}
     * @memberof V2RuleFunction
     */
    'disable_ssl_verify'?: boolean;
    /**
     * Cache lifetime
     * @type {string}
     * @memberof V2RuleFunction
     */
    'cache_lifetime'?: string | null;
    /**
     * Only proxy 404 responses
     * @type {boolean}
     * @memberof V2RuleFunction
     */
    'only_proxy_404'?: boolean;
    /**
     * Headers to inject
     * @type {{ [key: string]: string; }}
     * @memberof V2RuleFunction
     */
    'inject_headers'?: { [key: string]: string; } | null;
    /**
     * Headers to strip from response
     * @type {Array<string>}
     * @memberof V2RuleFunction
     */
    'proxy_strip_headers'?: Array<string>;
    /**
     * Headers to strip from request
     * @type {Array<string>}
     * @memberof V2RuleFunction
     */
    'proxy_strip_request_headers'?: Array<string>;
    /**
     * Origin timeout
     * @type {string}
     * @memberof V2RuleFunction
     */
    'origin_timeout'?: string;
    /**
     * Enable failover mode
     * @type {boolean}
     * @memberof V2RuleFunction
     */
    'failover_mode'?: boolean;
    /**
     * Failover TTFB threshold
     * @type {string}
     * @memberof V2RuleFunction
     */
    'failover_origin_ttfb'?: string;
    /**
     * Status codes for failover (default: 200,404,301,302,304)
     * @type {Array<string>}
     * @memberof V2RuleFunction
     */
    'failover_origin_status_codes'?: Array<string>;
    /**
     * Failover cache lifetime
     * @type {string}
     * @memberof V2RuleFunction
     */
    'failover_lifetime'?: string;
    /**
     * Notification type (none, slack)
     * @type {string}
     * @memberof V2RuleFunction
     */
    'notify'?: V2RuleFunctionNotifyEnum;
    /**
     * 
     * @type {V2RuleProxyActionAllOfNotifyConfig}
     * @memberof V2RuleFunction
     */
    'notify_config'?: V2RuleProxyActionAllOfNotifyConfig | null;
    /**
     * WAF enabled
     * @type {boolean}
     * @memberof V2RuleFunction
     */
    'waf_enabled'?: boolean;
    /**
     * 
     * @type {WafConfig}
     * @memberof V2RuleFunction
     */
    'waf_config'?: WafConfig;
    /**
     * Proxy alert enabled
     * @type {boolean}
     * @memberof V2RuleFunction
     */
    'proxy_alert_enabled'?: boolean;
    /**
     * Proxy inline function enabled
     * @type {boolean}
     * @memberof V2RuleFunction
     */
    'proxy_inline_fn_enabled'?: boolean;
    /**
     * 
     * @type {V2RuleProxyActionAllOfQuantCloudSelection}
     * @memberof V2RuleFunction
     */
    'quant_cloud_selection'?: V2RuleProxyActionAllOfQuantCloudSelection | null;
    /**
     * 
     * @type {V2RuleFunctionAction}
     * @memberof V2RuleFunction
     */
    'action_config': V2RuleFunctionAction;
}

export const V2RuleFunctionNotifyEnum = {
    None: 'none',
    Slack: 'slack'
} as const;

export type V2RuleFunctionNotifyEnum = typeof V2RuleFunctionNotifyEnum[keyof typeof V2RuleFunctionNotifyEnum];

/**
 * 
 * @export
 * @interface V2RuleFunctionAction
 */
export interface V2RuleFunctionAction {
    /**
     * Error message
     * @type {string}
     * @memberof V2RuleFunctionAction
     */
    'message': string;
    /**
     * Error flag
     * @type {boolean}
     * @memberof V2RuleFunctionAction
     */
    'error': boolean;
    /**
     * Target URL to proxy to
     * @type {string}
     * @memberof V2RuleFunctionAction
     */
    'to': string;
    /**
     * Host header override
     * @type {string}
     * @memberof V2RuleFunctionAction
     */
    'host'?: string;
    /**
     * Basic auth username
     * @type {string}
     * @memberof V2RuleFunctionAction
     */
    'auth_user'?: string;
    /**
     * Basic auth password
     * @type {string}
     * @memberof V2RuleFunctionAction
     */
    'auth_pass'?: string;
    /**
     * Disable SSL verification
     * @type {boolean}
     * @memberof V2RuleFunctionAction
     */
    'disable_ssl_verify'?: boolean;
    /**
     * Cache lifetime
     * @type {string}
     * @memberof V2RuleFunctionAction
     */
    'cache_lifetime'?: string | null;
    /**
     * Only proxy 404 responses
     * @type {boolean}
     * @memberof V2RuleFunctionAction
     */
    'only_proxy_404'?: boolean;
    /**
     * Headers to inject
     * @type {{ [key: string]: string; }}
     * @memberof V2RuleFunctionAction
     */
    'inject_headers'?: { [key: string]: string; } | null;
    /**
     * Headers to strip from response
     * @type {Array<string>}
     * @memberof V2RuleFunctionAction
     */
    'proxy_strip_headers'?: Array<string>;
    /**
     * Headers to strip from request
     * @type {Array<string>}
     * @memberof V2RuleFunctionAction
     */
    'proxy_strip_request_headers'?: Array<string>;
    /**
     * Origin timeout
     * @type {string}
     * @memberof V2RuleFunctionAction
     */
    'origin_timeout'?: string;
    /**
     * Enable failover mode
     * @type {boolean}
     * @memberof V2RuleFunctionAction
     */
    'failover_mode'?: boolean;
    /**
     * Failover TTFB threshold
     * @type {string}
     * @memberof V2RuleFunctionAction
     */
    'failover_origin_ttfb'?: string;
    /**
     * Status codes for failover (default: 200,404,301,302,304)
     * @type {Array<string>}
     * @memberof V2RuleFunctionAction
     */
    'failover_origin_status_codes'?: Array<string>;
    /**
     * Failover cache lifetime
     * @type {string}
     * @memberof V2RuleFunctionAction
     */
    'failover_lifetime'?: string;
    /**
     * Notification type (none, slack)
     * @type {string}
     * @memberof V2RuleFunctionAction
     */
    'notify'?: V2RuleFunctionActionNotifyEnum;
    /**
     * 
     * @type {V2RuleProxyActionAllOfNotifyConfig}
     * @memberof V2RuleFunctionAction
     */
    'notify_config'?: V2RuleProxyActionAllOfNotifyConfig | null;
    /**
     * WAF enabled
     * @type {boolean}
     * @memberof V2RuleFunctionAction
     */
    'waf_enabled'?: boolean;
    /**
     * 
     * @type {WafConfig}
     * @memberof V2RuleFunctionAction
     */
    'waf_config'?: WafConfig;
    /**
     * Proxy alert enabled
     * @type {boolean}
     * @memberof V2RuleFunctionAction
     */
    'proxy_alert_enabled'?: boolean;
    /**
     * Proxy inline function enabled
     * @type {boolean}
     * @memberof V2RuleFunctionAction
     */
    'proxy_inline_fn_enabled'?: boolean;
    /**
     * 
     * @type {V2RuleProxyActionAllOfQuantCloudSelection}
     * @memberof V2RuleFunctionAction
     */
    'quant_cloud_selection'?: V2RuleProxyActionAllOfQuantCloudSelection | null;
    /**
     * Function UUID
     * @type {string}
     * @memberof V2RuleFunctionAction
     */
    'fn_uuid': string;
}

export const V2RuleFunctionActionNotifyEnum = {
    None: 'none',
    Slack: 'slack'
} as const;

export type V2RuleFunctionActionNotifyEnum = typeof V2RuleFunctionActionNotifyEnum[keyof typeof V2RuleFunctionActionNotifyEnum];

/**
 * 
 * @export
 * @interface V2RuleFunctionRequest
 */
export interface V2RuleFunctionRequest {
    /**
     * Error message
     * @type {string}
     * @memberof V2RuleFunctionRequest
     */
    'message': string;
    /**
     * Error flag
     * @type {boolean}
     * @memberof V2RuleFunctionRequest
     */
    'error': boolean;
    /**
     * Domain patterns (default: any)
     * @type {Array<string>}
     * @memberof V2RuleFunctionRequest
     */
    'domain': Array<string>;
    /**
     * Rule name
     * @type {string}
     * @memberof V2RuleFunctionRequest
     */
    'name'?: string;
    /**
     * Rule UUID
     * @type {string}
     * @memberof V2RuleFunctionRequest
     */
    'uuid'?: string;
    /**
     * Rule weight
     * @type {number}
     * @memberof V2RuleFunctionRequest
     */
    'weight'?: number;
    /**
     * Whether rule is disabled
     * @type {boolean}
     * @memberof V2RuleFunctionRequest
     */
    'disabled'?: boolean;
    /**
     * URL patterns
     * @type {Array<string>}
     * @memberof V2RuleFunctionRequest
     */
    'url': Array<string>;
    /**
     * Country filter type (country_is, country_is_not, any)
     * @type {string}
     * @memberof V2RuleFunctionRequest
     */
    'country'?: string;
    /**
     * Allowed countries
     * @type {Array<string>}
     * @memberof V2RuleFunctionRequest
     */
    'country_is'?: Array<string>;
    /**
     * Excluded countries
     * @type {Array<string>}
     * @memberof V2RuleFunctionRequest
     */
    'country_is_not'?: Array<string>;
    /**
     * Method filter type (method_is, method_is_not, any)
     * @type {string}
     * @memberof V2RuleFunctionRequest
     */
    'method'?: string;
    /**
     * Allowed HTTP methods
     * @type {Array<string>}
     * @memberof V2RuleFunctionRequest
     */
    'method_is'?: Array<string>;
    /**
     * Excluded HTTP methods
     * @type {Array<string>}
     * @memberof V2RuleFunctionRequest
     */
    'method_is_not'?: Array<string>;
    /**
     * IP filter type (ip_is, ip_is_not, any)
     * @type {string}
     * @memberof V2RuleFunctionRequest
     */
    'ip'?: string;
    /**
     * Allowed IP addresses
     * @type {Array<string>}
     * @memberof V2RuleFunctionRequest
     */
    'ip_is'?: Array<string>;
    /**
     * Excluded IP addresses
     * @type {Array<string>}
     * @memberof V2RuleFunctionRequest
     */
    'ip_is_not'?: Array<string>;
    /**
     * Target URL to proxy to
     * @type {string}
     * @memberof V2RuleFunctionRequest
     */
    'to': string;
    /**
     * Host header override
     * @type {string}
     * @memberof V2RuleFunctionRequest
     */
    'host'?: string;
    /**
     * Basic auth username
     * @type {string}
     * @memberof V2RuleFunctionRequest
     */
    'auth_user'?: string;
    /**
     * Basic auth password
     * @type {string}
     * @memberof V2RuleFunctionRequest
     */
    'auth_pass'?: string;
    /**
     * Disable SSL verification
     * @type {boolean}
     * @memberof V2RuleFunctionRequest
     */
    'disable_ssl_verify'?: boolean;
    /**
     * Cache lifetime
     * @type {string}
     * @memberof V2RuleFunctionRequest
     */
    'cache_lifetime'?: string | null;
    /**
     * Only proxy 404 responses
     * @type {boolean}
     * @memberof V2RuleFunctionRequest
     */
    'only_proxy_404'?: boolean;
    /**
     * Headers to inject
     * @type {{ [key: string]: string; }}
     * @memberof V2RuleFunctionRequest
     */
    'inject_headers'?: { [key: string]: string; } | null;
    /**
     * Headers to strip from response
     * @type {Array<string>}
     * @memberof V2RuleFunctionRequest
     */
    'proxy_strip_headers'?: Array<string>;
    /**
     * Headers to strip from request
     * @type {Array<string>}
     * @memberof V2RuleFunctionRequest
     */
    'proxy_strip_request_headers'?: Array<string>;
    /**
     * Origin timeout
     * @type {string}
     * @memberof V2RuleFunctionRequest
     */
    'origin_timeout'?: string;
    /**
     * Enable failover mode
     * @type {boolean}
     * @memberof V2RuleFunctionRequest
     */
    'failover_mode'?: boolean;
    /**
     * Failover TTFB threshold
     * @type {string}
     * @memberof V2RuleFunctionRequest
     */
    'failover_origin_ttfb'?: string;
    /**
     * Status codes for failover (default: 200,404,301,302,304)
     * @type {Array<string>}
     * @memberof V2RuleFunctionRequest
     */
    'failover_origin_status_codes'?: Array<string>;
    /**
     * Failover cache lifetime
     * @type {string}
     * @memberof V2RuleFunctionRequest
     */
    'failover_lifetime'?: string;
    /**
     * Notification type (none, slack)
     * @type {string}
     * @memberof V2RuleFunctionRequest
     */
    'notify'?: V2RuleFunctionRequestNotifyEnum;
    /**
     * 
     * @type {V2RuleProxyActionAllOfNotifyConfig}
     * @memberof V2RuleFunctionRequest
     */
    'notify_config'?: V2RuleProxyActionAllOfNotifyConfig | null;
    /**
     * WAF enabled
     * @type {boolean}
     * @memberof V2RuleFunctionRequest
     */
    'waf_enabled'?: boolean;
    /**
     * 
     * @type {WafConfig}
     * @memberof V2RuleFunctionRequest
     */
    'waf_config'?: WafConfig;
    /**
     * Proxy alert enabled
     * @type {boolean}
     * @memberof V2RuleFunctionRequest
     */
    'proxy_alert_enabled'?: boolean;
    /**
     * Proxy inline function enabled
     * @type {boolean}
     * @memberof V2RuleFunctionRequest
     */
    'proxy_inline_fn_enabled'?: boolean;
    /**
     * 
     * @type {V2RuleProxyActionAllOfQuantCloudSelection}
     * @memberof V2RuleFunctionRequest
     */
    'quant_cloud_selection'?: V2RuleProxyActionAllOfQuantCloudSelection | null;
    /**
     * Function UUID
     * @type {string}
     * @memberof V2RuleFunctionRequest
     */
    'fn_uuid': string;
}

export const V2RuleFunctionRequestNotifyEnum = {
    None: 'none',
    Slack: 'slack'
} as const;

export type V2RuleFunctionRequestNotifyEnum = typeof V2RuleFunctionRequestNotifyEnum[keyof typeof V2RuleFunctionRequestNotifyEnum];

/**
 * 
 * @export
 * @interface V2RuleHeader
 */
export interface V2RuleHeader {
    /**
     * Error message
     * @type {string}
     * @memberof V2RuleHeader
     */
    'message': string;
    /**
     * Error flag
     * @type {boolean}
     * @memberof V2RuleHeader
     */
    'error': boolean;
    /**
     * Rule name
     * @type {string}
     * @memberof V2RuleHeader
     */
    'name'?: string;
    /**
     * Rule UUID
     * @type {string}
     * @memberof V2RuleHeader
     */
    'uuid': string;
    /**
     * Rule ID
     * @type {string}
     * @memberof V2RuleHeader
     */
    'rule_id'?: string;
    /**
     * Rule weight
     * @type {number}
     * @memberof V2RuleHeader
     */
    'weight'?: number;
    /**
     * URL patterns
     * @type {Array<string>}
     * @memberof V2RuleHeader
     */
    'url'?: Array<string>;
    /**
     * Domain patterns
     * @type {Array<string>}
     * @memberof V2RuleHeader
     */
    'domain'?: Array<string>;
    /**
     * Whether rule is disabled
     * @type {boolean}
     * @memberof V2RuleHeader
     */
    'disabled': boolean;
    /**
     * Only apply with cookie
     * @type {string}
     * @memberof V2RuleHeader
     */
    'only_with_cookie'?: string;
    /**
     * HTTP method
     * @type {string}
     * @memberof V2RuleHeader
     */
    'method'?: string;
    /**
     * Allowed HTTP methods
     * @type {Array<string>}
     * @memberof V2RuleHeader
     */
    'method_is'?: Array<string>;
    /**
     * Excluded HTTP methods
     * @type {Array<string>}
     * @memberof V2RuleHeader
     */
    'method_is_not'?: Array<string>;
    /**
     * IP address
     * @type {string}
     * @memberof V2RuleHeader
     */
    'ip'?: string;
    /**
     * Allowed IP addresses
     * @type {Array<string>}
     * @memberof V2RuleHeader
     */
    'ip_is'?: Array<string>;
    /**
     * Excluded IP addresses
     * @type {Array<string>}
     * @memberof V2RuleHeader
     */
    'ip_is_not'?: Array<string>;
    /**
     * Country code
     * @type {string}
     * @memberof V2RuleHeader
     */
    'country'?: string;
    /**
     * Allowed countries
     * @type {Array<string>}
     * @memberof V2RuleHeader
     */
    'country_is'?: Array<string>;
    /**
     * Excluded countries
     * @type {Array<string>}
     * @memberof V2RuleHeader
     */
    'country_is_not'?: Array<string>;
    /**
     * Rule action
     * @type {string}
     * @memberof V2RuleHeader
     */
    'action': string;
    /**
     * Target URL to proxy to
     * @type {string}
     * @memberof V2RuleHeader
     */
    'to': string;
    /**
     * Host header override
     * @type {string}
     * @memberof V2RuleHeader
     */
    'host'?: string;
    /**
     * Basic auth username
     * @type {string}
     * @memberof V2RuleHeader
     */
    'auth_user'?: string;
    /**
     * Basic auth password
     * @type {string}
     * @memberof V2RuleHeader
     */
    'auth_pass'?: string;
    /**
     * Disable SSL verification
     * @type {boolean}
     * @memberof V2RuleHeader
     */
    'disable_ssl_verify'?: boolean;
    /**
     * Cache lifetime
     * @type {string}
     * @memberof V2RuleHeader
     */
    'cache_lifetime'?: string | null;
    /**
     * Only proxy 404 responses
     * @type {boolean}
     * @memberof V2RuleHeader
     */
    'only_proxy_404'?: boolean;
    /**
     * Headers to inject
     * @type {{ [key: string]: string; }}
     * @memberof V2RuleHeader
     */
    'inject_headers'?: { [key: string]: string; } | null;
    /**
     * Headers to strip from response
     * @type {Array<string>}
     * @memberof V2RuleHeader
     */
    'proxy_strip_headers'?: Array<string>;
    /**
     * Headers to strip from request
     * @type {Array<string>}
     * @memberof V2RuleHeader
     */
    'proxy_strip_request_headers'?: Array<string>;
    /**
     * Origin timeout
     * @type {string}
     * @memberof V2RuleHeader
     */
    'origin_timeout'?: string;
    /**
     * Enable failover mode
     * @type {boolean}
     * @memberof V2RuleHeader
     */
    'failover_mode'?: boolean;
    /**
     * Failover TTFB threshold
     * @type {string}
     * @memberof V2RuleHeader
     */
    'failover_origin_ttfb'?: string;
    /**
     * Status codes for failover (default: 200,404,301,302,304)
     * @type {Array<string>}
     * @memberof V2RuleHeader
     */
    'failover_origin_status_codes'?: Array<string>;
    /**
     * Failover cache lifetime
     * @type {string}
     * @memberof V2RuleHeader
     */
    'failover_lifetime'?: string;
    /**
     * Notification type (none, slack)
     * @type {string}
     * @memberof V2RuleHeader
     */
    'notify'?: V2RuleHeaderNotifyEnum;
    /**
     * 
     * @type {V2RuleProxyActionAllOfNotifyConfig}
     * @memberof V2RuleHeader
     */
    'notify_config'?: V2RuleProxyActionAllOfNotifyConfig | null;
    /**
     * WAF enabled
     * @type {boolean}
     * @memberof V2RuleHeader
     */
    'waf_enabled'?: boolean;
    /**
     * 
     * @type {WafConfig}
     * @memberof V2RuleHeader
     */
    'waf_config'?: WafConfig;
    /**
     * Proxy alert enabled
     * @type {boolean}
     * @memberof V2RuleHeader
     */
    'proxy_alert_enabled'?: boolean;
    /**
     * Proxy inline function enabled
     * @type {boolean}
     * @memberof V2RuleHeader
     */
    'proxy_inline_fn_enabled'?: boolean;
    /**
     * 
     * @type {V2RuleProxyActionAllOfQuantCloudSelection}
     * @memberof V2RuleHeader
     */
    'quant_cloud_selection'?: V2RuleProxyActionAllOfQuantCloudSelection | null;
    /**
     * 
     * @type {V2RuleHeaderAction}
     * @memberof V2RuleHeader
     */
    'action_config': V2RuleHeaderAction;
}

export const V2RuleHeaderNotifyEnum = {
    None: 'none',
    Slack: 'slack'
} as const;

export type V2RuleHeaderNotifyEnum = typeof V2RuleHeaderNotifyEnum[keyof typeof V2RuleHeaderNotifyEnum];

/**
 * 
 * @export
 * @interface V2RuleHeaderAction
 */
export interface V2RuleHeaderAction {
    /**
     * Error message
     * @type {string}
     * @memberof V2RuleHeaderAction
     */
    'message': string;
    /**
     * Error flag
     * @type {boolean}
     * @memberof V2RuleHeaderAction
     */
    'error': boolean;
    /**
     * Target URL to proxy to
     * @type {string}
     * @memberof V2RuleHeaderAction
     */
    'to': string;
    /**
     * Host header override
     * @type {string}
     * @memberof V2RuleHeaderAction
     */
    'host'?: string;
    /**
     * Basic auth username
     * @type {string}
     * @memberof V2RuleHeaderAction
     */
    'auth_user'?: string;
    /**
     * Basic auth password
     * @type {string}
     * @memberof V2RuleHeaderAction
     */
    'auth_pass'?: string;
    /**
     * Disable SSL verification
     * @type {boolean}
     * @memberof V2RuleHeaderAction
     */
    'disable_ssl_verify'?: boolean;
    /**
     * Cache lifetime
     * @type {string}
     * @memberof V2RuleHeaderAction
     */
    'cache_lifetime'?: string | null;
    /**
     * Only proxy 404 responses
     * @type {boolean}
     * @memberof V2RuleHeaderAction
     */
    'only_proxy_404'?: boolean;
    /**
     * Headers to inject
     * @type {{ [key: string]: string; }}
     * @memberof V2RuleHeaderAction
     */
    'inject_headers'?: { [key: string]: string; } | null;
    /**
     * Headers to strip from response
     * @type {Array<string>}
     * @memberof V2RuleHeaderAction
     */
    'proxy_strip_headers'?: Array<string>;
    /**
     * Headers to strip from request
     * @type {Array<string>}
     * @memberof V2RuleHeaderAction
     */
    'proxy_strip_request_headers'?: Array<string>;
    /**
     * Origin timeout
     * @type {string}
     * @memberof V2RuleHeaderAction
     */
    'origin_timeout'?: string;
    /**
     * Enable failover mode
     * @type {boolean}
     * @memberof V2RuleHeaderAction
     */
    'failover_mode'?: boolean;
    /**
     * Failover TTFB threshold
     * @type {string}
     * @memberof V2RuleHeaderAction
     */
    'failover_origin_ttfb'?: string;
    /**
     * Status codes for failover (default: 200,404,301,302,304)
     * @type {Array<string>}
     * @memberof V2RuleHeaderAction
     */
    'failover_origin_status_codes'?: Array<string>;
    /**
     * Failover cache lifetime
     * @type {string}
     * @memberof V2RuleHeaderAction
     */
    'failover_lifetime'?: string;
    /**
     * Notification type (none, slack)
     * @type {string}
     * @memberof V2RuleHeaderAction
     */
    'notify'?: V2RuleHeaderActionNotifyEnum;
    /**
     * 
     * @type {V2RuleProxyActionAllOfNotifyConfig}
     * @memberof V2RuleHeaderAction
     */
    'notify_config'?: V2RuleProxyActionAllOfNotifyConfig | null;
    /**
     * WAF enabled
     * @type {boolean}
     * @memberof V2RuleHeaderAction
     */
    'waf_enabled'?: boolean;
    /**
     * 
     * @type {WafConfig}
     * @memberof V2RuleHeaderAction
     */
    'waf_config'?: WafConfig;
    /**
     * Proxy alert enabled
     * @type {boolean}
     * @memberof V2RuleHeaderAction
     */
    'proxy_alert_enabled'?: boolean;
    /**
     * Proxy inline function enabled
     * @type {boolean}
     * @memberof V2RuleHeaderAction
     */
    'proxy_inline_fn_enabled'?: boolean;
    /**
     * 
     * @type {V2RuleProxyActionAllOfQuantCloudSelection}
     * @memberof V2RuleHeaderAction
     */
    'quant_cloud_selection'?: V2RuleProxyActionAllOfQuantCloudSelection | null;
    /**
     * Headers to set
     * @type {{ [key: string]: string; }}
     * @memberof V2RuleHeaderAction
     */
    'headers': { [key: string]: string; };
}

export const V2RuleHeaderActionNotifyEnum = {
    None: 'none',
    Slack: 'slack'
} as const;

export type V2RuleHeaderActionNotifyEnum = typeof V2RuleHeaderActionNotifyEnum[keyof typeof V2RuleHeaderActionNotifyEnum];

/**
 * 
 * @export
 * @interface V2RuleHeaderRequest
 */
export interface V2RuleHeaderRequest {
    /**
     * Error message
     * @type {string}
     * @memberof V2RuleHeaderRequest
     */
    'message': string;
    /**
     * Error flag
     * @type {boolean}
     * @memberof V2RuleHeaderRequest
     */
    'error': boolean;
    /**
     * Domain patterns (default: any)
     * @type {Array<string>}
     * @memberof V2RuleHeaderRequest
     */
    'domain': Array<string>;
    /**
     * Rule name
     * @type {string}
     * @memberof V2RuleHeaderRequest
     */
    'name'?: string;
    /**
     * Rule UUID
     * @type {string}
     * @memberof V2RuleHeaderRequest
     */
    'uuid'?: string;
    /**
     * Rule weight
     * @type {number}
     * @memberof V2RuleHeaderRequest
     */
    'weight'?: number;
    /**
     * Whether rule is disabled
     * @type {boolean}
     * @memberof V2RuleHeaderRequest
     */
    'disabled'?: boolean;
    /**
     * URL patterns
     * @type {Array<string>}
     * @memberof V2RuleHeaderRequest
     */
    'url': Array<string>;
    /**
     * Country filter type (country_is, country_is_not, any)
     * @type {string}
     * @memberof V2RuleHeaderRequest
     */
    'country'?: string;
    /**
     * Allowed countries
     * @type {Array<string>}
     * @memberof V2RuleHeaderRequest
     */
    'country_is'?: Array<string>;
    /**
     * Excluded countries
     * @type {Array<string>}
     * @memberof V2RuleHeaderRequest
     */
    'country_is_not'?: Array<string>;
    /**
     * Method filter type (method_is, method_is_not, any)
     * @type {string}
     * @memberof V2RuleHeaderRequest
     */
    'method'?: string;
    /**
     * Allowed HTTP methods
     * @type {Array<string>}
     * @memberof V2RuleHeaderRequest
     */
    'method_is'?: Array<string>;
    /**
     * Excluded HTTP methods
     * @type {Array<string>}
     * @memberof V2RuleHeaderRequest
     */
    'method_is_not'?: Array<string>;
    /**
     * IP filter type (ip_is, ip_is_not, any)
     * @type {string}
     * @memberof V2RuleHeaderRequest
     */
    'ip'?: string;
    /**
     * Allowed IP addresses
     * @type {Array<string>}
     * @memberof V2RuleHeaderRequest
     */
    'ip_is'?: Array<string>;
    /**
     * Excluded IP addresses
     * @type {Array<string>}
     * @memberof V2RuleHeaderRequest
     */
    'ip_is_not'?: Array<string>;
    /**
     * Target URL to proxy to
     * @type {string}
     * @memberof V2RuleHeaderRequest
     */
    'to': string;
    /**
     * Host header override
     * @type {string}
     * @memberof V2RuleHeaderRequest
     */
    'host'?: string;
    /**
     * Basic auth username
     * @type {string}
     * @memberof V2RuleHeaderRequest
     */
    'auth_user'?: string;
    /**
     * Basic auth password
     * @type {string}
     * @memberof V2RuleHeaderRequest
     */
    'auth_pass'?: string;
    /**
     * Disable SSL verification
     * @type {boolean}
     * @memberof V2RuleHeaderRequest
     */
    'disable_ssl_verify'?: boolean;
    /**
     * Cache lifetime
     * @type {string}
     * @memberof V2RuleHeaderRequest
     */
    'cache_lifetime'?: string | null;
    /**
     * Only proxy 404 responses
     * @type {boolean}
     * @memberof V2RuleHeaderRequest
     */
    'only_proxy_404'?: boolean;
    /**
     * Headers to inject
     * @type {{ [key: string]: string; }}
     * @memberof V2RuleHeaderRequest
     */
    'inject_headers'?: { [key: string]: string; } | null;
    /**
     * Headers to strip from response
     * @type {Array<string>}
     * @memberof V2RuleHeaderRequest
     */
    'proxy_strip_headers'?: Array<string>;
    /**
     * Headers to strip from request
     * @type {Array<string>}
     * @memberof V2RuleHeaderRequest
     */
    'proxy_strip_request_headers'?: Array<string>;
    /**
     * Origin timeout
     * @type {string}
     * @memberof V2RuleHeaderRequest
     */
    'origin_timeout'?: string;
    /**
     * Enable failover mode
     * @type {boolean}
     * @memberof V2RuleHeaderRequest
     */
    'failover_mode'?: boolean;
    /**
     * Failover TTFB threshold
     * @type {string}
     * @memberof V2RuleHeaderRequest
     */
    'failover_origin_ttfb'?: string;
    /**
     * Status codes for failover (default: 200,404,301,302,304)
     * @type {Array<string>}
     * @memberof V2RuleHeaderRequest
     */
    'failover_origin_status_codes'?: Array<string>;
    /**
     * Failover cache lifetime
     * @type {string}
     * @memberof V2RuleHeaderRequest
     */
    'failover_lifetime'?: string;
    /**
     * Notification type (none, slack)
     * @type {string}
     * @memberof V2RuleHeaderRequest
     */
    'notify'?: V2RuleHeaderRequestNotifyEnum;
    /**
     * 
     * @type {V2RuleProxyActionAllOfNotifyConfig}
     * @memberof V2RuleHeaderRequest
     */
    'notify_config'?: V2RuleProxyActionAllOfNotifyConfig | null;
    /**
     * WAF enabled
     * @type {boolean}
     * @memberof V2RuleHeaderRequest
     */
    'waf_enabled'?: boolean;
    /**
     * 
     * @type {WafConfig}
     * @memberof V2RuleHeaderRequest
     */
    'waf_config'?: WafConfig;
    /**
     * Proxy alert enabled
     * @type {boolean}
     * @memberof V2RuleHeaderRequest
     */
    'proxy_alert_enabled'?: boolean;
    /**
     * Proxy inline function enabled
     * @type {boolean}
     * @memberof V2RuleHeaderRequest
     */
    'proxy_inline_fn_enabled'?: boolean;
    /**
     * 
     * @type {V2RuleProxyActionAllOfQuantCloudSelection}
     * @memberof V2RuleHeaderRequest
     */
    'quant_cloud_selection'?: V2RuleProxyActionAllOfQuantCloudSelection | null;
    /**
     * Headers to set
     * @type {{ [key: string]: string; }}
     * @memberof V2RuleHeaderRequest
     */
    'headers': { [key: string]: string; };
}

export const V2RuleHeaderRequestNotifyEnum = {
    None: 'none',
    Slack: 'slack'
} as const;

export type V2RuleHeaderRequestNotifyEnum = typeof V2RuleHeaderRequestNotifyEnum[keyof typeof V2RuleHeaderRequestNotifyEnum];

/**
 * 
 * @export
 * @interface V2RuleProxy
 */
export interface V2RuleProxy {
    /**
     * Error message
     * @type {string}
     * @memberof V2RuleProxy
     */
    'message': string;
    /**
     * Error flag
     * @type {boolean}
     * @memberof V2RuleProxy
     */
    'error': boolean;
    /**
     * Rule name
     * @type {string}
     * @memberof V2RuleProxy
     */
    'name'?: string;
    /**
     * Rule UUID
     * @type {string}
     * @memberof V2RuleProxy
     */
    'uuid': string;
    /**
     * Rule ID
     * @type {string}
     * @memberof V2RuleProxy
     */
    'rule_id'?: string;
    /**
     * Rule weight
     * @type {number}
     * @memberof V2RuleProxy
     */
    'weight'?: number;
    /**
     * URL patterns
     * @type {Array<string>}
     * @memberof V2RuleProxy
     */
    'url'?: Array<string>;
    /**
     * Domain patterns
     * @type {Array<string>}
     * @memberof V2RuleProxy
     */
    'domain'?: Array<string>;
    /**
     * Whether rule is disabled
     * @type {boolean}
     * @memberof V2RuleProxy
     */
    'disabled': boolean;
    /**
     * Only apply with cookie
     * @type {string}
     * @memberof V2RuleProxy
     */
    'only_with_cookie'?: string;
    /**
     * HTTP method
     * @type {string}
     * @memberof V2RuleProxy
     */
    'method'?: string;
    /**
     * Allowed HTTP methods
     * @type {Array<string>}
     * @memberof V2RuleProxy
     */
    'method_is'?: Array<string>;
    /**
     * Excluded HTTP methods
     * @type {Array<string>}
     * @memberof V2RuleProxy
     */
    'method_is_not'?: Array<string>;
    /**
     * IP address
     * @type {string}
     * @memberof V2RuleProxy
     */
    'ip'?: string;
    /**
     * Allowed IP addresses
     * @type {Array<string>}
     * @memberof V2RuleProxy
     */
    'ip_is'?: Array<string>;
    /**
     * Excluded IP addresses
     * @type {Array<string>}
     * @memberof V2RuleProxy
     */
    'ip_is_not'?: Array<string>;
    /**
     * Country code
     * @type {string}
     * @memberof V2RuleProxy
     */
    'country'?: string;
    /**
     * Allowed countries
     * @type {Array<string>}
     * @memberof V2RuleProxy
     */
    'country_is'?: Array<string>;
    /**
     * Excluded countries
     * @type {Array<string>}
     * @memberof V2RuleProxy
     */
    'country_is_not'?: Array<string>;
    /**
     * Rule action
     * @type {string}
     * @memberof V2RuleProxy
     */
    'action': string;
    /**
     * Target URL to proxy to
     * @type {string}
     * @memberof V2RuleProxy
     */
    'to': string;
    /**
     * Host header override
     * @type {string}
     * @memberof V2RuleProxy
     */
    'host'?: string;
    /**
     * Basic auth username
     * @type {string}
     * @memberof V2RuleProxy
     */
    'auth_user'?: string;
    /**
     * Basic auth password
     * @type {string}
     * @memberof V2RuleProxy
     */
    'auth_pass'?: string;
    /**
     * Disable SSL verification
     * @type {boolean}
     * @memberof V2RuleProxy
     */
    'disable_ssl_verify'?: boolean;
    /**
     * Cache lifetime
     * @type {string}
     * @memberof V2RuleProxy
     */
    'cache_lifetime'?: string | null;
    /**
     * Only proxy 404 responses
     * @type {boolean}
     * @memberof V2RuleProxy
     */
    'only_proxy_404'?: boolean;
    /**
     * Headers to inject
     * @type {{ [key: string]: string; }}
     * @memberof V2RuleProxy
     */
    'inject_headers'?: { [key: string]: string; } | null;
    /**
     * Headers to strip from response
     * @type {Array<string>}
     * @memberof V2RuleProxy
     */
    'proxy_strip_headers'?: Array<string>;
    /**
     * Headers to strip from request
     * @type {Array<string>}
     * @memberof V2RuleProxy
     */
    'proxy_strip_request_headers'?: Array<string>;
    /**
     * Origin timeout
     * @type {string}
     * @memberof V2RuleProxy
     */
    'origin_timeout'?: string;
    /**
     * Enable failover mode
     * @type {boolean}
     * @memberof V2RuleProxy
     */
    'failover_mode'?: boolean;
    /**
     * Failover TTFB threshold
     * @type {string}
     * @memberof V2RuleProxy
     */
    'failover_origin_ttfb'?: string;
    /**
     * Status codes for failover (default: 200,404,301,302,304)
     * @type {Array<string>}
     * @memberof V2RuleProxy
     */
    'failover_origin_status_codes'?: Array<string>;
    /**
     * Failover cache lifetime
     * @type {string}
     * @memberof V2RuleProxy
     */
    'failover_lifetime'?: string;
    /**
     * Notification type (none, slack)
     * @type {string}
     * @memberof V2RuleProxy
     */
    'notify'?: V2RuleProxyNotifyEnum;
    /**
     * 
     * @type {V2RuleProxyActionAllOfNotifyConfig}
     * @memberof V2RuleProxy
     */
    'notify_config'?: V2RuleProxyActionAllOfNotifyConfig | null;
    /**
     * WAF enabled
     * @type {boolean}
     * @memberof V2RuleProxy
     */
    'waf_enabled'?: boolean;
    /**
     * 
     * @type {WafConfig}
     * @memberof V2RuleProxy
     */
    'waf_config'?: WafConfig;
    /**
     * Proxy alert enabled
     * @type {boolean}
     * @memberof V2RuleProxy
     */
    'proxy_alert_enabled'?: boolean;
    /**
     * Proxy inline function enabled
     * @type {boolean}
     * @memberof V2RuleProxy
     */
    'proxy_inline_fn_enabled'?: boolean;
    /**
     * 
     * @type {V2RuleProxyActionAllOfQuantCloudSelection}
     * @memberof V2RuleProxy
     */
    'quant_cloud_selection'?: V2RuleProxyActionAllOfQuantCloudSelection | null;
    /**
     * 
     * @type {V2RuleProxyAction}
     * @memberof V2RuleProxy
     */
    'action_config': V2RuleProxyAction;
}

export const V2RuleProxyNotifyEnum = {
    None: 'none',
    Slack: 'slack'
} as const;

export type V2RuleProxyNotifyEnum = typeof V2RuleProxyNotifyEnum[keyof typeof V2RuleProxyNotifyEnum];

/**
 * 
 * @export
 * @interface V2RuleProxyAction
 */
export interface V2RuleProxyAction {
    /**
     * Error message
     * @type {string}
     * @memberof V2RuleProxyAction
     */
    'message': string;
    /**
     * Error flag
     * @type {boolean}
     * @memberof V2RuleProxyAction
     */
    'error': boolean;
    /**
     * Target URL to proxy to
     * @type {string}
     * @memberof V2RuleProxyAction
     */
    'to': string;
    /**
     * Host header override
     * @type {string}
     * @memberof V2RuleProxyAction
     */
    'host'?: string;
    /**
     * Basic auth username
     * @type {string}
     * @memberof V2RuleProxyAction
     */
    'auth_user'?: string;
    /**
     * Basic auth password
     * @type {string}
     * @memberof V2RuleProxyAction
     */
    'auth_pass'?: string;
    /**
     * Disable SSL verification
     * @type {boolean}
     * @memberof V2RuleProxyAction
     */
    'disable_ssl_verify'?: boolean;
    /**
     * Cache lifetime
     * @type {string}
     * @memberof V2RuleProxyAction
     */
    'cache_lifetime'?: string | null;
    /**
     * Only proxy 404 responses
     * @type {boolean}
     * @memberof V2RuleProxyAction
     */
    'only_proxy_404'?: boolean;
    /**
     * Headers to inject
     * @type {{ [key: string]: string; }}
     * @memberof V2RuleProxyAction
     */
    'inject_headers'?: { [key: string]: string; } | null;
    /**
     * Headers to strip from response
     * @type {Array<string>}
     * @memberof V2RuleProxyAction
     */
    'proxy_strip_headers'?: Array<string>;
    /**
     * Headers to strip from request
     * @type {Array<string>}
     * @memberof V2RuleProxyAction
     */
    'proxy_strip_request_headers'?: Array<string>;
    /**
     * Origin timeout
     * @type {string}
     * @memberof V2RuleProxyAction
     */
    'origin_timeout'?: string;
    /**
     * Enable failover mode
     * @type {boolean}
     * @memberof V2RuleProxyAction
     */
    'failover_mode'?: boolean;
    /**
     * Failover TTFB threshold
     * @type {string}
     * @memberof V2RuleProxyAction
     */
    'failover_origin_ttfb'?: string;
    /**
     * Status codes for failover (default: 200,404,301,302,304)
     * @type {Array<string>}
     * @memberof V2RuleProxyAction
     */
    'failover_origin_status_codes'?: Array<string>;
    /**
     * Failover cache lifetime
     * @type {string}
     * @memberof V2RuleProxyAction
     */
    'failover_lifetime'?: string;
    /**
     * Notification type (none, slack)
     * @type {string}
     * @memberof V2RuleProxyAction
     */
    'notify'?: V2RuleProxyActionNotifyEnum;
    /**
     * 
     * @type {V2RuleProxyActionAllOfNotifyConfig}
     * @memberof V2RuleProxyAction
     */
    'notify_config'?: V2RuleProxyActionAllOfNotifyConfig | null;
    /**
     * WAF enabled
     * @type {boolean}
     * @memberof V2RuleProxyAction
     */
    'waf_enabled'?: boolean;
    /**
     * 
     * @type {WafConfig}
     * @memberof V2RuleProxyAction
     */
    'waf_config'?: WafConfig | null;
    /**
     * Proxy alert enabled
     * @type {boolean}
     * @memberof V2RuleProxyAction
     */
    'proxy_alert_enabled'?: boolean;
    /**
     * Proxy inline function enabled
     * @type {boolean}
     * @memberof V2RuleProxyAction
     */
    'proxy_inline_fn_enabled'?: boolean;
    /**
     * 
     * @type {V2RuleProxyActionAllOfQuantCloudSelection}
     * @memberof V2RuleProxyAction
     */
    'quant_cloud_selection'?: V2RuleProxyActionAllOfQuantCloudSelection | null;
}

export const V2RuleProxyActionNotifyEnum = {
    None: 'none',
    Slack: 'slack'
} as const;

export type V2RuleProxyActionNotifyEnum = typeof V2RuleProxyActionNotifyEnum[keyof typeof V2RuleProxyActionNotifyEnum];

/**
 * Notification configuration (required when notify is slack)
 * @export
 * @interface V2RuleProxyActionAllOfNotifyConfig
 */
export interface V2RuleProxyActionAllOfNotifyConfig {
    /**
     * Slack webhook URL
     * @type {string}
     * @memberof V2RuleProxyActionAllOfNotifyConfig
     */
    'webhook_url'?: string;
}
/**
 * Quant Cloud application proxy selection (only present for Quant Cloud App proxies)
 * @export
 * @interface V2RuleProxyActionAllOfQuantCloudSelection
 */
export interface V2RuleProxyActionAllOfQuantCloudSelection {
    /**
     * Application name
     * @type {string}
     * @memberof V2RuleProxyActionAllOfQuantCloudSelection
     */
    'app'?: string;
    /**
     * Environment name
     * @type {string}
     * @memberof V2RuleProxyActionAllOfQuantCloudSelection
     */
    'env'?: string;
    /**
     * Container name
     * @type {string}
     * @memberof V2RuleProxyActionAllOfQuantCloudSelection
     */
    'container'?: string;
    /**
     * Container port
     * @type {number}
     * @memberof V2RuleProxyActionAllOfQuantCloudSelection
     */
    'port'?: number;
}
/**
 * 
 * @export
 * @interface V2RuleProxyRequest
 */
export interface V2RuleProxyRequest {
    /**
     * Error message
     * @type {string}
     * @memberof V2RuleProxyRequest
     */
    'message': string;
    /**
     * Error flag
     * @type {boolean}
     * @memberof V2RuleProxyRequest
     */
    'error': boolean;
    /**
     * Domain patterns (default: any)
     * @type {Array<string>}
     * @memberof V2RuleProxyRequest
     */
    'domain': Array<string>;
    /**
     * Rule name
     * @type {string}
     * @memberof V2RuleProxyRequest
     */
    'name'?: string;
    /**
     * Rule UUID
     * @type {string}
     * @memberof V2RuleProxyRequest
     */
    'uuid'?: string;
    /**
     * Rule weight
     * @type {number}
     * @memberof V2RuleProxyRequest
     */
    'weight'?: number;
    /**
     * Whether rule is disabled
     * @type {boolean}
     * @memberof V2RuleProxyRequest
     */
    'disabled'?: boolean;
    /**
     * URL patterns
     * @type {Array<string>}
     * @memberof V2RuleProxyRequest
     */
    'url': Array<string>;
    /**
     * Country filter type (country_is, country_is_not, any)
     * @type {string}
     * @memberof V2RuleProxyRequest
     */
    'country'?: string;
    /**
     * Allowed countries
     * @type {Array<string>}
     * @memberof V2RuleProxyRequest
     */
    'country_is'?: Array<string>;
    /**
     * Excluded countries
     * @type {Array<string>}
     * @memberof V2RuleProxyRequest
     */
    'country_is_not'?: Array<string>;
    /**
     * Method filter type (method_is, method_is_not, any)
     * @type {string}
     * @memberof V2RuleProxyRequest
     */
    'method'?: string;
    /**
     * Allowed HTTP methods
     * @type {Array<string>}
     * @memberof V2RuleProxyRequest
     */
    'method_is'?: Array<string>;
    /**
     * Excluded HTTP methods
     * @type {Array<string>}
     * @memberof V2RuleProxyRequest
     */
    'method_is_not'?: Array<string>;
    /**
     * IP filter type (ip_is, ip_is_not, any)
     * @type {string}
     * @memberof V2RuleProxyRequest
     */
    'ip'?: string;
    /**
     * Allowed IP addresses
     * @type {Array<string>}
     * @memberof V2RuleProxyRequest
     */
    'ip_is'?: Array<string>;
    /**
     * Excluded IP addresses
     * @type {Array<string>}
     * @memberof V2RuleProxyRequest
     */
    'ip_is_not'?: Array<string>;
    /**
     * Target URL to proxy to
     * @type {string}
     * @memberof V2RuleProxyRequest
     */
    'to': string;
    /**
     * Host header override
     * @type {string}
     * @memberof V2RuleProxyRequest
     */
    'host'?: string;
    /**
     * Basic auth username
     * @type {string}
     * @memberof V2RuleProxyRequest
     */
    'auth_user'?: string;
    /**
     * Basic auth password
     * @type {string}
     * @memberof V2RuleProxyRequest
     */
    'auth_pass'?: string;
    /**
     * Disable SSL verification
     * @type {boolean}
     * @memberof V2RuleProxyRequest
     */
    'disable_ssl_verify'?: boolean;
    /**
     * Cache lifetime
     * @type {string}
     * @memberof V2RuleProxyRequest
     */
    'cache_lifetime'?: string | null;
    /**
     * Only proxy 404 responses
     * @type {boolean}
     * @memberof V2RuleProxyRequest
     */
    'only_proxy_404'?: boolean;
    /**
     * Headers to inject
     * @type {{ [key: string]: string; }}
     * @memberof V2RuleProxyRequest
     */
    'inject_headers'?: { [key: string]: string; } | null;
    /**
     * Headers to strip from response
     * @type {Array<string>}
     * @memberof V2RuleProxyRequest
     */
    'proxy_strip_headers'?: Array<string>;
    /**
     * Headers to strip from request
     * @type {Array<string>}
     * @memberof V2RuleProxyRequest
     */
    'proxy_strip_request_headers'?: Array<string>;
    /**
     * Origin timeout
     * @type {string}
     * @memberof V2RuleProxyRequest
     */
    'origin_timeout'?: string;
    /**
     * Enable failover mode
     * @type {boolean}
     * @memberof V2RuleProxyRequest
     */
    'failover_mode'?: boolean;
    /**
     * Failover TTFB threshold
     * @type {string}
     * @memberof V2RuleProxyRequest
     */
    'failover_origin_ttfb'?: string;
    /**
     * Status codes for failover (default: 200,404,301,302,304)
     * @type {Array<string>}
     * @memberof V2RuleProxyRequest
     */
    'failover_origin_status_codes'?: Array<string>;
    /**
     * Failover cache lifetime
     * @type {string}
     * @memberof V2RuleProxyRequest
     */
    'failover_lifetime'?: string;
    /**
     * Notification type (none, slack)
     * @type {string}
     * @memberof V2RuleProxyRequest
     */
    'notify'?: V2RuleProxyRequestNotifyEnum;
    /**
     * 
     * @type {V2RuleProxyActionAllOfNotifyConfig}
     * @memberof V2RuleProxyRequest
     */
    'notify_config'?: V2RuleProxyActionAllOfNotifyConfig | null;
    /**
     * WAF enabled
     * @type {boolean}
     * @memberof V2RuleProxyRequest
     */
    'waf_enabled'?: boolean;
    /**
     * 
     * @type {WafConfig}
     * @memberof V2RuleProxyRequest
     */
    'waf_config'?: WafConfig | null;
    /**
     * Proxy alert enabled
     * @type {boolean}
     * @memberof V2RuleProxyRequest
     */
    'proxy_alert_enabled'?: boolean;
    /**
     * Proxy inline function enabled
     * @type {boolean}
     * @memberof V2RuleProxyRequest
     */
    'proxy_inline_fn_enabled'?: boolean;
    /**
     * 
     * @type {V2RuleProxyActionAllOfQuantCloudSelection}
     * @memberof V2RuleProxyRequest
     */
    'quant_cloud_selection'?: V2RuleProxyActionAllOfQuantCloudSelection | null;
    /**
     * Static error page
     * @type {string}
     * @memberof V2RuleProxyRequest
     */
    'static_error_page'?: string;
    /**
     * Status codes for static error page
     * @type {Array<string>}
     * @memberof V2RuleProxyRequest
     */
    'static_error_page_status_codes'?: Array<string>;
    /**
     * Application proxy enabled
     * @type {boolean}
     * @memberof V2RuleProxyRequest
     */
    'application_proxy'?: boolean;
    /**
     * Application name
     * @type {string}
     * @memberof V2RuleProxyRequest
     */
    'application_name'?: string;
    /**
     * Application environment
     * @type {string}
     * @memberof V2RuleProxyRequest
     */
    'application_environment'?: string;
    /**
     * Application container
     * @type {string}
     * @memberof V2RuleProxyRequest
     */
    'application_container'?: string;
    /**
     * Application port
     * @type {number}
     * @memberof V2RuleProxyRequest
     */
    'application_port'?: number;
}

export const V2RuleProxyRequestNotifyEnum = {
    None: 'none',
    Slack: 'slack'
} as const;

export type V2RuleProxyRequestNotifyEnum = typeof V2RuleProxyRequestNotifyEnum[keyof typeof V2RuleProxyRequestNotifyEnum];

/**
 * 
 * @export
 * @interface V2RuleRedirect
 */
export interface V2RuleRedirect {
    /**
     * Error message
     * @type {string}
     * @memberof V2RuleRedirect
     */
    'message': string;
    /**
     * Error flag
     * @type {boolean}
     * @memberof V2RuleRedirect
     */
    'error': boolean;
    /**
     * Rule name
     * @type {string}
     * @memberof V2RuleRedirect
     */
    'name'?: string;
    /**
     * Rule UUID
     * @type {string}
     * @memberof V2RuleRedirect
     */
    'uuid': string;
    /**
     * Rule ID
     * @type {string}
     * @memberof V2RuleRedirect
     */
    'rule_id'?: string;
    /**
     * Rule weight
     * @type {number}
     * @memberof V2RuleRedirect
     */
    'weight'?: number;
    /**
     * URL patterns
     * @type {Array<string>}
     * @memberof V2RuleRedirect
     */
    'url'?: Array<string>;
    /**
     * Domain patterns
     * @type {Array<string>}
     * @memberof V2RuleRedirect
     */
    'domain'?: Array<string>;
    /**
     * Whether rule is disabled
     * @type {boolean}
     * @memberof V2RuleRedirect
     */
    'disabled': boolean;
    /**
     * Only apply with cookie
     * @type {string}
     * @memberof V2RuleRedirect
     */
    'only_with_cookie'?: string;
    /**
     * HTTP method
     * @type {string}
     * @memberof V2RuleRedirect
     */
    'method'?: string;
    /**
     * Allowed HTTP methods
     * @type {Array<string>}
     * @memberof V2RuleRedirect
     */
    'method_is'?: Array<string>;
    /**
     * Excluded HTTP methods
     * @type {Array<string>}
     * @memberof V2RuleRedirect
     */
    'method_is_not'?: Array<string>;
    /**
     * IP address
     * @type {string}
     * @memberof V2RuleRedirect
     */
    'ip'?: string;
    /**
     * Allowed IP addresses
     * @type {Array<string>}
     * @memberof V2RuleRedirect
     */
    'ip_is'?: Array<string>;
    /**
     * Excluded IP addresses
     * @type {Array<string>}
     * @memberof V2RuleRedirect
     */
    'ip_is_not'?: Array<string>;
    /**
     * Country code
     * @type {string}
     * @memberof V2RuleRedirect
     */
    'country'?: string;
    /**
     * Allowed countries
     * @type {Array<string>}
     * @memberof V2RuleRedirect
     */
    'country_is'?: Array<string>;
    /**
     * Excluded countries
     * @type {Array<string>}
     * @memberof V2RuleRedirect
     */
    'country_is_not'?: Array<string>;
    /**
     * Rule action
     * @type {string}
     * @memberof V2RuleRedirect
     */
    'action': string;
    /**
     * Target URL to proxy to
     * @type {string}
     * @memberof V2RuleRedirect
     */
    'to': string;
    /**
     * Host header override
     * @type {string}
     * @memberof V2RuleRedirect
     */
    'host'?: string;
    /**
     * Basic auth username
     * @type {string}
     * @memberof V2RuleRedirect
     */
    'auth_user'?: string;
    /**
     * Basic auth password
     * @type {string}
     * @memberof V2RuleRedirect
     */
    'auth_pass'?: string;
    /**
     * Disable SSL verification
     * @type {boolean}
     * @memberof V2RuleRedirect
     */
    'disable_ssl_verify'?: boolean;
    /**
     * Cache lifetime
     * @type {string}
     * @memberof V2RuleRedirect
     */
    'cache_lifetime'?: string | null;
    /**
     * Only proxy 404 responses
     * @type {boolean}
     * @memberof V2RuleRedirect
     */
    'only_proxy_404'?: boolean;
    /**
     * Headers to inject
     * @type {{ [key: string]: string; }}
     * @memberof V2RuleRedirect
     */
    'inject_headers'?: { [key: string]: string; } | null;
    /**
     * Headers to strip from response
     * @type {Array<string>}
     * @memberof V2RuleRedirect
     */
    'proxy_strip_headers'?: Array<string>;
    /**
     * Headers to strip from request
     * @type {Array<string>}
     * @memberof V2RuleRedirect
     */
    'proxy_strip_request_headers'?: Array<string>;
    /**
     * Origin timeout
     * @type {string}
     * @memberof V2RuleRedirect
     */
    'origin_timeout'?: string;
    /**
     * Enable failover mode
     * @type {boolean}
     * @memberof V2RuleRedirect
     */
    'failover_mode'?: boolean;
    /**
     * Failover TTFB threshold
     * @type {string}
     * @memberof V2RuleRedirect
     */
    'failover_origin_ttfb'?: string;
    /**
     * Status codes for failover (default: 200,404,301,302,304)
     * @type {Array<string>}
     * @memberof V2RuleRedirect
     */
    'failover_origin_status_codes'?: Array<string>;
    /**
     * Failover cache lifetime
     * @type {string}
     * @memberof V2RuleRedirect
     */
    'failover_lifetime'?: string;
    /**
     * Notification type (none, slack)
     * @type {string}
     * @memberof V2RuleRedirect
     */
    'notify'?: V2RuleRedirectNotifyEnum;
    /**
     * 
     * @type {V2RuleProxyActionAllOfNotifyConfig}
     * @memberof V2RuleRedirect
     */
    'notify_config'?: V2RuleProxyActionAllOfNotifyConfig | null;
    /**
     * WAF enabled
     * @type {boolean}
     * @memberof V2RuleRedirect
     */
    'waf_enabled'?: boolean;
    /**
     * 
     * @type {WafConfig}
     * @memberof V2RuleRedirect
     */
    'waf_config'?: WafConfig;
    /**
     * Proxy alert enabled
     * @type {boolean}
     * @memberof V2RuleRedirect
     */
    'proxy_alert_enabled'?: boolean;
    /**
     * Proxy inline function enabled
     * @type {boolean}
     * @memberof V2RuleRedirect
     */
    'proxy_inline_fn_enabled'?: boolean;
    /**
     * 
     * @type {V2RuleProxyActionAllOfQuantCloudSelection}
     * @memberof V2RuleRedirect
     */
    'quant_cloud_selection'?: V2RuleProxyActionAllOfQuantCloudSelection | null;
    /**
     * 
     * @type {V2RuleRedirectAction}
     * @memberof V2RuleRedirect
     */
    'action_config'?: V2RuleRedirectAction;
}

export const V2RuleRedirectNotifyEnum = {
    None: 'none',
    Slack: 'slack'
} as const;

export type V2RuleRedirectNotifyEnum = typeof V2RuleRedirectNotifyEnum[keyof typeof V2RuleRedirectNotifyEnum];

/**
 * 
 * @export
 * @interface V2RuleRedirectAction
 */
export interface V2RuleRedirectAction {
    /**
     * Error message
     * @type {string}
     * @memberof V2RuleRedirectAction
     */
    'message': string;
    /**
     * Error flag
     * @type {boolean}
     * @memberof V2RuleRedirectAction
     */
    'error': boolean;
    /**
     * Redirect destination URL
     * @type {string}
     * @memberof V2RuleRedirectAction
     */
    'to': string;
    /**
     * Host header override
     * @type {string}
     * @memberof V2RuleRedirectAction
     */
    'host'?: string;
    /**
     * Basic auth username
     * @type {string}
     * @memberof V2RuleRedirectAction
     */
    'auth_user'?: string;
    /**
     * Basic auth password
     * @type {string}
     * @memberof V2RuleRedirectAction
     */
    'auth_pass'?: string;
    /**
     * Disable SSL verification
     * @type {boolean}
     * @memberof V2RuleRedirectAction
     */
    'disable_ssl_verify'?: boolean;
    /**
     * Cache lifetime
     * @type {string}
     * @memberof V2RuleRedirectAction
     */
    'cache_lifetime'?: string | null;
    /**
     * Only proxy 404 responses
     * @type {boolean}
     * @memberof V2RuleRedirectAction
     */
    'only_proxy_404'?: boolean;
    /**
     * Headers to inject
     * @type {{ [key: string]: string; }}
     * @memberof V2RuleRedirectAction
     */
    'inject_headers'?: { [key: string]: string; } | null;
    /**
     * Headers to strip from response
     * @type {Array<string>}
     * @memberof V2RuleRedirectAction
     */
    'proxy_strip_headers'?: Array<string>;
    /**
     * Headers to strip from request
     * @type {Array<string>}
     * @memberof V2RuleRedirectAction
     */
    'proxy_strip_request_headers'?: Array<string>;
    /**
     * Origin timeout
     * @type {string}
     * @memberof V2RuleRedirectAction
     */
    'origin_timeout'?: string;
    /**
     * Enable failover mode
     * @type {boolean}
     * @memberof V2RuleRedirectAction
     */
    'failover_mode'?: boolean;
    /**
     * Failover TTFB threshold
     * @type {string}
     * @memberof V2RuleRedirectAction
     */
    'failover_origin_ttfb'?: string;
    /**
     * Status codes for failover (default: 200,404,301,302,304)
     * @type {Array<string>}
     * @memberof V2RuleRedirectAction
     */
    'failover_origin_status_codes'?: Array<string>;
    /**
     * Failover cache lifetime
     * @type {string}
     * @memberof V2RuleRedirectAction
     */
    'failover_lifetime'?: string;
    /**
     * Notification type (none, slack)
     * @type {string}
     * @memberof V2RuleRedirectAction
     */
    'notify'?: V2RuleRedirectActionNotifyEnum;
    /**
     * 
     * @type {V2RuleProxyActionAllOfNotifyConfig}
     * @memberof V2RuleRedirectAction
     */
    'notify_config'?: V2RuleProxyActionAllOfNotifyConfig | null;
    /**
     * WAF enabled
     * @type {boolean}
     * @memberof V2RuleRedirectAction
     */
    'waf_enabled'?: boolean;
    /**
     * 
     * @type {WafConfig}
     * @memberof V2RuleRedirectAction
     */
    'waf_config'?: WafConfig;
    /**
     * Proxy alert enabled
     * @type {boolean}
     * @memberof V2RuleRedirectAction
     */
    'proxy_alert_enabled'?: boolean;
    /**
     * Proxy inline function enabled
     * @type {boolean}
     * @memberof V2RuleRedirectAction
     */
    'proxy_inline_fn_enabled'?: boolean;
    /**
     * 
     * @type {V2RuleProxyActionAllOfQuantCloudSelection}
     * @memberof V2RuleRedirectAction
     */
    'quant_cloud_selection'?: V2RuleProxyActionAllOfQuantCloudSelection | null;
    /**
     * HTTP status code for redirect
     * @type {string}
     * @memberof V2RuleRedirectAction
     */
    'status_code'?: string;
}

export const V2RuleRedirectActionNotifyEnum = {
    None: 'none',
    Slack: 'slack'
} as const;

export type V2RuleRedirectActionNotifyEnum = typeof V2RuleRedirectActionNotifyEnum[keyof typeof V2RuleRedirectActionNotifyEnum];

/**
 * 
 * @export
 * @interface V2RuleRedirectRequest
 */
export interface V2RuleRedirectRequest {
    /**
     * Error message
     * @type {string}
     * @memberof V2RuleRedirectRequest
     */
    'message': string;
    /**
     * Error flag
     * @type {boolean}
     * @memberof V2RuleRedirectRequest
     */
    'error': boolean;
    /**
     * Domain patterns (default: any)
     * @type {Array<string>}
     * @memberof V2RuleRedirectRequest
     */
    'domain': Array<string>;
    /**
     * Rule name
     * @type {string}
     * @memberof V2RuleRedirectRequest
     */
    'name'?: string;
    /**
     * Rule UUID
     * @type {string}
     * @memberof V2RuleRedirectRequest
     */
    'uuid'?: string;
    /**
     * Rule weight
     * @type {number}
     * @memberof V2RuleRedirectRequest
     */
    'weight'?: number;
    /**
     * Whether rule is disabled
     * @type {boolean}
     * @memberof V2RuleRedirectRequest
     */
    'disabled'?: boolean;
    /**
     * URL patterns
     * @type {Array<string>}
     * @memberof V2RuleRedirectRequest
     */
    'url': Array<string>;
    /**
     * Country filter type (country_is, country_is_not, any)
     * @type {string}
     * @memberof V2RuleRedirectRequest
     */
    'country'?: string;
    /**
     * Allowed countries
     * @type {Array<string>}
     * @memberof V2RuleRedirectRequest
     */
    'country_is'?: Array<string>;
    /**
     * Excluded countries
     * @type {Array<string>}
     * @memberof V2RuleRedirectRequest
     */
    'country_is_not'?: Array<string>;
    /**
     * Method filter type (method_is, method_is_not, any)
     * @type {string}
     * @memberof V2RuleRedirectRequest
     */
    'method'?: string;
    /**
     * Allowed HTTP methods
     * @type {Array<string>}
     * @memberof V2RuleRedirectRequest
     */
    'method_is'?: Array<string>;
    /**
     * Excluded HTTP methods
     * @type {Array<string>}
     * @memberof V2RuleRedirectRequest
     */
    'method_is_not'?: Array<string>;
    /**
     * IP filter type (ip_is, ip_is_not, any)
     * @type {string}
     * @memberof V2RuleRedirectRequest
     */
    'ip'?: string;
    /**
     * Allowed IP addresses
     * @type {Array<string>}
     * @memberof V2RuleRedirectRequest
     */
    'ip_is'?: Array<string>;
    /**
     * Excluded IP addresses
     * @type {Array<string>}
     * @memberof V2RuleRedirectRequest
     */
    'ip_is_not'?: Array<string>;
    /**
     * Target URL to proxy to
     * @type {string}
     * @memberof V2RuleRedirectRequest
     */
    'to': string;
    /**
     * Host header override
     * @type {string}
     * @memberof V2RuleRedirectRequest
     */
    'host'?: string;
    /**
     * Basic auth username
     * @type {string}
     * @memberof V2RuleRedirectRequest
     */
    'auth_user'?: string;
    /**
     * Basic auth password
     * @type {string}
     * @memberof V2RuleRedirectRequest
     */
    'auth_pass'?: string;
    /**
     * Disable SSL verification
     * @type {boolean}
     * @memberof V2RuleRedirectRequest
     */
    'disable_ssl_verify'?: boolean;
    /**
     * Cache lifetime
     * @type {string}
     * @memberof V2RuleRedirectRequest
     */
    'cache_lifetime'?: string | null;
    /**
     * Only proxy 404 responses
     * @type {boolean}
     * @memberof V2RuleRedirectRequest
     */
    'only_proxy_404'?: boolean;
    /**
     * Headers to inject
     * @type {{ [key: string]: string; }}
     * @memberof V2RuleRedirectRequest
     */
    'inject_headers'?: { [key: string]: string; } | null;
    /**
     * Headers to strip from response
     * @type {Array<string>}
     * @memberof V2RuleRedirectRequest
     */
    'proxy_strip_headers'?: Array<string>;
    /**
     * Headers to strip from request
     * @type {Array<string>}
     * @memberof V2RuleRedirectRequest
     */
    'proxy_strip_request_headers'?: Array<string>;
    /**
     * Origin timeout
     * @type {string}
     * @memberof V2RuleRedirectRequest
     */
    'origin_timeout'?: string;
    /**
     * Enable failover mode
     * @type {boolean}
     * @memberof V2RuleRedirectRequest
     */
    'failover_mode'?: boolean;
    /**
     * Failover TTFB threshold
     * @type {string}
     * @memberof V2RuleRedirectRequest
     */
    'failover_origin_ttfb'?: string;
    /**
     * Status codes for failover (default: 200,404,301,302,304)
     * @type {Array<string>}
     * @memberof V2RuleRedirectRequest
     */
    'failover_origin_status_codes'?: Array<string>;
    /**
     * Failover cache lifetime
     * @type {string}
     * @memberof V2RuleRedirectRequest
     */
    'failover_lifetime'?: string;
    /**
     * Notification type (none, slack)
     * @type {string}
     * @memberof V2RuleRedirectRequest
     */
    'notify'?: V2RuleRedirectRequestNotifyEnum;
    /**
     * 
     * @type {V2RuleProxyActionAllOfNotifyConfig}
     * @memberof V2RuleRedirectRequest
     */
    'notify_config'?: V2RuleProxyActionAllOfNotifyConfig | null;
    /**
     * WAF enabled
     * @type {boolean}
     * @memberof V2RuleRedirectRequest
     */
    'waf_enabled'?: boolean;
    /**
     * 
     * @type {WafConfig}
     * @memberof V2RuleRedirectRequest
     */
    'waf_config'?: WafConfig;
    /**
     * Proxy alert enabled
     * @type {boolean}
     * @memberof V2RuleRedirectRequest
     */
    'proxy_alert_enabled'?: boolean;
    /**
     * Proxy inline function enabled
     * @type {boolean}
     * @memberof V2RuleRedirectRequest
     */
    'proxy_inline_fn_enabled'?: boolean;
    /**
     * 
     * @type {V2RuleProxyActionAllOfQuantCloudSelection}
     * @memberof V2RuleRedirectRequest
     */
    'quant_cloud_selection'?: V2RuleProxyActionAllOfQuantCloudSelection | null;
    /**
     * Redirect destination URL
     * @type {string}
     * @memberof V2RuleRedirectRequest
     */
    'redirect_to': string;
    /**
     * HTTP status code for redirect
     * @type {string}
     * @memberof V2RuleRedirectRequest
     */
    'redirect_code'?: string;
}

export const V2RuleRedirectRequestNotifyEnum = {
    None: 'none',
    Slack: 'slack'
} as const;

export type V2RuleRedirectRequestNotifyEnum = typeof V2RuleRedirectRequestNotifyEnum[keyof typeof V2RuleRedirectRequestNotifyEnum];

/**
 * 
 * @export
 * @interface V2RuleRequest
 */
export interface V2RuleRequest {
    /**
     * Error message
     * @type {string}
     * @memberof V2RuleRequest
     */
    'message': string;
    /**
     * Error flag
     * @type {boolean}
     * @memberof V2RuleRequest
     */
    'error': boolean;
    /**
     * Domain patterns (default: any)
     * @type {Array<string>}
     * @memberof V2RuleRequest
     */
    'domain': Array<string>;
    /**
     * Rule name
     * @type {string}
     * @memberof V2RuleRequest
     */
    'name'?: string;
    /**
     * Rule UUID
     * @type {string}
     * @memberof V2RuleRequest
     */
    'uuid'?: string;
    /**
     * Rule weight
     * @type {number}
     * @memberof V2RuleRequest
     */
    'weight'?: number;
    /**
     * Whether rule is disabled
     * @type {boolean}
     * @memberof V2RuleRequest
     */
    'disabled'?: boolean;
    /**
     * URL patterns
     * @type {Array<string>}
     * @memberof V2RuleRequest
     */
    'url': Array<string>;
    /**
     * Country filter type (country_is, country_is_not, any)
     * @type {string}
     * @memberof V2RuleRequest
     */
    'country'?: string;
    /**
     * Allowed countries
     * @type {Array<string>}
     * @memberof V2RuleRequest
     */
    'country_is'?: Array<string>;
    /**
     * Excluded countries
     * @type {Array<string>}
     * @memberof V2RuleRequest
     */
    'country_is_not'?: Array<string>;
    /**
     * Method filter type (method_is, method_is_not, any)
     * @type {string}
     * @memberof V2RuleRequest
     */
    'method'?: string;
    /**
     * Allowed HTTP methods
     * @type {Array<string>}
     * @memberof V2RuleRequest
     */
    'method_is'?: Array<string>;
    /**
     * Excluded HTTP methods
     * @type {Array<string>}
     * @memberof V2RuleRequest
     */
    'method_is_not'?: Array<string>;
    /**
     * IP filter type (ip_is, ip_is_not, any)
     * @type {string}
     * @memberof V2RuleRequest
     */
    'ip'?: string;
    /**
     * Allowed IP addresses
     * @type {Array<string>}
     * @memberof V2RuleRequest
     */
    'ip_is'?: Array<string>;
    /**
     * Excluded IP addresses
     * @type {Array<string>}
     * @memberof V2RuleRequest
     */
    'ip_is_not'?: Array<string>;
}
/**
 * 
 * @export
 * @interface V2RuleServeStatic
 */
export interface V2RuleServeStatic {
    /**
     * Error message
     * @type {string}
     * @memberof V2RuleServeStatic
     */
    'message': string;
    /**
     * Error flag
     * @type {boolean}
     * @memberof V2RuleServeStatic
     */
    'error': boolean;
    /**
     * Rule name
     * @type {string}
     * @memberof V2RuleServeStatic
     */
    'name'?: string;
    /**
     * Rule UUID
     * @type {string}
     * @memberof V2RuleServeStatic
     */
    'uuid': string;
    /**
     * Rule ID
     * @type {string}
     * @memberof V2RuleServeStatic
     */
    'rule_id'?: string;
    /**
     * Rule weight
     * @type {number}
     * @memberof V2RuleServeStatic
     */
    'weight'?: number;
    /**
     * URL patterns
     * @type {Array<string>}
     * @memberof V2RuleServeStatic
     */
    'url'?: Array<string>;
    /**
     * Domain patterns
     * @type {Array<string>}
     * @memberof V2RuleServeStatic
     */
    'domain'?: Array<string>;
    /**
     * Whether rule is disabled
     * @type {boolean}
     * @memberof V2RuleServeStatic
     */
    'disabled': boolean;
    /**
     * Only apply with cookie
     * @type {string}
     * @memberof V2RuleServeStatic
     */
    'only_with_cookie'?: string;
    /**
     * HTTP method
     * @type {string}
     * @memberof V2RuleServeStatic
     */
    'method'?: string;
    /**
     * Allowed HTTP methods
     * @type {Array<string>}
     * @memberof V2RuleServeStatic
     */
    'method_is'?: Array<string>;
    /**
     * Excluded HTTP methods
     * @type {Array<string>}
     * @memberof V2RuleServeStatic
     */
    'method_is_not'?: Array<string>;
    /**
     * IP address
     * @type {string}
     * @memberof V2RuleServeStatic
     */
    'ip'?: string;
    /**
     * Allowed IP addresses
     * @type {Array<string>}
     * @memberof V2RuleServeStatic
     */
    'ip_is'?: Array<string>;
    /**
     * Excluded IP addresses
     * @type {Array<string>}
     * @memberof V2RuleServeStatic
     */
    'ip_is_not'?: Array<string>;
    /**
     * Country code
     * @type {string}
     * @memberof V2RuleServeStatic
     */
    'country'?: string;
    /**
     * Allowed countries
     * @type {Array<string>}
     * @memberof V2RuleServeStatic
     */
    'country_is'?: Array<string>;
    /**
     * Excluded countries
     * @type {Array<string>}
     * @memberof V2RuleServeStatic
     */
    'country_is_not'?: Array<string>;
    /**
     * Rule action
     * @type {string}
     * @memberof V2RuleServeStatic
     */
    'action': string;
    /**
     * Target URL to proxy to
     * @type {string}
     * @memberof V2RuleServeStatic
     */
    'to': string;
    /**
     * Host header override
     * @type {string}
     * @memberof V2RuleServeStatic
     */
    'host'?: string;
    /**
     * Basic auth username
     * @type {string}
     * @memberof V2RuleServeStatic
     */
    'auth_user'?: string;
    /**
     * Basic auth password
     * @type {string}
     * @memberof V2RuleServeStatic
     */
    'auth_pass'?: string;
    /**
     * Disable SSL verification
     * @type {boolean}
     * @memberof V2RuleServeStatic
     */
    'disable_ssl_verify'?: boolean;
    /**
     * Cache lifetime
     * @type {string}
     * @memberof V2RuleServeStatic
     */
    'cache_lifetime'?: string | null;
    /**
     * Only proxy 404 responses
     * @type {boolean}
     * @memberof V2RuleServeStatic
     */
    'only_proxy_404'?: boolean;
    /**
     * Headers to inject
     * @type {{ [key: string]: string; }}
     * @memberof V2RuleServeStatic
     */
    'inject_headers'?: { [key: string]: string; } | null;
    /**
     * Headers to strip from response
     * @type {Array<string>}
     * @memberof V2RuleServeStatic
     */
    'proxy_strip_headers'?: Array<string>;
    /**
     * Headers to strip from request
     * @type {Array<string>}
     * @memberof V2RuleServeStatic
     */
    'proxy_strip_request_headers'?: Array<string>;
    /**
     * Origin timeout
     * @type {string}
     * @memberof V2RuleServeStatic
     */
    'origin_timeout'?: string;
    /**
     * Enable failover mode
     * @type {boolean}
     * @memberof V2RuleServeStatic
     */
    'failover_mode'?: boolean;
    /**
     * Failover TTFB threshold
     * @type {string}
     * @memberof V2RuleServeStatic
     */
    'failover_origin_ttfb'?: string;
    /**
     * Status codes for failover (default: 200,404,301,302,304)
     * @type {Array<string>}
     * @memberof V2RuleServeStatic
     */
    'failover_origin_status_codes'?: Array<string>;
    /**
     * Failover cache lifetime
     * @type {string}
     * @memberof V2RuleServeStatic
     */
    'failover_lifetime'?: string;
    /**
     * Notification type (none, slack)
     * @type {string}
     * @memberof V2RuleServeStatic
     */
    'notify'?: V2RuleServeStaticNotifyEnum;
    /**
     * 
     * @type {V2RuleProxyActionAllOfNotifyConfig}
     * @memberof V2RuleServeStatic
     */
    'notify_config'?: V2RuleProxyActionAllOfNotifyConfig | null;
    /**
     * WAF enabled
     * @type {boolean}
     * @memberof V2RuleServeStatic
     */
    'waf_enabled'?: boolean;
    /**
     * 
     * @type {WafConfig}
     * @memberof V2RuleServeStatic
     */
    'waf_config'?: WafConfig;
    /**
     * Proxy alert enabled
     * @type {boolean}
     * @memberof V2RuleServeStatic
     */
    'proxy_alert_enabled'?: boolean;
    /**
     * Proxy inline function enabled
     * @type {boolean}
     * @memberof V2RuleServeStatic
     */
    'proxy_inline_fn_enabled'?: boolean;
    /**
     * 
     * @type {V2RuleProxyActionAllOfQuantCloudSelection}
     * @memberof V2RuleServeStatic
     */
    'quant_cloud_selection'?: V2RuleProxyActionAllOfQuantCloudSelection | null;
    /**
     * 
     * @type {V2RuleServeStaticAction}
     * @memberof V2RuleServeStatic
     */
    'action_config': V2RuleServeStaticAction;
}

export const V2RuleServeStaticNotifyEnum = {
    None: 'none',
    Slack: 'slack'
} as const;

export type V2RuleServeStaticNotifyEnum = typeof V2RuleServeStaticNotifyEnum[keyof typeof V2RuleServeStaticNotifyEnum];

/**
 * 
 * @export
 * @interface V2RuleServeStaticAction
 */
export interface V2RuleServeStaticAction {
    /**
     * Error message
     * @type {string}
     * @memberof V2RuleServeStaticAction
     */
    'message': string;
    /**
     * Error flag
     * @type {boolean}
     * @memberof V2RuleServeStaticAction
     */
    'error': boolean;
    /**
     * Target URL to proxy to
     * @type {string}
     * @memberof V2RuleServeStaticAction
     */
    'to': string;
    /**
     * Host header override
     * @type {string}
     * @memberof V2RuleServeStaticAction
     */
    'host'?: string;
    /**
     * Basic auth username
     * @type {string}
     * @memberof V2RuleServeStaticAction
     */
    'auth_user'?: string;
    /**
     * Basic auth password
     * @type {string}
     * @memberof V2RuleServeStaticAction
     */
    'auth_pass'?: string;
    /**
     * Disable SSL verification
     * @type {boolean}
     * @memberof V2RuleServeStaticAction
     */
    'disable_ssl_verify'?: boolean;
    /**
     * Cache lifetime
     * @type {string}
     * @memberof V2RuleServeStaticAction
     */
    'cache_lifetime'?: string | null;
    /**
     * Only proxy 404 responses
     * @type {boolean}
     * @memberof V2RuleServeStaticAction
     */
    'only_proxy_404'?: boolean;
    /**
     * Headers to inject
     * @type {{ [key: string]: string; }}
     * @memberof V2RuleServeStaticAction
     */
    'inject_headers'?: { [key: string]: string; } | null;
    /**
     * Headers to strip from response
     * @type {Array<string>}
     * @memberof V2RuleServeStaticAction
     */
    'proxy_strip_headers'?: Array<string>;
    /**
     * Headers to strip from request
     * @type {Array<string>}
     * @memberof V2RuleServeStaticAction
     */
    'proxy_strip_request_headers'?: Array<string>;
    /**
     * Origin timeout
     * @type {string}
     * @memberof V2RuleServeStaticAction
     */
    'origin_timeout'?: string;
    /**
     * Enable failover mode
     * @type {boolean}
     * @memberof V2RuleServeStaticAction
     */
    'failover_mode'?: boolean;
    /**
     * Failover TTFB threshold
     * @type {string}
     * @memberof V2RuleServeStaticAction
     */
    'failover_origin_ttfb'?: string;
    /**
     * Status codes for failover (default: 200,404,301,302,304)
     * @type {Array<string>}
     * @memberof V2RuleServeStaticAction
     */
    'failover_origin_status_codes'?: Array<string>;
    /**
     * Failover cache lifetime
     * @type {string}
     * @memberof V2RuleServeStaticAction
     */
    'failover_lifetime'?: string;
    /**
     * Notification type (none, slack)
     * @type {string}
     * @memberof V2RuleServeStaticAction
     */
    'notify'?: V2RuleServeStaticActionNotifyEnum;
    /**
     * 
     * @type {V2RuleProxyActionAllOfNotifyConfig}
     * @memberof V2RuleServeStaticAction
     */
    'notify_config'?: V2RuleProxyActionAllOfNotifyConfig | null;
    /**
     * WAF enabled
     * @type {boolean}
     * @memberof V2RuleServeStaticAction
     */
    'waf_enabled'?: boolean;
    /**
     * 
     * @type {WafConfig}
     * @memberof V2RuleServeStaticAction
     */
    'waf_config'?: WafConfig;
    /**
     * Proxy alert enabled
     * @type {boolean}
     * @memberof V2RuleServeStaticAction
     */
    'proxy_alert_enabled'?: boolean;
    /**
     * Proxy inline function enabled
     * @type {boolean}
     * @memberof V2RuleServeStaticAction
     */
    'proxy_inline_fn_enabled'?: boolean;
    /**
     * 
     * @type {V2RuleProxyActionAllOfQuantCloudSelection}
     * @memberof V2RuleServeStaticAction
     */
    'quant_cloud_selection'?: V2RuleProxyActionAllOfQuantCloudSelection | null;
    /**
     * Path to the static file to serve
     * @type {string}
     * @memberof V2RuleServeStaticAction
     */
    'static_file_path': string;
}

export const V2RuleServeStaticActionNotifyEnum = {
    None: 'none',
    Slack: 'slack'
} as const;

export type V2RuleServeStaticActionNotifyEnum = typeof V2RuleServeStaticActionNotifyEnum[keyof typeof V2RuleServeStaticActionNotifyEnum];

/**
 * 
 * @export
 * @interface V2RuleServeStaticRequest
 */
export interface V2RuleServeStaticRequest {
    /**
     * Error message
     * @type {string}
     * @memberof V2RuleServeStaticRequest
     */
    'message': string;
    /**
     * Error flag
     * @type {boolean}
     * @memberof V2RuleServeStaticRequest
     */
    'error': boolean;
    /**
     * Domain patterns (default: any)
     * @type {Array<string>}
     * @memberof V2RuleServeStaticRequest
     */
    'domain': Array<string>;
    /**
     * Rule name
     * @type {string}
     * @memberof V2RuleServeStaticRequest
     */
    'name'?: string;
    /**
     * Rule UUID
     * @type {string}
     * @memberof V2RuleServeStaticRequest
     */
    'uuid'?: string;
    /**
     * Rule weight
     * @type {number}
     * @memberof V2RuleServeStaticRequest
     */
    'weight'?: number;
    /**
     * Whether rule is disabled
     * @type {boolean}
     * @memberof V2RuleServeStaticRequest
     */
    'disabled'?: boolean;
    /**
     * URL patterns
     * @type {Array<string>}
     * @memberof V2RuleServeStaticRequest
     */
    'url': Array<string>;
    /**
     * Country filter type (country_is, country_is_not, any)
     * @type {string}
     * @memberof V2RuleServeStaticRequest
     */
    'country'?: string;
    /**
     * Allowed countries
     * @type {Array<string>}
     * @memberof V2RuleServeStaticRequest
     */
    'country_is'?: Array<string>;
    /**
     * Excluded countries
     * @type {Array<string>}
     * @memberof V2RuleServeStaticRequest
     */
    'country_is_not'?: Array<string>;
    /**
     * Method filter type (method_is, method_is_not, any)
     * @type {string}
     * @memberof V2RuleServeStaticRequest
     */
    'method'?: string;
    /**
     * Allowed HTTP methods
     * @type {Array<string>}
     * @memberof V2RuleServeStaticRequest
     */
    'method_is'?: Array<string>;
    /**
     * Excluded HTTP methods
     * @type {Array<string>}
     * @memberof V2RuleServeStaticRequest
     */
    'method_is_not'?: Array<string>;
    /**
     * IP filter type (ip_is, ip_is_not, any)
     * @type {string}
     * @memberof V2RuleServeStaticRequest
     */
    'ip'?: string;
    /**
     * Allowed IP addresses
     * @type {Array<string>}
     * @memberof V2RuleServeStaticRequest
     */
    'ip_is'?: Array<string>;
    /**
     * Excluded IP addresses
     * @type {Array<string>}
     * @memberof V2RuleServeStaticRequest
     */
    'ip_is_not'?: Array<string>;
    /**
     * Target URL to proxy to
     * @type {string}
     * @memberof V2RuleServeStaticRequest
     */
    'to': string;
    /**
     * Host header override
     * @type {string}
     * @memberof V2RuleServeStaticRequest
     */
    'host'?: string;
    /**
     * Basic auth username
     * @type {string}
     * @memberof V2RuleServeStaticRequest
     */
    'auth_user'?: string;
    /**
     * Basic auth password
     * @type {string}
     * @memberof V2RuleServeStaticRequest
     */
    'auth_pass'?: string;
    /**
     * Disable SSL verification
     * @type {boolean}
     * @memberof V2RuleServeStaticRequest
     */
    'disable_ssl_verify'?: boolean;
    /**
     * Cache lifetime
     * @type {string}
     * @memberof V2RuleServeStaticRequest
     */
    'cache_lifetime'?: string | null;
    /**
     * Only proxy 404 responses
     * @type {boolean}
     * @memberof V2RuleServeStaticRequest
     */
    'only_proxy_404'?: boolean;
    /**
     * Headers to inject
     * @type {{ [key: string]: string; }}
     * @memberof V2RuleServeStaticRequest
     */
    'inject_headers'?: { [key: string]: string; } | null;
    /**
     * Headers to strip from response
     * @type {Array<string>}
     * @memberof V2RuleServeStaticRequest
     */
    'proxy_strip_headers'?: Array<string>;
    /**
     * Headers to strip from request
     * @type {Array<string>}
     * @memberof V2RuleServeStaticRequest
     */
    'proxy_strip_request_headers'?: Array<string>;
    /**
     * Origin timeout
     * @type {string}
     * @memberof V2RuleServeStaticRequest
     */
    'origin_timeout'?: string;
    /**
     * Enable failover mode
     * @type {boolean}
     * @memberof V2RuleServeStaticRequest
     */
    'failover_mode'?: boolean;
    /**
     * Failover TTFB threshold
     * @type {string}
     * @memberof V2RuleServeStaticRequest
     */
    'failover_origin_ttfb'?: string;
    /**
     * Status codes for failover (default: 200,404,301,302,304)
     * @type {Array<string>}
     * @memberof V2RuleServeStaticRequest
     */
    'failover_origin_status_codes'?: Array<string>;
    /**
     * Failover cache lifetime
     * @type {string}
     * @memberof V2RuleServeStaticRequest
     */
    'failover_lifetime'?: string;
    /**
     * Notification type (none, slack)
     * @type {string}
     * @memberof V2RuleServeStaticRequest
     */
    'notify'?: V2RuleServeStaticRequestNotifyEnum;
    /**
     * 
     * @type {V2RuleProxyActionAllOfNotifyConfig}
     * @memberof V2RuleServeStaticRequest
     */
    'notify_config'?: V2RuleProxyActionAllOfNotifyConfig | null;
    /**
     * WAF enabled
     * @type {boolean}
     * @memberof V2RuleServeStaticRequest
     */
    'waf_enabled'?: boolean;
    /**
     * 
     * @type {WafConfig}
     * @memberof V2RuleServeStaticRequest
     */
    'waf_config'?: WafConfig;
    /**
     * Proxy alert enabled
     * @type {boolean}
     * @memberof V2RuleServeStaticRequest
     */
    'proxy_alert_enabled'?: boolean;
    /**
     * Proxy inline function enabled
     * @type {boolean}
     * @memberof V2RuleServeStaticRequest
     */
    'proxy_inline_fn_enabled'?: boolean;
    /**
     * 
     * @type {V2RuleProxyActionAllOfQuantCloudSelection}
     * @memberof V2RuleServeStaticRequest
     */
    'quant_cloud_selection'?: V2RuleProxyActionAllOfQuantCloudSelection | null;
    /**
     * Path to the static file to serve
     * @type {string}
     * @memberof V2RuleServeStaticRequest
     */
    'static_file_path': string;
}

export const V2RuleServeStaticRequestNotifyEnum = {
    None: 'none',
    Slack: 'slack'
} as const;

export type V2RuleServeStaticRequestNotifyEnum = typeof V2RuleServeStaticRequestNotifyEnum[keyof typeof V2RuleServeStaticRequestNotifyEnum];

/**
 * 
 * @export
 * @interface V2SecretStore
 */
export interface V2SecretStore {
    /**
     * Error message
     * @type {string}
     * @memberof V2SecretStore
     */
    'message': string;
    /**
     * Error flag
     * @type {boolean}
     * @memberof V2SecretStore
     */
    'error': boolean;
    /**
     * Secret store ID
     * @type {string}
     * @memberof V2SecretStore
     */
    'id': string;
    /**
     * Secret store name
     * @type {string}
     * @memberof V2SecretStore
     */
    'name': string;
}
/**
 * 
 * @export
 * @interface V2SecretStoreRequest
 */
export interface V2SecretStoreRequest {
    /**
     * Error message
     * @type {string}
     * @memberof V2SecretStoreRequest
     */
    'message': string;
    /**
     * Error flag
     * @type {boolean}
     * @memberof V2SecretStoreRequest
     */
    'error': boolean;
    /**
     * Secret store name
     * @type {string}
     * @memberof V2SecretStoreRequest
     */
    'name': string;
}
/**
 * 
 * @export
 * @interface V2Store
 */
export interface V2Store {
    /**
     * Error message
     * @type {string}
     * @memberof V2Store
     */
    'message': string;
    /**
     * Error flag
     * @type {boolean}
     * @memberof V2Store
     */
    'error': boolean;
    /**
     * Store ID
     * @type {string}
     * @memberof V2Store
     */
    'id': string;
    /**
     * Store name
     * @type {string}
     * @memberof V2Store
     */
    'name': string;
}
/**
 * 
 * @export
 * @interface V2StoreItem
 */
export interface V2StoreItem {
    /**
     * Error message
     * @type {string}
     * @memberof V2StoreItem
     */
    'message': string;
    /**
     * Error flag
     * @type {boolean}
     * @memberof V2StoreItem
     */
    'error': boolean;
    /**
     * Item key
     * @type {string}
     * @memberof V2StoreItem
     */
    'key': string;
    /**
     * Item value (can be JSON string)
     * @type {string}
     * @memberof V2StoreItem
     */
    'value': string;
}
/**
 * 
 * @export
 * @interface V2StoreItemRequest
 */
export interface V2StoreItemRequest {
    /**
     * Error message
     * @type {string}
     * @memberof V2StoreItemRequest
     */
    'message': string;
    /**
     * Error flag
     * @type {boolean}
     * @memberof V2StoreItemRequest
     */
    'error': boolean;
    /**
     * Item key
     * @type {string}
     * @memberof V2StoreItemRequest
     */
    'key': string;
    /**
     * Item value (can be JSON string)
     * @type {string}
     * @memberof V2StoreItemRequest
     */
    'value': string;
}
/**
 * 
 * @export
 * @interface V2StoreItemUpdateRequest
 */
export interface V2StoreItemUpdateRequest {
    /**
     * Error message
     * @type {string}
     * @memberof V2StoreItemUpdateRequest
     */
    'message': string;
    /**
     * Error flag
     * @type {boolean}
     * @memberof V2StoreItemUpdateRequest
     */
    'error': boolean;
    /**
     * Item value (can be JSON string)
     * @type {string}
     * @memberof V2StoreItemUpdateRequest
     */
    'value': string;
}
/**
 * 
 * @export
 * @interface V2StoreItemsListResponse
 */
export interface V2StoreItemsListResponse {
    /**
     * Error message
     * @type {string}
     * @memberof V2StoreItemsListResponse
     */
    'message': string;
    /**
     * Error flag
     * @type {boolean}
     * @memberof V2StoreItemsListResponse
     */
    'error': boolean;
    /**
     * List of item keys
     * @type {Array<string>}
     * @memberof V2StoreItemsListResponse
     */
    'data'?: Array<string>;
    /**
     * Cursor for next page of results
     * @type {string}
     * @memberof V2StoreItemsListResponse
     */
    'next_cursor'?: string | null;
}
/**
 * 
 * @export
 * @interface V2StoreRequest
 */
export interface V2StoreRequest {
    /**
     * Error message
     * @type {string}
     * @memberof V2StoreRequest
     */
    'message': string;
    /**
     * Error flag
     * @type {boolean}
     * @memberof V2StoreRequest
     */
    'error': boolean;
    /**
     * Store name
     * @type {string}
     * @memberof V2StoreRequest
     */
    'name': string;
}
/**
 * 
 * @export
 * @interface ValidateCompose200Response
 */
export interface ValidateCompose200Response {
    /**
     * 
     * @type {string}
     * @memberof ValidateCompose200Response
     */
    'message': string;
    /**
     * The translated internal compose definition format
     * @type {object}
     * @memberof ValidateCompose200Response
     */
    'translatedComposeDefinition': object;
    /**
     * Optional warnings encountered during translation
     * @type {Array<string>}
     * @memberof ValidateCompose200Response
     */
    'translationWarnings'?: Array<string> | null;
}
/**
 * 
 * @export
 * @interface ValidateCompose422Response
 */
export interface ValidateCompose422Response {
    /**
     * 
     * @type {string}
     * @memberof ValidateCompose422Response
     */
    'error'?: string;
}
/**
 * 
 * @export
 * @interface ValidateComposeRequest
 */
export interface ValidateComposeRequest {
    /**
     * The docker-compose.yml file content as a string
     * @type {string}
     * @memberof ValidateComposeRequest
     */
    'compose': string;
    /**
     * Optional image tag suffix (query parameter takes precedence)
     * @type {string}
     * @memberof ValidateComposeRequest
     */
    'imageSuffix'?: string;
    /**
     * Optional application name for context
     * @type {string}
     * @memberof ValidateComposeRequest
     */
    'application'?: string;
}
/**
 * 
 * @export
 * @interface Variable
 */
export interface Variable {
    /**
     * 
     * @type {string}
     * @memberof Variable
     */
    'key'?: string;
    /**
     * 
     * @type {string}
     * @memberof Variable
     */
    'value'?: string;
}
/**
 * 
 * @export
 * @interface Volume
 */
export interface Volume {
    /**
     * 
     * @type {string}
     * @memberof Volume
     */
    'volumeId'?: string;
    /**
     * 
     * @type {string}
     * @memberof Volume
     */
    'volumeName'?: string;
    /**
     * 
     * @type {string}
     * @memberof Volume
     */
    'description'?: string;
    /**
     * 
     * @type {string}
     * @memberof Volume
     */
    'environmentEfsId'?: string;
    /**
     * 
     * @type {string}
     * @memberof Volume
     */
    'createdAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof Volume
     */
    'rootDirectory'?: string;
    /**
     * 
     * @type {string}
     * @memberof Volume
     */
    'accessPointId'?: string;
    /**
     * 
     * @type {string}
     * @memberof Volume
     */
    'accessPointArn'?: string;
}
/**
 * Web Application Firewall configuration
 * @export
 * @interface WafConfig
 */
export interface WafConfig {
    /**
     * WAF operation mode
     * @type {string}
     * @memberof WafConfig
     */
    'mode'?: WafConfigModeEnum;
    /**
     * OWASP paranoia level
     * @type {number}
     * @memberof WafConfig
     */
    'paranoia_level'?: number;
    /**
     * WAF rule IDs to allow/whitelist
     * @type {Array<string>}
     * @memberof WafConfig
     */
    'allow_rules'?: Array<string>;
    /**
     * IP addresses to allow
     * @type {Array<string>}
     * @memberof WafConfig
     */
    'allow_ip'?: Array<string>;
    /**
     * IP addresses to block
     * @type {Array<string>}
     * @memberof WafConfig
     */
    'block_ip'?: Array<string>;
    /**
     * ASN numbers to block
     * @type {Array<string>}
     * @memberof WafConfig
     */
    'block_asn'?: Array<string>;
    /**
     * User agent patterns to block
     * @type {Array<string>}
     * @memberof WafConfig
     */
    'block_ua'?: Array<string>;
    /**
     * Referer patterns to block
     * @type {Array<string>}
     * @memberof WafConfig
     */
    'block_referer'?: Array<string>;
    /**
     * Slack webhook URL for notifications
     * @type {string}
     * @memberof WafConfig
     */
    'notify_slack'?: string;
    /**
     * Minimum hits per minute to trigger Slack notification
     * @type {number}
     * @memberof WafConfig
     */
    'notify_slack_hits_rpm'?: number;
    /**
     * Email addresses for notifications
     * @type {Array<string>}
     * @memberof WafConfig
     */
    'notify_email'?: Array<string>;
    /**
     * 
     * @type {WafConfigHttpbl}
     * @memberof WafConfig
     */
    'httpbl'?: WafConfigHttpbl;
    /**
     * 
     * @type {WafConfigBlockLists}
     * @memberof WafConfig
     */
    'block_lists'?: WafConfigBlockLists;
    /**
     * Rate limiting thresholds
     * @type {Array<WafConfigThresholdsInner>}
     * @memberof WafConfig
     */
    'thresholds'?: Array<WafConfigThresholdsInner>;
}

export const WafConfigModeEnum = {
    Report: 'report',
    Block: 'block'
} as const;

export type WafConfigModeEnum = typeof WafConfigModeEnum[keyof typeof WafConfigModeEnum];

/**
 * Enable predefined block lists
 * @export
 * @interface WafConfigBlockLists
 */
export interface WafConfigBlockLists {
    /**
     * Block known bad user agents
     * @type {boolean}
     * @memberof WafConfigBlockLists
     */
    'user_agent'?: boolean;
    /**
     * Block known bad referers
     * @type {boolean}
     * @memberof WafConfigBlockLists
     */
    'referer'?: boolean;
    /**
     * Block known bad IPs
     * @type {boolean}
     * @memberof WafConfigBlockLists
     */
    'ip'?: boolean;
    /**
     * Block AI crawlers
     * @type {boolean}
     * @memberof WafConfigBlockLists
     */
    'ai'?: boolean;
}
/**
 * Project Honey Pot HTTP:BL configuration
 * @export
 * @interface WafConfigHttpbl
 */
export interface WafConfigHttpbl {
    /**
     * Enable HTTP:BL
     * @type {boolean}
     * @memberof WafConfigHttpbl
     */
    'httpbl_enabled'?: boolean;
    /**
     * Block suspicious IPs
     * @type {boolean}
     * @memberof WafConfigHttpbl
     */
    'block_suspicious'?: boolean;
    /**
     * Block email harvesters
     * @type {boolean}
     * @memberof WafConfigHttpbl
     */
    'block_harvester'?: boolean;
    /**
     * Block spam sources
     * @type {boolean}
     * @memberof WafConfigHttpbl
     */
    'block_spam'?: boolean;
    /**
     * Block search engines
     * @type {boolean}
     * @memberof WafConfigHttpbl
     */
    'block_search_engine'?: boolean;
    /**
     * HTTP:BL API key
     * @type {string}
     * @memberof WafConfigHttpbl
     */
    'httpbl_key'?: string;
}
/**
 * 
 * @export
 * @interface WafConfigThresholdsInner
 */
export interface WafConfigThresholdsInner {
    /**
     * Threshold type
     * @type {string}
     * @memberof WafConfigThresholdsInner
     */
    'type'?: WafConfigThresholdsInnerTypeEnum;
    /**
     * Requests per second limit (for ip/header)
     * @type {number}
     * @memberof WafConfigThresholdsInner
     */
    'rps'?: number;
    /**
     * Hit count limit (for waf_hit_by_ip)
     * @type {number}
     * @memberof WafConfigThresholdsInner
     */
    'hits'?: number;
    /**
     * Time window in minutes (for waf_hit_by_ip)
     * @type {number}
     * @memberof WafConfigThresholdsInner
     */
    'minutes'?: number;
    /**
     * Cooldown period in seconds
     * @type {number}
     * @memberof WafConfigThresholdsInner
     */
    'cooldown'?: number;
    /**
     * Threshold enforcement mode
     * @type {string}
     * @memberof WafConfigThresholdsInner
     */
    'mode'?: WafConfigThresholdsInnerModeEnum;
    /**
     * Header name (for header type)
     * @type {string}
     * @memberof WafConfigThresholdsInner
     */
    'value'?: string | null;
    /**
     * Slack webhook for this threshold
     * @type {string}
     * @memberof WafConfigThresholdsInner
     */
    'notify_slack'?: string | null;
}

export const WafConfigThresholdsInnerTypeEnum = {
    Ip: 'ip',
    Header: 'header',
    WafHitByIp: 'waf_hit_by_ip'
} as const;

export type WafConfigThresholdsInnerTypeEnum = typeof WafConfigThresholdsInnerTypeEnum[keyof typeof WafConfigThresholdsInnerTypeEnum];
export const WafConfigThresholdsInnerModeEnum = {
    Disabled: 'disabled',
    Report: 'report',
    Block: 'block'
} as const;

export type WafConfigThresholdsInnerModeEnum = typeof WafConfigThresholdsInnerModeEnum[keyof typeof WafConfigThresholdsInnerModeEnum];


/**
 * AIServicesApi - axios parameter creator
 * @export
 */
export const AIServicesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Sends requests to the AI API Gateway endpoint which buffers responses. Supports text, images, videos, and documents via base64 encoding.      *      * **Multimodal Support:**      * - **Text**: Simple string content      * - **Images**: Base64-encoded PNG, JPEG, GIF, WebP (up to 25MB)      * - **Videos**: Base64-encoded MP4, MOV, WebM, etc. (up to 25MB)      * - **Documents**: Base64-encoded PDF, DOCX, CSV, etc. (up to 25MB)      *      * **Supported Models:**      * - Amazon Nova Lite, Micro, Pro (all support multimodal)      * - Claude models (text only)      *      * **Usage Tips:**      * - Use base64 encoding for images/videos < 5-10MB      * - Place media before text prompts for best results      * - Label multiple media files (e.g., \'Image 1:\', \'Image 2:\')      * - Maximum 25MB total payload size      *      * **Response Patterns:**      * - **Text-only**: Returns simple text response when no tools requested      * - **Single tool**: Returns `toolUse` object when AI requests one tool      * - **Multiple tools**: Returns `toolUse` array when AI requests multiple tools      * - **Auto-execute sync**: Automatically executes tool and returns final text response      * - **Auto-execute async**: Returns toolUse with `executionId` and `status` for polling
         * @summary Chat inference via API Gateway (buffered responses) with multimodal support
         * @param {string} organisation The organisation ID
         * @param {ChatInferenceRequest} chatInferenceRequest Chat request with optional multimodal content blocks
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        chatInference: async (organisation: string, chatInferenceRequest: ChatInferenceRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organisation' is not null or undefined
            assertParamExists('chatInference', 'organisation', organisation)
            // verify required parameter 'chatInferenceRequest' is not null or undefined
            assertParamExists('chatInference', 'chatInferenceRequest', chatInferenceRequest)
            const localVarPath = `/api/v3/organizations/{organisation}/ai/chat`
                .replace(`{${"organisation"}}`, encodeURIComponent(String(organisation)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(chatInferenceRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Streams responses from the AI streaming subdomain using Server-Sent Events (SSE). Tokens are streamed in real-time as they are generated.      *      * **Multimodal Support:**      * - **Text**: Simple string content      * - **Images**: Base64-encoded PNG, JPEG, GIF, WebP (up to 25MB)      * - **Videos**: Base64-encoded MP4, MOV, WebM, etc. (up to 25MB)      * - **Documents**: Base64-encoded PDF, DOCX, CSV, etc. (up to 25MB)      *      * **Supported Models:**      * - Amazon Nova Lite, Micro, Pro (all support multimodal)      * - Claude models (text only)      *      * **Usage Tips:**      * - Use base64 encoding for images/videos < 5-10MB      * - Place media before text prompts for best results      * - Label multiple media files (e.g., \'Image 1:\', \'Image 2:\')      * - Maximum 25MB total payload size      * - Streaming works with all content types (text, image, video, document)
         * @summary Chat inference via streaming endpoint (true HTTP streaming) with multimodal support
         * @param {string} organisation The organisation ID
         * @param {ChatInferenceStreamRequest} chatInferenceStreamRequest Chat request with optional multimodal content blocks
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        chatInferenceStream: async (organisation: string, chatInferenceStreamRequest: ChatInferenceStreamRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organisation' is not null or undefined
            assertParamExists('chatInferenceStream', 'organisation', organisation)
            // verify required parameter 'chatInferenceStreamRequest' is not null or undefined
            assertParamExists('chatInferenceStream', 'chatInferenceStreamRequest', chatInferenceStreamRequest)
            const localVarPath = `/api/v3/organizations/{organisation}/ai/chat/stream`
                .replace(`{${"organisation"}}`, encodeURIComponent(String(organisation)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(chatInferenceStreamRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates an AI session with automatic expiration (60 min default, 24h max). Sessions are isolated by organization. Use userId to identify the user creating the session. Use sessionGroup for logical grouping. Use metadata for additional custom data. Filter sessions by userId or sessionGroup when listing.
         * @summary Create a new chat session with multi-tenant isolation
         * @param {string} organisation The organisation ID
         * @param {CreateAISessionRequest} createAISessionRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAISession: async (organisation: string, createAISessionRequest: CreateAISessionRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organisation' is not null or undefined
            assertParamExists('createAISession', 'organisation', organisation)
            // verify required parameter 'createAISessionRequest' is not null or undefined
            assertParamExists('createAISession', 'createAISessionRequest', createAISessionRequest)
            const localVarPath = `/api/v3/organizations/{organisation}/ai/sessions`
                .replace(`{${"organisation"}}`, encodeURIComponent(String(organisation)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createAISessionRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a chat session
         * @param {string} organisation The organisation ID
         * @param {string} sessionId The session ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAISession: async (organisation: string, sessionId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organisation' is not null or undefined
            assertParamExists('deleteAISession', 'organisation', organisation)
            // verify required parameter 'sessionId' is not null or undefined
            assertParamExists('deleteAISession', 'sessionId', sessionId)
            const localVarPath = `/api/v3/organizations/{organisation}/ai/sessions/{sessionId}`
                .replace(`{${"organisation"}}`, encodeURIComponent(String(organisation)))
                .replace(`{${"sessionId"}}`, encodeURIComponent(String(sessionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Generates vector embeddings for text content using embedding models. Used for semantic search, document similarity, and RAG applications.      *      * **Features:**      * - Single text or batch processing (up to 100 texts)      * - Configurable dimensions (256, 512, 1024, 8192 for Titan v2)      * - Optional normalization to unit length      * - Usage tracking for billing      *      * **Use Cases:**      * - Semantic search across documents      * - Similarity matching for content recommendations      * - RAG (Retrieval-Augmented Generation) pipelines      * - Clustering and classification      *      * **Available Embedding Models:**      * - amazon.titan-embed-text-v2:0 (default, supports 256-8192 dimensions)      * - amazon.titan-embed-text-v1:0 (1536 dimensions fixed)
         * @summary Generate text embeddings for semantic search and RAG applications
         * @param {string} organisation The organisation ID
         * @param {EmbeddingsRequest} embeddingsRequest Embedding request with single or multiple texts
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        embeddings: async (organisation: string, embeddingsRequest: EmbeddingsRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organisation' is not null or undefined
            assertParamExists('embeddings', 'organisation', organisation)
            // verify required parameter 'embeddingsRequest' is not null or undefined
            assertParamExists('embeddings', 'embeddingsRequest', embeddingsRequest)
            const localVarPath = `/api/v3/organizations/{organisation}/ai/embeddings`
                .replace(`{${"organisation"}}`, encodeURIComponent(String(organisation)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(embeddingsRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get AI configuration for an organization
         * @param {string} organisation The organisation ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAIConfig: async (organisation: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organisation' is not null or undefined
            assertParamExists('getAIConfig', 'organisation', organisation)
            const localVarPath = `/api/v3/organizations/{organisation}/ai/config`
                .replace(`{${"organisation"}}`, encodeURIComponent(String(organisation)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a specific chat session
         * @param {string} organisation The organisation ID
         * @param {string} sessionId The session ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAISession: async (organisation: string, sessionId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organisation' is not null or undefined
            assertParamExists('getAISession', 'organisation', organisation)
            // verify required parameter 'sessionId' is not null or undefined
            assertParamExists('getAISession', 'sessionId', sessionId)
            const localVarPath = `/api/v3/organizations/{organisation}/ai/sessions/{sessionId}`
                .replace(`{${"organisation"}}`, encodeURIComponent(String(organisation)))
                .replace(`{${"sessionId"}}`, encodeURIComponent(String(sessionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get AI usage statistics
         * @param {string} organisation The organisation ID
         * @param {string} [month] Month to retrieve statistics for (YYYY-MM format)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAIUsageStats: async (organisation: string, month?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organisation' is not null or undefined
            assertParamExists('getAIUsageStats', 'organisation', organisation)
            const localVarPath = `/api/v3/organizations/{organisation}/ai/usage`
                .replace(`{${"organisation"}}`, encodeURIComponent(String(organisation)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (month !== undefined) {
                localVarQueryParameter['month'] = month;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves the status and result of an async tool execution. Used for polling long-running tools like image generation.      *      * **Async Tool Execution Pattern:**      * This endpoint enables a polling pattern for long-running tools that would otherwise hit API Gateway\'s 30-second timeout.      *      * **Flow:**      * 1. AI requests tool use (e.g., `generate_image`)      * 2. Chat API returns `toolUse` with execution tracking info      * 3. Client starts polling this endpoint with the `executionId`      * 4. When `status === \'complete\'`, retrieve `result` and send back to AI      * 5. AI incorporates result into final response      *      * **Status Values:**      * - `pending`: Tool execution queued, not yet started      * - `running`: Tool is currently executing      * - `complete`: Tool execution finished successfully, `result` available      * - `failed`: Tool execution failed, `error` available      *      * **Polling Recommendations:**      * - Poll every 2-3 seconds for image generation      * - Exponential backoff for other tools (start 1s, max 5s)      * - Stop polling after 5 minutes (consider failed)      * - Auto-cleanup after 24 hours (TTL)      *      * **Use Cases:**      * - Image generation (10-15s typical runtime)      * - Video processing      * - Large file uploads/downloads      * - Complex database queries      * - External API calls with high latency
         * @summary Get async tool execution status and result
         * @param {string} organisation The organisation ID
         * @param {string} executionId Tool execution identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getToolExecutionStatus: async (organisation: string, executionId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organisation' is not null or undefined
            assertParamExists('getToolExecutionStatus', 'organisation', organisation)
            // verify required parameter 'executionId' is not null or undefined
            assertParamExists('getToolExecutionStatus', 'executionId', executionId)
            const localVarPath = `/api/v3/organizations/{organisation}/ai/tools/executions/{executionId}`
                .replace(`{${"organisation"}}`, encodeURIComponent(String(organisation)))
                .replace(`{${"executionId"}}`, encodeURIComponent(String(executionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Generates images using Amazon Nova Canvas image generation model.      *      * **Region Restriction:** Nova Canvas is ONLY available in:      * - `us-east-1` (US East, N. Virginia)      * - `ap-northeast-1` (Asia Pacific, Tokyo)      * - `eu-west-1` (Europe, Ireland)      *  NOT available in `ap-southeast-2` (Sydney)      *      * **Supported Task Types:**      * - **TEXT_IMAGE**: Basic text-to-image generation      * - **TEXT_IMAGE with Conditioning**: Layout-guided generation using edge detection or segmentation      * - **COLOR_GUIDED_GENERATION**: Generate images with specific color palettes      * - **IMAGE_VARIATION**: Create variations of existing images      * - **INPAINTING**: Fill masked areas in images      * - **OUTPAINTING**: Extend images beyond their borders      * - **BACKGROUND_REMOVAL**: Remove backgrounds from images      * - **VIRTUAL_TRY_ON**: Try on garments/objects on people      *      * **Quality Options:**      * - **standard**: Faster generation, lower cost      * - **premium**: Higher quality, slower generation      *      * **Timeout:** Image generation can take up to 5 minutes
         * @summary Generate images with Amazon Nova Canvas
         * @param {string} organisation The organisation ID
         * @param {ImageGenerationRequest} imageGenerationRequest Image generation request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        imageGeneration: async (organisation: string, imageGenerationRequest: ImageGenerationRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organisation' is not null or undefined
            assertParamExists('imageGeneration', 'organisation', organisation)
            // verify required parameter 'imageGenerationRequest' is not null or undefined
            assertParamExists('imageGeneration', 'imageGenerationRequest', imageGenerationRequest)
            const localVarPath = `/api/v3/organizations/{organisation}/ai/image-generation`
                .replace(`{${"organisation"}}`, encodeURIComponent(String(organisation)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(imageGenerationRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List available AI models for an organization
         * @param {string} organisation The organisation ID
         * @param {ListAIModelsFeatureEnum} [feature] Filter models by supported feature
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAIModels: async (organisation: string, feature?: ListAIModelsFeatureEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organisation' is not null or undefined
            assertParamExists('listAIModels', 'organisation', organisation)
            const localVarPath = `/api/v3/organizations/{organisation}/ai/models`
                .replace(`{${"organisation"}}`, encodeURIComponent(String(organisation)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (feature !== undefined) {
                localVarQueryParameter['feature'] = feature;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Lists active sessions for an organization with flexible filtering options.      *      * **Query Combinations:**      * 1. By Organization (default): Returns all sessions in the organization      * 2. By Organization + Group: `?sessionGroup=drupal-prod` - Sessions in a specific group      * 3. By User: `?userId=user-123` - All sessions for a user      * 4. By User + Group: `?userId=user-123&sessionGroup=drupal-prod` - User\'s sessions in a specific group      *      * **Use Cases:**      * - List user\'s conversations in a specific app/environment      * - Admin view of all sessions in a customer/tenant group      * - User profile showing all AI conversations across apps
         * @summary List chat sessions with multi-tenant filtering
         * @param {string} organisation The organisation ID
         * @param {string} [userId] Filter sessions by user ID
         * @param {string} [sessionGroup] Filter by session group. Returns only sessions matching the specified group.
         * @param {number} [limit] Maximum number of sessions to return (default 50, max 100)
         * @param {number} [offset] Offset for pagination
         * @param {string} [model] Filter by model ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAISessions: async (organisation: string, userId?: string, sessionGroup?: string, limit?: number, offset?: number, model?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organisation' is not null or undefined
            assertParamExists('listAISessions', 'organisation', organisation)
            const localVarPath = `/api/v3/organizations/{organisation}/ai/sessions`
                .replace(`{${"organisation"}}`, encodeURIComponent(String(organisation)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }

            if (sessionGroup !== undefined) {
                localVarQueryParameter['sessionGroup'] = sessionGroup;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (model !== undefined) {
                localVarQueryParameter['model'] = model;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves just the names of available built-in tools. Useful for quick validation or UI dropdown population without the full tool specifications.
         * @summary List tool names only (lightweight response)
         * @param {string} organisation The organisation ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAIToolNames: async (organisation: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organisation' is not null or undefined
            assertParamExists('listAIToolNames', 'organisation', organisation)
            const localVarPath = `/api/v3/organizations/{organisation}/ai/tools/names`
                .replace(`{${"organisation"}}`, encodeURIComponent(String(organisation)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves all available built-in tools that can be used with function calling. These tools can be included in `toolConfig` when making AI inference requests.      *      * **Available Built-in Tools:**      * - `get_weather`: Get current weather for a location using Open-Meteo API      * - `calculate`: Perform basic mathematical calculations (add, subtract, multiply, divide)      * - `search_web`: Search the web for information (mock implementation)      * - `generate_image`: Generate images with Amazon Nova Canvas (async execution, 10-15s typical runtime)      *      * **Use Cases:**      * - Discover available tools dynamically without hardcoding      * - Get complete tool specifications including input schemas      * - Build UI for tool selection      * - Validate tool names before sending requests      *      * **Dynamic Tool Discovery:**      * This endpoint enables clients to:      * 1. Fetch all available tools on page load      * 2. Display tool capabilities to users      * 3. Filter tools based on user permissions      * 4. Use `allowedTools` whitelist for security      *      * **Alternative Endpoint:**      * - `GET /ai/tools/names` - Returns only tool names (faster, lighter response)
         * @summary List available built-in tools for function calling
         * @param {string} organisation The organisation ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAITools: async (organisation: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organisation' is not null or undefined
            assertParamExists('listAITools', 'organisation', organisation)
            const localVarPath = `/api/v3/organizations/{organisation}/ai/tools`
                .replace(`{${"organisation"}}`, encodeURIComponent(String(organisation)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Lists recent async tool executions for an organization. Useful for debugging, monitoring, and building admin UIs.      *      * **Query Patterns:**      * - All recent executions: `GET /ai/tools/executions`      * - Filter by status: `GET /ai/tools/executions?status=running`      * - Limit results: `GET /ai/tools/executions?limit=20`      *      * **Results:**      * - Ordered by creation time (newest first)      * - Limited to 50 by default (configurable via `limit` parameter)      * - Only shows executions not yet expired (24h TTL)      *      * **Use Cases:**      * - Monitor all active tool executions      * - Debug failed executions      * - Build admin dashboards      * - Track tool usage patterns      * - Audit async operations
         * @summary List tool executions for monitoring and debugging
         * @param {string} organisation The organisation ID
         * @param {ListToolExecutionsStatusEnum} [status] Filter by execution status
         * @param {number} [limit] Maximum number of executions to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listToolExecutions: async (organisation: string, status?: ListToolExecutionsStatusEnum, limit?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organisation' is not null or undefined
            assertParamExists('listToolExecutions', 'organisation', organisation)
            const localVarPath = `/api/v3/organizations/{organisation}/ai/tools/executions`
                .replace(`{${"organisation"}}`, encodeURIComponent(String(organisation)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update AI configuration for an organization
         * @param {string} organisation The organisation ID
         * @param {UpdateAIConfigRequest} updateAIConfigRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAIConfig: async (organisation: string, updateAIConfigRequest: UpdateAIConfigRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organisation' is not null or undefined
            assertParamExists('updateAIConfig', 'organisation', organisation)
            // verify required parameter 'updateAIConfigRequest' is not null or undefined
            assertParamExists('updateAIConfig', 'updateAIConfigRequest', updateAIConfigRequest)
            const localVarPath = `/api/v3/organizations/{organisation}/ai/config`
                .replace(`{${"organisation"}}`, encodeURIComponent(String(organisation)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateAIConfigRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AIServicesApi - functional programming interface
 * @export
 */
export const AIServicesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AIServicesApiAxiosParamCreator(configuration)
    return {
        /**
         * Sends requests to the AI API Gateway endpoint which buffers responses. Supports text, images, videos, and documents via base64 encoding.      *      * **Multimodal Support:**      * - **Text**: Simple string content      * - **Images**: Base64-encoded PNG, JPEG, GIF, WebP (up to 25MB)      * - **Videos**: Base64-encoded MP4, MOV, WebM, etc. (up to 25MB)      * - **Documents**: Base64-encoded PDF, DOCX, CSV, etc. (up to 25MB)      *      * **Supported Models:**      * - Amazon Nova Lite, Micro, Pro (all support multimodal)      * - Claude models (text only)      *      * **Usage Tips:**      * - Use base64 encoding for images/videos < 5-10MB      * - Place media before text prompts for best results      * - Label multiple media files (e.g., \'Image 1:\', \'Image 2:\')      * - Maximum 25MB total payload size      *      * **Response Patterns:**      * - **Text-only**: Returns simple text response when no tools requested      * - **Single tool**: Returns `toolUse` object when AI requests one tool      * - **Multiple tools**: Returns `toolUse` array when AI requests multiple tools      * - **Auto-execute sync**: Automatically executes tool and returns final text response      * - **Auto-execute async**: Returns toolUse with `executionId` and `status` for polling
         * @summary Chat inference via API Gateway (buffered responses) with multimodal support
         * @param {string} organisation The organisation ID
         * @param {ChatInferenceRequest} chatInferenceRequest Chat request with optional multimodal content blocks
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async chatInference(organisation: string, chatInferenceRequest: ChatInferenceRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ChatInference200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.chatInference(organisation, chatInferenceRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AIServicesApi.chatInference']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Streams responses from the AI streaming subdomain using Server-Sent Events (SSE). Tokens are streamed in real-time as they are generated.      *      * **Multimodal Support:**      * - **Text**: Simple string content      * - **Images**: Base64-encoded PNG, JPEG, GIF, WebP (up to 25MB)      * - **Videos**: Base64-encoded MP4, MOV, WebM, etc. (up to 25MB)      * - **Documents**: Base64-encoded PDF, DOCX, CSV, etc. (up to 25MB)      *      * **Supported Models:**      * - Amazon Nova Lite, Micro, Pro (all support multimodal)      * - Claude models (text only)      *      * **Usage Tips:**      * - Use base64 encoding for images/videos < 5-10MB      * - Place media before text prompts for best results      * - Label multiple media files (e.g., \'Image 1:\', \'Image 2:\')      * - Maximum 25MB total payload size      * - Streaming works with all content types (text, image, video, document)
         * @summary Chat inference via streaming endpoint (true HTTP streaming) with multimodal support
         * @param {string} organisation The organisation ID
         * @param {ChatInferenceStreamRequest} chatInferenceStreamRequest Chat request with optional multimodal content blocks
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async chatInferenceStream(organisation: string, chatInferenceStreamRequest: ChatInferenceStreamRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.chatInferenceStream(organisation, chatInferenceStreamRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AIServicesApi.chatInferenceStream']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Creates an AI session with automatic expiration (60 min default, 24h max). Sessions are isolated by organization. Use userId to identify the user creating the session. Use sessionGroup for logical grouping. Use metadata for additional custom data. Filter sessions by userId or sessionGroup when listing.
         * @summary Create a new chat session with multi-tenant isolation
         * @param {string} organisation The organisation ID
         * @param {CreateAISessionRequest} createAISessionRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createAISession(organisation: string, createAISessionRequest: CreateAISessionRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateAISession201Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createAISession(organisation, createAISessionRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AIServicesApi.createAISession']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete a chat session
         * @param {string} organisation The organisation ID
         * @param {string} sessionId The session ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteAISession(organisation: string, sessionId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeleteAISession200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteAISession(organisation, sessionId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AIServicesApi.deleteAISession']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Generates vector embeddings for text content using embedding models. Used for semantic search, document similarity, and RAG applications.      *      * **Features:**      * - Single text or batch processing (up to 100 texts)      * - Configurable dimensions (256, 512, 1024, 8192 for Titan v2)      * - Optional normalization to unit length      * - Usage tracking for billing      *      * **Use Cases:**      * - Semantic search across documents      * - Similarity matching for content recommendations      * - RAG (Retrieval-Augmented Generation) pipelines      * - Clustering and classification      *      * **Available Embedding Models:**      * - amazon.titan-embed-text-v2:0 (default, supports 256-8192 dimensions)      * - amazon.titan-embed-text-v1:0 (1536 dimensions fixed)
         * @summary Generate text embeddings for semantic search and RAG applications
         * @param {string} organisation The organisation ID
         * @param {EmbeddingsRequest} embeddingsRequest Embedding request with single or multiple texts
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async embeddings(organisation: string, embeddingsRequest: EmbeddingsRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Embeddings200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.embeddings(organisation, embeddingsRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AIServicesApi.embeddings']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get AI configuration for an organization
         * @param {string} organisation The organisation ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAIConfig(organisation: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetAIConfig200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAIConfig(organisation, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AIServicesApi.getAIConfig']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get a specific chat session
         * @param {string} organisation The organisation ID
         * @param {string} sessionId The session ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAISession(organisation: string, sessionId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetAISession200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAISession(organisation, sessionId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AIServicesApi.getAISession']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get AI usage statistics
         * @param {string} organisation The organisation ID
         * @param {string} [month] Month to retrieve statistics for (YYYY-MM format)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAIUsageStats(organisation: string, month?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetAIUsageStats200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAIUsageStats(organisation, month, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AIServicesApi.getAIUsageStats']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieves the status and result of an async tool execution. Used for polling long-running tools like image generation.      *      * **Async Tool Execution Pattern:**      * This endpoint enables a polling pattern for long-running tools that would otherwise hit API Gateway\'s 30-second timeout.      *      * **Flow:**      * 1. AI requests tool use (e.g., `generate_image`)      * 2. Chat API returns `toolUse` with execution tracking info      * 3. Client starts polling this endpoint with the `executionId`      * 4. When `status === \'complete\'`, retrieve `result` and send back to AI      * 5. AI incorporates result into final response      *      * **Status Values:**      * - `pending`: Tool execution queued, not yet started      * - `running`: Tool is currently executing      * - `complete`: Tool execution finished successfully, `result` available      * - `failed`: Tool execution failed, `error` available      *      * **Polling Recommendations:**      * - Poll every 2-3 seconds for image generation      * - Exponential backoff for other tools (start 1s, max 5s)      * - Stop polling after 5 minutes (consider failed)      * - Auto-cleanup after 24 hours (TTL)      *      * **Use Cases:**      * - Image generation (10-15s typical runtime)      * - Video processing      * - Large file uploads/downloads      * - Complex database queries      * - External API calls with high latency
         * @summary Get async tool execution status and result
         * @param {string} organisation The organisation ID
         * @param {string} executionId Tool execution identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getToolExecutionStatus(organisation: string, executionId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetToolExecutionStatus200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getToolExecutionStatus(organisation, executionId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AIServicesApi.getToolExecutionStatus']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Generates images using Amazon Nova Canvas image generation model.      *      * **Region Restriction:** Nova Canvas is ONLY available in:      * - `us-east-1` (US East, N. Virginia)      * - `ap-northeast-1` (Asia Pacific, Tokyo)      * - `eu-west-1` (Europe, Ireland)      *  NOT available in `ap-southeast-2` (Sydney)      *      * **Supported Task Types:**      * - **TEXT_IMAGE**: Basic text-to-image generation      * - **TEXT_IMAGE with Conditioning**: Layout-guided generation using edge detection or segmentation      * - **COLOR_GUIDED_GENERATION**: Generate images with specific color palettes      * - **IMAGE_VARIATION**: Create variations of existing images      * - **INPAINTING**: Fill masked areas in images      * - **OUTPAINTING**: Extend images beyond their borders      * - **BACKGROUND_REMOVAL**: Remove backgrounds from images      * - **VIRTUAL_TRY_ON**: Try on garments/objects on people      *      * **Quality Options:**      * - **standard**: Faster generation, lower cost      * - **premium**: Higher quality, slower generation      *      * **Timeout:** Image generation can take up to 5 minutes
         * @summary Generate images with Amazon Nova Canvas
         * @param {string} organisation The organisation ID
         * @param {ImageGenerationRequest} imageGenerationRequest Image generation request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async imageGeneration(organisation: string, imageGenerationRequest: ImageGenerationRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ImageGeneration200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.imageGeneration(organisation, imageGenerationRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AIServicesApi.imageGeneration']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary List available AI models for an organization
         * @param {string} organisation The organisation ID
         * @param {ListAIModelsFeatureEnum} [feature] Filter models by supported feature
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listAIModels(organisation: string, feature?: ListAIModelsFeatureEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListAIModels200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listAIModels(organisation, feature, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AIServicesApi.listAIModels']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Lists active sessions for an organization with flexible filtering options.      *      * **Query Combinations:**      * 1. By Organization (default): Returns all sessions in the organization      * 2. By Organization + Group: `?sessionGroup=drupal-prod` - Sessions in a specific group      * 3. By User: `?userId=user-123` - All sessions for a user      * 4. By User + Group: `?userId=user-123&sessionGroup=drupal-prod` - User\'s sessions in a specific group      *      * **Use Cases:**      * - List user\'s conversations in a specific app/environment      * - Admin view of all sessions in a customer/tenant group      * - User profile showing all AI conversations across apps
         * @summary List chat sessions with multi-tenant filtering
         * @param {string} organisation The organisation ID
         * @param {string} [userId] Filter sessions by user ID
         * @param {string} [sessionGroup] Filter by session group. Returns only sessions matching the specified group.
         * @param {number} [limit] Maximum number of sessions to return (default 50, max 100)
         * @param {number} [offset] Offset for pagination
         * @param {string} [model] Filter by model ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listAISessions(organisation: string, userId?: string, sessionGroup?: string, limit?: number, offset?: number, model?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ListAISessions200ResponseInner>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listAISessions(organisation, userId, sessionGroup, limit, offset, model, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AIServicesApi.listAISessions']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieves just the names of available built-in tools. Useful for quick validation or UI dropdown population without the full tool specifications.
         * @summary List tool names only (lightweight response)
         * @param {string} organisation The organisation ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listAIToolNames(organisation: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListAIToolNames200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listAIToolNames(organisation, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AIServicesApi.listAIToolNames']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieves all available built-in tools that can be used with function calling. These tools can be included in `toolConfig` when making AI inference requests.      *      * **Available Built-in Tools:**      * - `get_weather`: Get current weather for a location using Open-Meteo API      * - `calculate`: Perform basic mathematical calculations (add, subtract, multiply, divide)      * - `search_web`: Search the web for information (mock implementation)      * - `generate_image`: Generate images with Amazon Nova Canvas (async execution, 10-15s typical runtime)      *      * **Use Cases:**      * - Discover available tools dynamically without hardcoding      * - Get complete tool specifications including input schemas      * - Build UI for tool selection      * - Validate tool names before sending requests      *      * **Dynamic Tool Discovery:**      * This endpoint enables clients to:      * 1. Fetch all available tools on page load      * 2. Display tool capabilities to users      * 3. Filter tools based on user permissions      * 4. Use `allowedTools` whitelist for security      *      * **Alternative Endpoint:**      * - `GET /ai/tools/names` - Returns only tool names (faster, lighter response)
         * @summary List available built-in tools for function calling
         * @param {string} organisation The organisation ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listAITools(organisation: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListAITools200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listAITools(organisation, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AIServicesApi.listAITools']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Lists recent async tool executions for an organization. Useful for debugging, monitoring, and building admin UIs.      *      * **Query Patterns:**      * - All recent executions: `GET /ai/tools/executions`      * - Filter by status: `GET /ai/tools/executions?status=running`      * - Limit results: `GET /ai/tools/executions?limit=20`      *      * **Results:**      * - Ordered by creation time (newest first)      * - Limited to 50 by default (configurable via `limit` parameter)      * - Only shows executions not yet expired (24h TTL)      *      * **Use Cases:**      * - Monitor all active tool executions      * - Debug failed executions      * - Build admin dashboards      * - Track tool usage patterns      * - Audit async operations
         * @summary List tool executions for monitoring and debugging
         * @param {string} organisation The organisation ID
         * @param {ListToolExecutionsStatusEnum} [status] Filter by execution status
         * @param {number} [limit] Maximum number of executions to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listToolExecutions(organisation: string, status?: ListToolExecutionsStatusEnum, limit?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListToolExecutions200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listToolExecutions(organisation, status, limit, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AIServicesApi.listToolExecutions']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update AI configuration for an organization
         * @param {string} organisation The organisation ID
         * @param {UpdateAIConfigRequest} updateAIConfigRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateAIConfig(organisation: string, updateAIConfigRequest: UpdateAIConfigRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateAIConfig(organisation, updateAIConfigRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AIServicesApi.updateAIConfig']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * AIServicesApi - factory interface
 * @export
 */
export const AIServicesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AIServicesApiFp(configuration)
    return {
        /**
         * Sends requests to the AI API Gateway endpoint which buffers responses. Supports text, images, videos, and documents via base64 encoding.      *      * **Multimodal Support:**      * - **Text**: Simple string content      * - **Images**: Base64-encoded PNG, JPEG, GIF, WebP (up to 25MB)      * - **Videos**: Base64-encoded MP4, MOV, WebM, etc. (up to 25MB)      * - **Documents**: Base64-encoded PDF, DOCX, CSV, etc. (up to 25MB)      *      * **Supported Models:**      * - Amazon Nova Lite, Micro, Pro (all support multimodal)      * - Claude models (text only)      *      * **Usage Tips:**      * - Use base64 encoding for images/videos < 5-10MB      * - Place media before text prompts for best results      * - Label multiple media files (e.g., \'Image 1:\', \'Image 2:\')      * - Maximum 25MB total payload size      *      * **Response Patterns:**      * - **Text-only**: Returns simple text response when no tools requested      * - **Single tool**: Returns `toolUse` object when AI requests one tool      * - **Multiple tools**: Returns `toolUse` array when AI requests multiple tools      * - **Auto-execute sync**: Automatically executes tool and returns final text response      * - **Auto-execute async**: Returns toolUse with `executionId` and `status` for polling
         * @summary Chat inference via API Gateway (buffered responses) with multimodal support
         * @param {string} organisation The organisation ID
         * @param {ChatInferenceRequest} chatInferenceRequest Chat request with optional multimodal content blocks
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        chatInference(organisation: string, chatInferenceRequest: ChatInferenceRequest, options?: RawAxiosRequestConfig): AxiosPromise<ChatInference200Response> {
            return localVarFp.chatInference(organisation, chatInferenceRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Streams responses from the AI streaming subdomain using Server-Sent Events (SSE). Tokens are streamed in real-time as they are generated.      *      * **Multimodal Support:**      * - **Text**: Simple string content      * - **Images**: Base64-encoded PNG, JPEG, GIF, WebP (up to 25MB)      * - **Videos**: Base64-encoded MP4, MOV, WebM, etc. (up to 25MB)      * - **Documents**: Base64-encoded PDF, DOCX, CSV, etc. (up to 25MB)      *      * **Supported Models:**      * - Amazon Nova Lite, Micro, Pro (all support multimodal)      * - Claude models (text only)      *      * **Usage Tips:**      * - Use base64 encoding for images/videos < 5-10MB      * - Place media before text prompts for best results      * - Label multiple media files (e.g., \'Image 1:\', \'Image 2:\')      * - Maximum 25MB total payload size      * - Streaming works with all content types (text, image, video, document)
         * @summary Chat inference via streaming endpoint (true HTTP streaming) with multimodal support
         * @param {string} organisation The organisation ID
         * @param {ChatInferenceStreamRequest} chatInferenceStreamRequest Chat request with optional multimodal content blocks
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        chatInferenceStream(organisation: string, chatInferenceStreamRequest: ChatInferenceStreamRequest, options?: RawAxiosRequestConfig): AxiosPromise<string> {
            return localVarFp.chatInferenceStream(organisation, chatInferenceStreamRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Creates an AI session with automatic expiration (60 min default, 24h max). Sessions are isolated by organization. Use userId to identify the user creating the session. Use sessionGroup for logical grouping. Use metadata for additional custom data. Filter sessions by userId or sessionGroup when listing.
         * @summary Create a new chat session with multi-tenant isolation
         * @param {string} organisation The organisation ID
         * @param {CreateAISessionRequest} createAISessionRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAISession(organisation: string, createAISessionRequest: CreateAISessionRequest, options?: RawAxiosRequestConfig): AxiosPromise<CreateAISession201Response> {
            return localVarFp.createAISession(organisation, createAISessionRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete a chat session
         * @param {string} organisation The organisation ID
         * @param {string} sessionId The session ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAISession(organisation: string, sessionId: string, options?: RawAxiosRequestConfig): AxiosPromise<DeleteAISession200Response> {
            return localVarFp.deleteAISession(organisation, sessionId, options).then((request) => request(axios, basePath));
        },
        /**
         * Generates vector embeddings for text content using embedding models. Used for semantic search, document similarity, and RAG applications.      *      * **Features:**      * - Single text or batch processing (up to 100 texts)      * - Configurable dimensions (256, 512, 1024, 8192 for Titan v2)      * - Optional normalization to unit length      * - Usage tracking for billing      *      * **Use Cases:**      * - Semantic search across documents      * - Similarity matching for content recommendations      * - RAG (Retrieval-Augmented Generation) pipelines      * - Clustering and classification      *      * **Available Embedding Models:**      * - amazon.titan-embed-text-v2:0 (default, supports 256-8192 dimensions)      * - amazon.titan-embed-text-v1:0 (1536 dimensions fixed)
         * @summary Generate text embeddings for semantic search and RAG applications
         * @param {string} organisation The organisation ID
         * @param {EmbeddingsRequest} embeddingsRequest Embedding request with single or multiple texts
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        embeddings(organisation: string, embeddingsRequest: EmbeddingsRequest, options?: RawAxiosRequestConfig): AxiosPromise<Embeddings200Response> {
            return localVarFp.embeddings(organisation, embeddingsRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get AI configuration for an organization
         * @param {string} organisation The organisation ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAIConfig(organisation: string, options?: RawAxiosRequestConfig): AxiosPromise<GetAIConfig200Response> {
            return localVarFp.getAIConfig(organisation, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a specific chat session
         * @param {string} organisation The organisation ID
         * @param {string} sessionId The session ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAISession(organisation: string, sessionId: string, options?: RawAxiosRequestConfig): AxiosPromise<GetAISession200Response> {
            return localVarFp.getAISession(organisation, sessionId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get AI usage statistics
         * @param {string} organisation The organisation ID
         * @param {string} [month] Month to retrieve statistics for (YYYY-MM format)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAIUsageStats(organisation: string, month?: string, options?: RawAxiosRequestConfig): AxiosPromise<GetAIUsageStats200Response> {
            return localVarFp.getAIUsageStats(organisation, month, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves the status and result of an async tool execution. Used for polling long-running tools like image generation.      *      * **Async Tool Execution Pattern:**      * This endpoint enables a polling pattern for long-running tools that would otherwise hit API Gateway\'s 30-second timeout.      *      * **Flow:**      * 1. AI requests tool use (e.g., `generate_image`)      * 2. Chat API returns `toolUse` with execution tracking info      * 3. Client starts polling this endpoint with the `executionId`      * 4. When `status === \'complete\'`, retrieve `result` and send back to AI      * 5. AI incorporates result into final response      *      * **Status Values:**      * - `pending`: Tool execution queued, not yet started      * - `running`: Tool is currently executing      * - `complete`: Tool execution finished successfully, `result` available      * - `failed`: Tool execution failed, `error` available      *      * **Polling Recommendations:**      * - Poll every 2-3 seconds for image generation      * - Exponential backoff for other tools (start 1s, max 5s)      * - Stop polling after 5 minutes (consider failed)      * - Auto-cleanup after 24 hours (TTL)      *      * **Use Cases:**      * - Image generation (10-15s typical runtime)      * - Video processing      * - Large file uploads/downloads      * - Complex database queries      * - External API calls with high latency
         * @summary Get async tool execution status and result
         * @param {string} organisation The organisation ID
         * @param {string} executionId Tool execution identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getToolExecutionStatus(organisation: string, executionId: string, options?: RawAxiosRequestConfig): AxiosPromise<GetToolExecutionStatus200Response> {
            return localVarFp.getToolExecutionStatus(organisation, executionId, options).then((request) => request(axios, basePath));
        },
        /**
         * Generates images using Amazon Nova Canvas image generation model.      *      * **Region Restriction:** Nova Canvas is ONLY available in:      * - `us-east-1` (US East, N. Virginia)      * - `ap-northeast-1` (Asia Pacific, Tokyo)      * - `eu-west-1` (Europe, Ireland)      *  NOT available in `ap-southeast-2` (Sydney)      *      * **Supported Task Types:**      * - **TEXT_IMAGE**: Basic text-to-image generation      * - **TEXT_IMAGE with Conditioning**: Layout-guided generation using edge detection or segmentation      * - **COLOR_GUIDED_GENERATION**: Generate images with specific color palettes      * - **IMAGE_VARIATION**: Create variations of existing images      * - **INPAINTING**: Fill masked areas in images      * - **OUTPAINTING**: Extend images beyond their borders      * - **BACKGROUND_REMOVAL**: Remove backgrounds from images      * - **VIRTUAL_TRY_ON**: Try on garments/objects on people      *      * **Quality Options:**      * - **standard**: Faster generation, lower cost      * - **premium**: Higher quality, slower generation      *      * **Timeout:** Image generation can take up to 5 minutes
         * @summary Generate images with Amazon Nova Canvas
         * @param {string} organisation The organisation ID
         * @param {ImageGenerationRequest} imageGenerationRequest Image generation request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        imageGeneration(organisation: string, imageGenerationRequest: ImageGenerationRequest, options?: RawAxiosRequestConfig): AxiosPromise<ImageGeneration200Response> {
            return localVarFp.imageGeneration(organisation, imageGenerationRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List available AI models for an organization
         * @param {string} organisation The organisation ID
         * @param {ListAIModelsFeatureEnum} [feature] Filter models by supported feature
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAIModels(organisation: string, feature?: ListAIModelsFeatureEnum, options?: RawAxiosRequestConfig): AxiosPromise<ListAIModels200Response> {
            return localVarFp.listAIModels(organisation, feature, options).then((request) => request(axios, basePath));
        },
        /**
         * Lists active sessions for an organization with flexible filtering options.      *      * **Query Combinations:**      * 1. By Organization (default): Returns all sessions in the organization      * 2. By Organization + Group: `?sessionGroup=drupal-prod` - Sessions in a specific group      * 3. By User: `?userId=user-123` - All sessions for a user      * 4. By User + Group: `?userId=user-123&sessionGroup=drupal-prod` - User\'s sessions in a specific group      *      * **Use Cases:**      * - List user\'s conversations in a specific app/environment      * - Admin view of all sessions in a customer/tenant group      * - User profile showing all AI conversations across apps
         * @summary List chat sessions with multi-tenant filtering
         * @param {string} organisation The organisation ID
         * @param {string} [userId] Filter sessions by user ID
         * @param {string} [sessionGroup] Filter by session group. Returns only sessions matching the specified group.
         * @param {number} [limit] Maximum number of sessions to return (default 50, max 100)
         * @param {number} [offset] Offset for pagination
         * @param {string} [model] Filter by model ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAISessions(organisation: string, userId?: string, sessionGroup?: string, limit?: number, offset?: number, model?: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<ListAISessions200ResponseInner>> {
            return localVarFp.listAISessions(organisation, userId, sessionGroup, limit, offset, model, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves just the names of available built-in tools. Useful for quick validation or UI dropdown population without the full tool specifications.
         * @summary List tool names only (lightweight response)
         * @param {string} organisation The organisation ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAIToolNames(organisation: string, options?: RawAxiosRequestConfig): AxiosPromise<ListAIToolNames200Response> {
            return localVarFp.listAIToolNames(organisation, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves all available built-in tools that can be used with function calling. These tools can be included in `toolConfig` when making AI inference requests.      *      * **Available Built-in Tools:**      * - `get_weather`: Get current weather for a location using Open-Meteo API      * - `calculate`: Perform basic mathematical calculations (add, subtract, multiply, divide)      * - `search_web`: Search the web for information (mock implementation)      * - `generate_image`: Generate images with Amazon Nova Canvas (async execution, 10-15s typical runtime)      *      * **Use Cases:**      * - Discover available tools dynamically without hardcoding      * - Get complete tool specifications including input schemas      * - Build UI for tool selection      * - Validate tool names before sending requests      *      * **Dynamic Tool Discovery:**      * This endpoint enables clients to:      * 1. Fetch all available tools on page load      * 2. Display tool capabilities to users      * 3. Filter tools based on user permissions      * 4. Use `allowedTools` whitelist for security      *      * **Alternative Endpoint:**      * - `GET /ai/tools/names` - Returns only tool names (faster, lighter response)
         * @summary List available built-in tools for function calling
         * @param {string} organisation The organisation ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAITools(organisation: string, options?: RawAxiosRequestConfig): AxiosPromise<ListAITools200Response> {
            return localVarFp.listAITools(organisation, options).then((request) => request(axios, basePath));
        },
        /**
         * Lists recent async tool executions for an organization. Useful for debugging, monitoring, and building admin UIs.      *      * **Query Patterns:**      * - All recent executions: `GET /ai/tools/executions`      * - Filter by status: `GET /ai/tools/executions?status=running`      * - Limit results: `GET /ai/tools/executions?limit=20`      *      * **Results:**      * - Ordered by creation time (newest first)      * - Limited to 50 by default (configurable via `limit` parameter)      * - Only shows executions not yet expired (24h TTL)      *      * **Use Cases:**      * - Monitor all active tool executions      * - Debug failed executions      * - Build admin dashboards      * - Track tool usage patterns      * - Audit async operations
         * @summary List tool executions for monitoring and debugging
         * @param {string} organisation The organisation ID
         * @param {ListToolExecutionsStatusEnum} [status] Filter by execution status
         * @param {number} [limit] Maximum number of executions to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listToolExecutions(organisation: string, status?: ListToolExecutionsStatusEnum, limit?: number, options?: RawAxiosRequestConfig): AxiosPromise<ListToolExecutions200Response> {
            return localVarFp.listToolExecutions(organisation, status, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update AI configuration for an organization
         * @param {string} organisation The organisation ID
         * @param {UpdateAIConfigRequest} updateAIConfigRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAIConfig(organisation: string, updateAIConfigRequest: UpdateAIConfigRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.updateAIConfig(organisation, updateAIConfigRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AIServicesApi - object-oriented interface
 * @export
 * @class AIServicesApi
 * @extends {BaseAPI}
 */
export class AIServicesApi extends BaseAPI {
    /**
     * Sends requests to the AI API Gateway endpoint which buffers responses. Supports text, images, videos, and documents via base64 encoding.      *      * **Multimodal Support:**      * - **Text**: Simple string content      * - **Images**: Base64-encoded PNG, JPEG, GIF, WebP (up to 25MB)      * - **Videos**: Base64-encoded MP4, MOV, WebM, etc. (up to 25MB)      * - **Documents**: Base64-encoded PDF, DOCX, CSV, etc. (up to 25MB)      *      * **Supported Models:**      * - Amazon Nova Lite, Micro, Pro (all support multimodal)      * - Claude models (text only)      *      * **Usage Tips:**      * - Use base64 encoding for images/videos < 5-10MB      * - Place media before text prompts for best results      * - Label multiple media files (e.g., \'Image 1:\', \'Image 2:\')      * - Maximum 25MB total payload size      *      * **Response Patterns:**      * - **Text-only**: Returns simple text response when no tools requested      * - **Single tool**: Returns `toolUse` object when AI requests one tool      * - **Multiple tools**: Returns `toolUse` array when AI requests multiple tools      * - **Auto-execute sync**: Automatically executes tool and returns final text response      * - **Auto-execute async**: Returns toolUse with `executionId` and `status` for polling
     * @summary Chat inference via API Gateway (buffered responses) with multimodal support
     * @param {string} organisation The organisation ID
     * @param {ChatInferenceRequest} chatInferenceRequest Chat request with optional multimodal content blocks
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AIServicesApi
     */
    public chatInference(organisation: string, chatInferenceRequest: ChatInferenceRequest, options?: RawAxiosRequestConfig) {
        return AIServicesApiFp(this.configuration).chatInference(organisation, chatInferenceRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Streams responses from the AI streaming subdomain using Server-Sent Events (SSE). Tokens are streamed in real-time as they are generated.      *      * **Multimodal Support:**      * - **Text**: Simple string content      * - **Images**: Base64-encoded PNG, JPEG, GIF, WebP (up to 25MB)      * - **Videos**: Base64-encoded MP4, MOV, WebM, etc. (up to 25MB)      * - **Documents**: Base64-encoded PDF, DOCX, CSV, etc. (up to 25MB)      *      * **Supported Models:**      * - Amazon Nova Lite, Micro, Pro (all support multimodal)      * - Claude models (text only)      *      * **Usage Tips:**      * - Use base64 encoding for images/videos < 5-10MB      * - Place media before text prompts for best results      * - Label multiple media files (e.g., \'Image 1:\', \'Image 2:\')      * - Maximum 25MB total payload size      * - Streaming works with all content types (text, image, video, document)
     * @summary Chat inference via streaming endpoint (true HTTP streaming) with multimodal support
     * @param {string} organisation The organisation ID
     * @param {ChatInferenceStreamRequest} chatInferenceStreamRequest Chat request with optional multimodal content blocks
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AIServicesApi
     */
    public chatInferenceStream(organisation: string, chatInferenceStreamRequest: ChatInferenceStreamRequest, options?: RawAxiosRequestConfig) {
        return AIServicesApiFp(this.configuration).chatInferenceStream(organisation, chatInferenceStreamRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Creates an AI session with automatic expiration (60 min default, 24h max). Sessions are isolated by organization. Use userId to identify the user creating the session. Use sessionGroup for logical grouping. Use metadata for additional custom data. Filter sessions by userId or sessionGroup when listing.
     * @summary Create a new chat session with multi-tenant isolation
     * @param {string} organisation The organisation ID
     * @param {CreateAISessionRequest} createAISessionRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AIServicesApi
     */
    public createAISession(organisation: string, createAISessionRequest: CreateAISessionRequest, options?: RawAxiosRequestConfig) {
        return AIServicesApiFp(this.configuration).createAISession(organisation, createAISessionRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete a chat session
     * @param {string} organisation The organisation ID
     * @param {string} sessionId The session ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AIServicesApi
     */
    public deleteAISession(organisation: string, sessionId: string, options?: RawAxiosRequestConfig) {
        return AIServicesApiFp(this.configuration).deleteAISession(organisation, sessionId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Generates vector embeddings for text content using embedding models. Used for semantic search, document similarity, and RAG applications.      *      * **Features:**      * - Single text or batch processing (up to 100 texts)      * - Configurable dimensions (256, 512, 1024, 8192 for Titan v2)      * - Optional normalization to unit length      * - Usage tracking for billing      *      * **Use Cases:**      * - Semantic search across documents      * - Similarity matching for content recommendations      * - RAG (Retrieval-Augmented Generation) pipelines      * - Clustering and classification      *      * **Available Embedding Models:**      * - amazon.titan-embed-text-v2:0 (default, supports 256-8192 dimensions)      * - amazon.titan-embed-text-v1:0 (1536 dimensions fixed)
     * @summary Generate text embeddings for semantic search and RAG applications
     * @param {string} organisation The organisation ID
     * @param {EmbeddingsRequest} embeddingsRequest Embedding request with single or multiple texts
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AIServicesApi
     */
    public embeddings(organisation: string, embeddingsRequest: EmbeddingsRequest, options?: RawAxiosRequestConfig) {
        return AIServicesApiFp(this.configuration).embeddings(organisation, embeddingsRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get AI configuration for an organization
     * @param {string} organisation The organisation ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AIServicesApi
     */
    public getAIConfig(organisation: string, options?: RawAxiosRequestConfig) {
        return AIServicesApiFp(this.configuration).getAIConfig(organisation, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a specific chat session
     * @param {string} organisation The organisation ID
     * @param {string} sessionId The session ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AIServicesApi
     */
    public getAISession(organisation: string, sessionId: string, options?: RawAxiosRequestConfig) {
        return AIServicesApiFp(this.configuration).getAISession(organisation, sessionId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get AI usage statistics
     * @param {string} organisation The organisation ID
     * @param {string} [month] Month to retrieve statistics for (YYYY-MM format)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AIServicesApi
     */
    public getAIUsageStats(organisation: string, month?: string, options?: RawAxiosRequestConfig) {
        return AIServicesApiFp(this.configuration).getAIUsageStats(organisation, month, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves the status and result of an async tool execution. Used for polling long-running tools like image generation.      *      * **Async Tool Execution Pattern:**      * This endpoint enables a polling pattern for long-running tools that would otherwise hit API Gateway\'s 30-second timeout.      *      * **Flow:**      * 1. AI requests tool use (e.g., `generate_image`)      * 2. Chat API returns `toolUse` with execution tracking info      * 3. Client starts polling this endpoint with the `executionId`      * 4. When `status === \'complete\'`, retrieve `result` and send back to AI      * 5. AI incorporates result into final response      *      * **Status Values:**      * - `pending`: Tool execution queued, not yet started      * - `running`: Tool is currently executing      * - `complete`: Tool execution finished successfully, `result` available      * - `failed`: Tool execution failed, `error` available      *      * **Polling Recommendations:**      * - Poll every 2-3 seconds for image generation      * - Exponential backoff for other tools (start 1s, max 5s)      * - Stop polling after 5 minutes (consider failed)      * - Auto-cleanup after 24 hours (TTL)      *      * **Use Cases:**      * - Image generation (10-15s typical runtime)      * - Video processing      * - Large file uploads/downloads      * - Complex database queries      * - External API calls with high latency
     * @summary Get async tool execution status and result
     * @param {string} organisation The organisation ID
     * @param {string} executionId Tool execution identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AIServicesApi
     */
    public getToolExecutionStatus(organisation: string, executionId: string, options?: RawAxiosRequestConfig) {
        return AIServicesApiFp(this.configuration).getToolExecutionStatus(organisation, executionId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Generates images using Amazon Nova Canvas image generation model.      *      * **Region Restriction:** Nova Canvas is ONLY available in:      * - `us-east-1` (US East, N. Virginia)      * - `ap-northeast-1` (Asia Pacific, Tokyo)      * - `eu-west-1` (Europe, Ireland)      *  NOT available in `ap-southeast-2` (Sydney)      *      * **Supported Task Types:**      * - **TEXT_IMAGE**: Basic text-to-image generation      * - **TEXT_IMAGE with Conditioning**: Layout-guided generation using edge detection or segmentation      * - **COLOR_GUIDED_GENERATION**: Generate images with specific color palettes      * - **IMAGE_VARIATION**: Create variations of existing images      * - **INPAINTING**: Fill masked areas in images      * - **OUTPAINTING**: Extend images beyond their borders      * - **BACKGROUND_REMOVAL**: Remove backgrounds from images      * - **VIRTUAL_TRY_ON**: Try on garments/objects on people      *      * **Quality Options:**      * - **standard**: Faster generation, lower cost      * - **premium**: Higher quality, slower generation      *      * **Timeout:** Image generation can take up to 5 minutes
     * @summary Generate images with Amazon Nova Canvas
     * @param {string} organisation The organisation ID
     * @param {ImageGenerationRequest} imageGenerationRequest Image generation request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AIServicesApi
     */
    public imageGeneration(organisation: string, imageGenerationRequest: ImageGenerationRequest, options?: RawAxiosRequestConfig) {
        return AIServicesApiFp(this.configuration).imageGeneration(organisation, imageGenerationRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List available AI models for an organization
     * @param {string} organisation The organisation ID
     * @param {ListAIModelsFeatureEnum} [feature] Filter models by supported feature
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AIServicesApi
     */
    public listAIModels(organisation: string, feature?: ListAIModelsFeatureEnum, options?: RawAxiosRequestConfig) {
        return AIServicesApiFp(this.configuration).listAIModels(organisation, feature, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Lists active sessions for an organization with flexible filtering options.      *      * **Query Combinations:**      * 1. By Organization (default): Returns all sessions in the organization      * 2. By Organization + Group: `?sessionGroup=drupal-prod` - Sessions in a specific group      * 3. By User: `?userId=user-123` - All sessions for a user      * 4. By User + Group: `?userId=user-123&sessionGroup=drupal-prod` - User\'s sessions in a specific group      *      * **Use Cases:**      * - List user\'s conversations in a specific app/environment      * - Admin view of all sessions in a customer/tenant group      * - User profile showing all AI conversations across apps
     * @summary List chat sessions with multi-tenant filtering
     * @param {string} organisation The organisation ID
     * @param {string} [userId] Filter sessions by user ID
     * @param {string} [sessionGroup] Filter by session group. Returns only sessions matching the specified group.
     * @param {number} [limit] Maximum number of sessions to return (default 50, max 100)
     * @param {number} [offset] Offset for pagination
     * @param {string} [model] Filter by model ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AIServicesApi
     */
    public listAISessions(organisation: string, userId?: string, sessionGroup?: string, limit?: number, offset?: number, model?: string, options?: RawAxiosRequestConfig) {
        return AIServicesApiFp(this.configuration).listAISessions(organisation, userId, sessionGroup, limit, offset, model, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves just the names of available built-in tools. Useful for quick validation or UI dropdown population without the full tool specifications.
     * @summary List tool names only (lightweight response)
     * @param {string} organisation The organisation ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AIServicesApi
     */
    public listAIToolNames(organisation: string, options?: RawAxiosRequestConfig) {
        return AIServicesApiFp(this.configuration).listAIToolNames(organisation, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves all available built-in tools that can be used with function calling. These tools can be included in `toolConfig` when making AI inference requests.      *      * **Available Built-in Tools:**      * - `get_weather`: Get current weather for a location using Open-Meteo API      * - `calculate`: Perform basic mathematical calculations (add, subtract, multiply, divide)      * - `search_web`: Search the web for information (mock implementation)      * - `generate_image`: Generate images with Amazon Nova Canvas (async execution, 10-15s typical runtime)      *      * **Use Cases:**      * - Discover available tools dynamically without hardcoding      * - Get complete tool specifications including input schemas      * - Build UI for tool selection      * - Validate tool names before sending requests      *      * **Dynamic Tool Discovery:**      * This endpoint enables clients to:      * 1. Fetch all available tools on page load      * 2. Display tool capabilities to users      * 3. Filter tools based on user permissions      * 4. Use `allowedTools` whitelist for security      *      * **Alternative Endpoint:**      * - `GET /ai/tools/names` - Returns only tool names (faster, lighter response)
     * @summary List available built-in tools for function calling
     * @param {string} organisation The organisation ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AIServicesApi
     */
    public listAITools(organisation: string, options?: RawAxiosRequestConfig) {
        return AIServicesApiFp(this.configuration).listAITools(organisation, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Lists recent async tool executions for an organization. Useful for debugging, monitoring, and building admin UIs.      *      * **Query Patterns:**      * - All recent executions: `GET /ai/tools/executions`      * - Filter by status: `GET /ai/tools/executions?status=running`      * - Limit results: `GET /ai/tools/executions?limit=20`      *      * **Results:**      * - Ordered by creation time (newest first)      * - Limited to 50 by default (configurable via `limit` parameter)      * - Only shows executions not yet expired (24h TTL)      *      * **Use Cases:**      * - Monitor all active tool executions      * - Debug failed executions      * - Build admin dashboards      * - Track tool usage patterns      * - Audit async operations
     * @summary List tool executions for monitoring and debugging
     * @param {string} organisation The organisation ID
     * @param {ListToolExecutionsStatusEnum} [status] Filter by execution status
     * @param {number} [limit] Maximum number of executions to return
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AIServicesApi
     */
    public listToolExecutions(organisation: string, status?: ListToolExecutionsStatusEnum, limit?: number, options?: RawAxiosRequestConfig) {
        return AIServicesApiFp(this.configuration).listToolExecutions(organisation, status, limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update AI configuration for an organization
     * @param {string} organisation The organisation ID
     * @param {UpdateAIConfigRequest} updateAIConfigRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AIServicesApi
     */
    public updateAIConfig(organisation: string, updateAIConfigRequest: UpdateAIConfigRequest, options?: RawAxiosRequestConfig) {
        return AIServicesApiFp(this.configuration).updateAIConfig(organisation, updateAIConfigRequest, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const ListAIModelsFeatureEnum = {
    Chat: 'chat',
    Embeddings: 'embeddings',
    Vision: 'vision',
    Streaming: 'streaming',
    All: 'all'
} as const;
export type ListAIModelsFeatureEnum = typeof ListAIModelsFeatureEnum[keyof typeof ListAIModelsFeatureEnum];
/**
 * @export
 */
export const ListToolExecutionsStatusEnum = {
    Pending: 'pending',
    Running: 'running',
    Complete: 'complete',
    Failed: 'failed'
} as const;
export type ListToolExecutionsStatusEnum = typeof ListToolExecutionsStatusEnum[keyof typeof ListToolExecutionsStatusEnum];


/**
 * ApplicationsApi - axios parameter creator
 * @export
 */
export const ApplicationsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create a new application
         * @param {string} organisation The organisation ID
         * @param {CreateApplicationRequest} createApplicationRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createApplication: async (organisation: string, createApplicationRequest: CreateApplicationRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organisation' is not null or undefined
            assertParamExists('createApplication', 'organisation', organisation)
            // verify required parameter 'createApplicationRequest' is not null or undefined
            assertParamExists('createApplication', 'createApplicationRequest', createApplicationRequest)
            const localVarPath = `/api/v3/organizations/{organisation}/applications`
                .replace(`{${"organisation"}}`, encodeURIComponent(String(organisation)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createApplicationRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete an application
         * @param {string} organisation The organisation ID
         * @param {string} application The application ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteApplication: async (organisation: string, application: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organisation' is not null or undefined
            assertParamExists('deleteApplication', 'organisation', organisation)
            // verify required parameter 'application' is not null or undefined
            assertParamExists('deleteApplication', 'application', application)
            const localVarPath = `/api/v3/organizations/{organisation}/applications/{application}`
                .replace(`{${"organisation"}}`, encodeURIComponent(String(organisation)))
                .replace(`{${"application"}}`, encodeURIComponent(String(application)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a single application
         * @param {string} organisation The organisation ID
         * @param {string} application The application ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getApplication: async (organisation: string, application: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organisation' is not null or undefined
            assertParamExists('getApplication', 'organisation', organisation)
            // verify required parameter 'application' is not null or undefined
            assertParamExists('getApplication', 'application', application)
            const localVarPath = `/api/v3/organizations/{organisation}/applications/{application}`
                .replace(`{${"organisation"}}`, encodeURIComponent(String(organisation)))
                .replace(`{${"application"}}`, encodeURIComponent(String(application)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get ECR login credentials
         * @param {string} organisation The organisation ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEcrLoginCredentials: async (organisation: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organisation' is not null or undefined
            assertParamExists('getEcrLoginCredentials', 'organisation', organisation)
            const localVarPath = `/api/v3/organizations/{organisation}/applications/ecr-login`
                .replace(`{${"organisation"}}`, encodeURIComponent(String(organisation)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get all applications for an organisation
         * @param {string} organisation The organisation ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listApplications: async (organisation: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organisation' is not null or undefined
            assertParamExists('listApplications', 'organisation', organisation)
            const localVarPath = `/api/v3/organizations/{organisation}/applications`
                .replace(`{${"organisation"}}`, encodeURIComponent(String(organisation)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ApplicationsApi - functional programming interface
 * @export
 */
export const ApplicationsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ApplicationsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Create a new application
         * @param {string} organisation The organisation ID
         * @param {CreateApplicationRequest} createApplicationRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createApplication(organisation: string, createApplicationRequest: CreateApplicationRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Application>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createApplication(organisation, createApplicationRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ApplicationsApi.createApplication']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete an application
         * @param {string} organisation The organisation ID
         * @param {string} application The application ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteApplication(organisation: string, application: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteApplication(organisation, application, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ApplicationsApi.deleteApplication']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get a single application
         * @param {string} organisation The organisation ID
         * @param {string} application The application ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getApplication(organisation: string, application: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Application>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getApplication(organisation, application, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ApplicationsApi.getApplication']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get ECR login credentials
         * @param {string} organisation The organisation ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getEcrLoginCredentials(organisation: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetEcrLoginCredentials200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getEcrLoginCredentials(organisation, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ApplicationsApi.getEcrLoginCredentials']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get all applications for an organisation
         * @param {string} organisation The organisation ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listApplications(organisation: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Application>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listApplications(organisation, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ApplicationsApi.listApplications']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ApplicationsApi - factory interface
 * @export
 */
export const ApplicationsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ApplicationsApiFp(configuration)
    return {
        /**
         * 
         * @summary Create a new application
         * @param {string} organisation The organisation ID
         * @param {CreateApplicationRequest} createApplicationRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createApplication(organisation: string, createApplicationRequest: CreateApplicationRequest, options?: RawAxiosRequestConfig): AxiosPromise<Application> {
            return localVarFp.createApplication(organisation, createApplicationRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete an application
         * @param {string} organisation The organisation ID
         * @param {string} application The application ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteApplication(organisation: string, application: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteApplication(organisation, application, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a single application
         * @param {string} organisation The organisation ID
         * @param {string} application The application ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getApplication(organisation: string, application: string, options?: RawAxiosRequestConfig): AxiosPromise<Application> {
            return localVarFp.getApplication(organisation, application, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get ECR login credentials
         * @param {string} organisation The organisation ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEcrLoginCredentials(organisation: string, options?: RawAxiosRequestConfig): AxiosPromise<GetEcrLoginCredentials200Response> {
            return localVarFp.getEcrLoginCredentials(organisation, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get all applications for an organisation
         * @param {string} organisation The organisation ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listApplications(organisation: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<Application>> {
            return localVarFp.listApplications(organisation, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ApplicationsApi - object-oriented interface
 * @export
 * @class ApplicationsApi
 * @extends {BaseAPI}
 */
export class ApplicationsApi extends BaseAPI {
    /**
     * 
     * @summary Create a new application
     * @param {string} organisation The organisation ID
     * @param {CreateApplicationRequest} createApplicationRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationsApi
     */
    public createApplication(organisation: string, createApplicationRequest: CreateApplicationRequest, options?: RawAxiosRequestConfig) {
        return ApplicationsApiFp(this.configuration).createApplication(organisation, createApplicationRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete an application
     * @param {string} organisation The organisation ID
     * @param {string} application The application ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationsApi
     */
    public deleteApplication(organisation: string, application: string, options?: RawAxiosRequestConfig) {
        return ApplicationsApiFp(this.configuration).deleteApplication(organisation, application, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a single application
     * @param {string} organisation The organisation ID
     * @param {string} application The application ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationsApi
     */
    public getApplication(organisation: string, application: string, options?: RawAxiosRequestConfig) {
        return ApplicationsApiFp(this.configuration).getApplication(organisation, application, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get ECR login credentials
     * @param {string} organisation The organisation ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationsApi
     */
    public getEcrLoginCredentials(organisation: string, options?: RawAxiosRequestConfig) {
        return ApplicationsApiFp(this.configuration).getEcrLoginCredentials(organisation, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get all applications for an organisation
     * @param {string} organisation The organisation ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationsApi
     */
    public listApplications(organisation: string, options?: RawAxiosRequestConfig) {
        return ApplicationsApiFp(this.configuration).listApplications(organisation, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * BackupManagementApi - axios parameter creator
 * @export
 */
export const BackupManagementApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create a backup for an environment
         * @param {string} organisation The organisation ID
         * @param {string} application The application ID
         * @param {string} environment The environment ID
         * @param {CreateBackupTypeEnum} type The backup type
         * @param {CreateBackupRequest} [createBackupRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createBackup: async (organisation: string, application: string, environment: string, type: CreateBackupTypeEnum, createBackupRequest?: CreateBackupRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organisation' is not null or undefined
            assertParamExists('createBackup', 'organisation', organisation)
            // verify required parameter 'application' is not null or undefined
            assertParamExists('createBackup', 'application', application)
            // verify required parameter 'environment' is not null or undefined
            assertParamExists('createBackup', 'environment', environment)
            // verify required parameter 'type' is not null or undefined
            assertParamExists('createBackup', 'type', type)
            const localVarPath = `/api/v3/organizations/{organisation}/applications/{application}/environments/{environment}/backups/{type}`
                .replace(`{${"organisation"}}`, encodeURIComponent(String(organisation)))
                .replace(`{${"application"}}`, encodeURIComponent(String(application)))
                .replace(`{${"environment"}}`, encodeURIComponent(String(environment)))
                .replace(`{${"type"}}`, encodeURIComponent(String(type)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createBackupRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a backup
         * @param {string} organisation The organisation ID
         * @param {string} application The application ID
         * @param {string} environment The environment ID
         * @param {DeleteBackupTypeEnum} type The backup type
         * @param {string} backupId The backup ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteBackup: async (organisation: string, application: string, environment: string, type: DeleteBackupTypeEnum, backupId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organisation' is not null or undefined
            assertParamExists('deleteBackup', 'organisation', organisation)
            // verify required parameter 'application' is not null or undefined
            assertParamExists('deleteBackup', 'application', application)
            // verify required parameter 'environment' is not null or undefined
            assertParamExists('deleteBackup', 'environment', environment)
            // verify required parameter 'type' is not null or undefined
            assertParamExists('deleteBackup', 'type', type)
            // verify required parameter 'backupId' is not null or undefined
            assertParamExists('deleteBackup', 'backupId', backupId)
            const localVarPath = `/api/v3/organizations/{organisation}/applications/{application}/environments/{environment}/backups/{type}/{backupId}`
                .replace(`{${"organisation"}}`, encodeURIComponent(String(organisation)))
                .replace(`{${"application"}}`, encodeURIComponent(String(application)))
                .replace(`{${"environment"}}`, encodeURIComponent(String(environment)))
                .replace(`{${"type"}}`, encodeURIComponent(String(type)))
                .replace(`{${"backupId"}}`, encodeURIComponent(String(backupId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Generate a download URL for a backup
         * @param {string} organisation The organisation ID
         * @param {string} application The application ID
         * @param {string} environment The environment ID
         * @param {DownloadBackupTypeEnum} type The backup type
         * @param {string} backupId The backup ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadBackup: async (organisation: string, application: string, environment: string, type: DownloadBackupTypeEnum, backupId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organisation' is not null or undefined
            assertParamExists('downloadBackup', 'organisation', organisation)
            // verify required parameter 'application' is not null or undefined
            assertParamExists('downloadBackup', 'application', application)
            // verify required parameter 'environment' is not null or undefined
            assertParamExists('downloadBackup', 'environment', environment)
            // verify required parameter 'type' is not null or undefined
            assertParamExists('downloadBackup', 'type', type)
            // verify required parameter 'backupId' is not null or undefined
            assertParamExists('downloadBackup', 'backupId', backupId)
            const localVarPath = `/api/v3/organizations/{organisation}/applications/{application}/environments/{environment}/backups/{type}/{backupId}/download`
                .replace(`{${"organisation"}}`, encodeURIComponent(String(organisation)))
                .replace(`{${"application"}}`, encodeURIComponent(String(application)))
                .replace(`{${"environment"}}`, encodeURIComponent(String(environment)))
                .replace(`{${"type"}}`, encodeURIComponent(String(type)))
                .replace(`{${"backupId"}}`, encodeURIComponent(String(backupId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves a list of backups (database or filesystem) for the environment with status, size, and metadata. Supports filtering and ordering via query parameters.
         * @summary List backups for an environment
         * @param {string} organisation The organisation ID
         * @param {string} application The application ID
         * @param {string} environment The environment ID
         * @param {ListBackupsTypeEnum} type The backup type
         * @param {ListBackupsOrderEnum} [order] Sort order for backups by creation date (asc &#x3D; oldest first, desc &#x3D; newest first)
         * @param {number} [limit] Maximum number of backups to return (max 100)
         * @param {string} [createdBefore] Only return backups created before this ISO 8601 timestamp (e.g., 2025-01-01T00:00:00Z)
         * @param {string} [createdAfter] Only return backups created after this ISO 8601 timestamp (e.g., 2024-12-01T00:00:00Z)
         * @param {ListBackupsStatusEnum} [status] Filter backups by status
         * @param {string} [nextToken] Token for retrieving the next page of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listBackups: async (organisation: string, application: string, environment: string, type: ListBackupsTypeEnum, order?: ListBackupsOrderEnum, limit?: number, createdBefore?: string, createdAfter?: string, status?: ListBackupsStatusEnum, nextToken?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organisation' is not null or undefined
            assertParamExists('listBackups', 'organisation', organisation)
            // verify required parameter 'application' is not null or undefined
            assertParamExists('listBackups', 'application', application)
            // verify required parameter 'environment' is not null or undefined
            assertParamExists('listBackups', 'environment', environment)
            // verify required parameter 'type' is not null or undefined
            assertParamExists('listBackups', 'type', type)
            const localVarPath = `/api/v3/organizations/{organisation}/applications/{application}/environments/{environment}/backups/{type}`
                .replace(`{${"organisation"}}`, encodeURIComponent(String(organisation)))
                .replace(`{${"application"}}`, encodeURIComponent(String(application)))
                .replace(`{${"environment"}}`, encodeURIComponent(String(environment)))
                .replace(`{${"type"}}`, encodeURIComponent(String(type)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (createdBefore !== undefined) {
                localVarQueryParameter['createdBefore'] = (createdBefore as any instanceof Date) ?
                    (createdBefore as any).toISOString() :
                    createdBefore;
            }

            if (createdAfter !== undefined) {
                localVarQueryParameter['createdAfter'] = (createdAfter as any instanceof Date) ?
                    (createdAfter as any).toISOString() :
                    createdAfter;
            }

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }

            if (nextToken !== undefined) {
                localVarQueryParameter['nextToken'] = nextToken;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * BackupManagementApi - functional programming interface
 * @export
 */
export const BackupManagementApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = BackupManagementApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Create a backup for an environment
         * @param {string} organisation The organisation ID
         * @param {string} application The application ID
         * @param {string} environment The environment ID
         * @param {CreateBackupTypeEnum} type The backup type
         * @param {CreateBackupRequest} [createBackupRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createBackup(organisation: string, application: string, environment: string, type: CreateBackupTypeEnum, createBackupRequest?: CreateBackupRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateBackup202Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createBackup(organisation, application, environment, type, createBackupRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BackupManagementApi.createBackup']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete a backup
         * @param {string} organisation The organisation ID
         * @param {string} application The application ID
         * @param {string} environment The environment ID
         * @param {DeleteBackupTypeEnum} type The backup type
         * @param {string} backupId The backup ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteBackup(organisation: string, application: string, environment: string, type: DeleteBackupTypeEnum, backupId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeleteBackup200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteBackup(organisation, application, environment, type, backupId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BackupManagementApi.deleteBackup']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Generate a download URL for a backup
         * @param {string} organisation The organisation ID
         * @param {string} application The application ID
         * @param {string} environment The environment ID
         * @param {DownloadBackupTypeEnum} type The backup type
         * @param {string} backupId The backup ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async downloadBackup(organisation: string, application: string, environment: string, type: DownloadBackupTypeEnum, backupId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DownloadBackup200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.downloadBackup(organisation, application, environment, type, backupId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BackupManagementApi.downloadBackup']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieves a list of backups (database or filesystem) for the environment with status, size, and metadata. Supports filtering and ordering via query parameters.
         * @summary List backups for an environment
         * @param {string} organisation The organisation ID
         * @param {string} application The application ID
         * @param {string} environment The environment ID
         * @param {ListBackupsTypeEnum} type The backup type
         * @param {ListBackupsOrderEnum} [order] Sort order for backups by creation date (asc &#x3D; oldest first, desc &#x3D; newest first)
         * @param {number} [limit] Maximum number of backups to return (max 100)
         * @param {string} [createdBefore] Only return backups created before this ISO 8601 timestamp (e.g., 2025-01-01T00:00:00Z)
         * @param {string} [createdAfter] Only return backups created after this ISO 8601 timestamp (e.g., 2024-12-01T00:00:00Z)
         * @param {ListBackupsStatusEnum} [status] Filter backups by status
         * @param {string} [nextToken] Token for retrieving the next page of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listBackups(organisation: string, application: string, environment: string, type: ListBackupsTypeEnum, order?: ListBackupsOrderEnum, limit?: number, createdBefore?: string, createdAfter?: string, status?: ListBackupsStatusEnum, nextToken?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListBackups200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listBackups(organisation, application, environment, type, order, limit, createdBefore, createdAfter, status, nextToken, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BackupManagementApi.listBackups']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * BackupManagementApi - factory interface
 * @export
 */
export const BackupManagementApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = BackupManagementApiFp(configuration)
    return {
        /**
         * 
         * @summary Create a backup for an environment
         * @param {string} organisation The organisation ID
         * @param {string} application The application ID
         * @param {string} environment The environment ID
         * @param {CreateBackupTypeEnum} type The backup type
         * @param {CreateBackupRequest} [createBackupRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createBackup(organisation: string, application: string, environment: string, type: CreateBackupTypeEnum, createBackupRequest?: CreateBackupRequest, options?: RawAxiosRequestConfig): AxiosPromise<CreateBackup202Response> {
            return localVarFp.createBackup(organisation, application, environment, type, createBackupRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete a backup
         * @param {string} organisation The organisation ID
         * @param {string} application The application ID
         * @param {string} environment The environment ID
         * @param {DeleteBackupTypeEnum} type The backup type
         * @param {string} backupId The backup ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteBackup(organisation: string, application: string, environment: string, type: DeleteBackupTypeEnum, backupId: string, options?: RawAxiosRequestConfig): AxiosPromise<DeleteBackup200Response> {
            return localVarFp.deleteBackup(organisation, application, environment, type, backupId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Generate a download URL for a backup
         * @param {string} organisation The organisation ID
         * @param {string} application The application ID
         * @param {string} environment The environment ID
         * @param {DownloadBackupTypeEnum} type The backup type
         * @param {string} backupId The backup ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadBackup(organisation: string, application: string, environment: string, type: DownloadBackupTypeEnum, backupId: string, options?: RawAxiosRequestConfig): AxiosPromise<DownloadBackup200Response> {
            return localVarFp.downloadBackup(organisation, application, environment, type, backupId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves a list of backups (database or filesystem) for the environment with status, size, and metadata. Supports filtering and ordering via query parameters.
         * @summary List backups for an environment
         * @param {string} organisation The organisation ID
         * @param {string} application The application ID
         * @param {string} environment The environment ID
         * @param {ListBackupsTypeEnum} type The backup type
         * @param {ListBackupsOrderEnum} [order] Sort order for backups by creation date (asc &#x3D; oldest first, desc &#x3D; newest first)
         * @param {number} [limit] Maximum number of backups to return (max 100)
         * @param {string} [createdBefore] Only return backups created before this ISO 8601 timestamp (e.g., 2025-01-01T00:00:00Z)
         * @param {string} [createdAfter] Only return backups created after this ISO 8601 timestamp (e.g., 2024-12-01T00:00:00Z)
         * @param {ListBackupsStatusEnum} [status] Filter backups by status
         * @param {string} [nextToken] Token for retrieving the next page of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listBackups(organisation: string, application: string, environment: string, type: ListBackupsTypeEnum, order?: ListBackupsOrderEnum, limit?: number, createdBefore?: string, createdAfter?: string, status?: ListBackupsStatusEnum, nextToken?: string, options?: RawAxiosRequestConfig): AxiosPromise<ListBackups200Response> {
            return localVarFp.listBackups(organisation, application, environment, type, order, limit, createdBefore, createdAfter, status, nextToken, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * BackupManagementApi - object-oriented interface
 * @export
 * @class BackupManagementApi
 * @extends {BaseAPI}
 */
export class BackupManagementApi extends BaseAPI {
    /**
     * 
     * @summary Create a backup for an environment
     * @param {string} organisation The organisation ID
     * @param {string} application The application ID
     * @param {string} environment The environment ID
     * @param {CreateBackupTypeEnum} type The backup type
     * @param {CreateBackupRequest} [createBackupRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BackupManagementApi
     */
    public createBackup(organisation: string, application: string, environment: string, type: CreateBackupTypeEnum, createBackupRequest?: CreateBackupRequest, options?: RawAxiosRequestConfig) {
        return BackupManagementApiFp(this.configuration).createBackup(organisation, application, environment, type, createBackupRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete a backup
     * @param {string} organisation The organisation ID
     * @param {string} application The application ID
     * @param {string} environment The environment ID
     * @param {DeleteBackupTypeEnum} type The backup type
     * @param {string} backupId The backup ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BackupManagementApi
     */
    public deleteBackup(organisation: string, application: string, environment: string, type: DeleteBackupTypeEnum, backupId: string, options?: RawAxiosRequestConfig) {
        return BackupManagementApiFp(this.configuration).deleteBackup(organisation, application, environment, type, backupId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Generate a download URL for a backup
     * @param {string} organisation The organisation ID
     * @param {string} application The application ID
     * @param {string} environment The environment ID
     * @param {DownloadBackupTypeEnum} type The backup type
     * @param {string} backupId The backup ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BackupManagementApi
     */
    public downloadBackup(organisation: string, application: string, environment: string, type: DownloadBackupTypeEnum, backupId: string, options?: RawAxiosRequestConfig) {
        return BackupManagementApiFp(this.configuration).downloadBackup(organisation, application, environment, type, backupId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves a list of backups (database or filesystem) for the environment with status, size, and metadata. Supports filtering and ordering via query parameters.
     * @summary List backups for an environment
     * @param {string} organisation The organisation ID
     * @param {string} application The application ID
     * @param {string} environment The environment ID
     * @param {ListBackupsTypeEnum} type The backup type
     * @param {ListBackupsOrderEnum} [order] Sort order for backups by creation date (asc &#x3D; oldest first, desc &#x3D; newest first)
     * @param {number} [limit] Maximum number of backups to return (max 100)
     * @param {string} [createdBefore] Only return backups created before this ISO 8601 timestamp (e.g., 2025-01-01T00:00:00Z)
     * @param {string} [createdAfter] Only return backups created after this ISO 8601 timestamp (e.g., 2024-12-01T00:00:00Z)
     * @param {ListBackupsStatusEnum} [status] Filter backups by status
     * @param {string} [nextToken] Token for retrieving the next page of results
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BackupManagementApi
     */
    public listBackups(organisation: string, application: string, environment: string, type: ListBackupsTypeEnum, order?: ListBackupsOrderEnum, limit?: number, createdBefore?: string, createdAfter?: string, status?: ListBackupsStatusEnum, nextToken?: string, options?: RawAxiosRequestConfig) {
        return BackupManagementApiFp(this.configuration).listBackups(organisation, application, environment, type, order, limit, createdBefore, createdAfter, status, nextToken, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const CreateBackupTypeEnum = {
    Database: 'database',
    Filesystem: 'filesystem'
} as const;
export type CreateBackupTypeEnum = typeof CreateBackupTypeEnum[keyof typeof CreateBackupTypeEnum];
/**
 * @export
 */
export const DeleteBackupTypeEnum = {
    Database: 'database',
    Filesystem: 'filesystem'
} as const;
export type DeleteBackupTypeEnum = typeof DeleteBackupTypeEnum[keyof typeof DeleteBackupTypeEnum];
/**
 * @export
 */
export const DownloadBackupTypeEnum = {
    Database: 'database',
    Filesystem: 'filesystem'
} as const;
export type DownloadBackupTypeEnum = typeof DownloadBackupTypeEnum[keyof typeof DownloadBackupTypeEnum];
/**
 * @export
 */
export const ListBackupsTypeEnum = {
    Database: 'database',
    Filesystem: 'filesystem'
} as const;
export type ListBackupsTypeEnum = typeof ListBackupsTypeEnum[keyof typeof ListBackupsTypeEnum];
/**
 * @export
 */
export const ListBackupsOrderEnum = {
    Asc: 'asc',
    Desc: 'desc'
} as const;
export type ListBackupsOrderEnum = typeof ListBackupsOrderEnum[keyof typeof ListBackupsOrderEnum];
/**
 * @export
 */
export const ListBackupsStatusEnum = {
    Completed: 'completed',
    Failed: 'failed',
    Running: 'running'
} as const;
export type ListBackupsStatusEnum = typeof ListBackupsStatusEnum[keyof typeof ListBackupsStatusEnum];


/**
 * CommandsApi - axios parameter creator
 * @export
 */
export const CommandsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create a command for an environment
         * @param {string} organisation The organisation ID
         * @param {string} environment The environment ID
         * @param {CreateCommandRequest} createCommandRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCommand: async (organisation: string, environment: string, createCommandRequest: CreateCommandRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organisation' is not null or undefined
            assertParamExists('createCommand', 'organisation', organisation)
            // verify required parameter 'environment' is not null or undefined
            assertParamExists('createCommand', 'environment', environment)
            // verify required parameter 'createCommandRequest' is not null or undefined
            assertParamExists('createCommand', 'createCommandRequest', createCommandRequest)
            const localVarPath = `/api/v3/organizations/{organisation}/environments/{environment}/commands`
                .replace(`{${"organisation"}}`, encodeURIComponent(String(organisation)))
                .replace(`{${"environment"}}`, encodeURIComponent(String(environment)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createCommandRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a command
         * @param {string} organisation The organisation ID
         * @param {string} environment The environment ID
         * @param {string} command The command ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCommand: async (organisation: string, environment: string, command: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organisation' is not null or undefined
            assertParamExists('getCommand', 'organisation', organisation)
            // verify required parameter 'environment' is not null or undefined
            assertParamExists('getCommand', 'environment', environment)
            // verify required parameter 'command' is not null or undefined
            assertParamExists('getCommand', 'command', command)
            const localVarPath = `/api/v3/organizations/{organisation}/environments/{environment}/commands/{command}`
                .replace(`{${"organisation"}}`, encodeURIComponent(String(organisation)))
                .replace(`{${"environment"}}`, encodeURIComponent(String(environment)))
                .replace(`{${"command"}}`, encodeURIComponent(String(command)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get all commands for an environment
         * @param {string} organisation The organisation ID
         * @param {string} environment The environment ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listCommands: async (organisation: string, environment: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organisation' is not null or undefined
            assertParamExists('listCommands', 'organisation', organisation)
            // verify required parameter 'environment' is not null or undefined
            assertParamExists('listCommands', 'environment', environment)
            const localVarPath = `/api/v3/organizations/{organisation}/environments/{environment}/commands`
                .replace(`{${"organisation"}}`, encodeURIComponent(String(organisation)))
                .replace(`{${"environment"}}`, encodeURIComponent(String(environment)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CommandsApi - functional programming interface
 * @export
 */
export const CommandsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = CommandsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Create a command for an environment
         * @param {string} organisation The organisation ID
         * @param {string} environment The environment ID
         * @param {CreateCommandRequest} createCommandRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createCommand(organisation: string, environment: string, createCommandRequest: CreateCommandRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Command>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createCommand(organisation, environment, createCommandRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CommandsApi.createCommand']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get a command
         * @param {string} organisation The organisation ID
         * @param {string} environment The environment ID
         * @param {string} command The command ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCommand(organisation: string, environment: string, command: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Command>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCommand(organisation, environment, command, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CommandsApi.getCommand']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get all commands for an environment
         * @param {string} organisation The organisation ID
         * @param {string} environment The environment ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listCommands(organisation: string, environment: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Command>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listCommands(organisation, environment, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CommandsApi.listCommands']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * CommandsApi - factory interface
 * @export
 */
export const CommandsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CommandsApiFp(configuration)
    return {
        /**
         * 
         * @summary Create a command for an environment
         * @param {string} organisation The organisation ID
         * @param {string} environment The environment ID
         * @param {CreateCommandRequest} createCommandRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCommand(organisation: string, environment: string, createCommandRequest: CreateCommandRequest, options?: RawAxiosRequestConfig): AxiosPromise<Command> {
            return localVarFp.createCommand(organisation, environment, createCommandRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a command
         * @param {string} organisation The organisation ID
         * @param {string} environment The environment ID
         * @param {string} command The command ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCommand(organisation: string, environment: string, command: string, options?: RawAxiosRequestConfig): AxiosPromise<Command> {
            return localVarFp.getCommand(organisation, environment, command, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get all commands for an environment
         * @param {string} organisation The organisation ID
         * @param {string} environment The environment ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listCommands(organisation: string, environment: string, options?: RawAxiosRequestConfig): AxiosPromise<Command> {
            return localVarFp.listCommands(organisation, environment, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * CommandsApi - object-oriented interface
 * @export
 * @class CommandsApi
 * @extends {BaseAPI}
 */
export class CommandsApi extends BaseAPI {
    /**
     * 
     * @summary Create a command for an environment
     * @param {string} organisation The organisation ID
     * @param {string} environment The environment ID
     * @param {CreateCommandRequest} createCommandRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CommandsApi
     */
    public createCommand(organisation: string, environment: string, createCommandRequest: CreateCommandRequest, options?: RawAxiosRequestConfig) {
        return CommandsApiFp(this.configuration).createCommand(organisation, environment, createCommandRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a command
     * @param {string} organisation The organisation ID
     * @param {string} environment The environment ID
     * @param {string} command The command ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CommandsApi
     */
    public getCommand(organisation: string, environment: string, command: string, options?: RawAxiosRequestConfig) {
        return CommandsApiFp(this.configuration).getCommand(organisation, environment, command, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get all commands for an environment
     * @param {string} organisation The organisation ID
     * @param {string} environment The environment ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CommandsApi
     */
    public listCommands(organisation: string, environment: string, options?: RawAxiosRequestConfig) {
        return CommandsApiFp(this.configuration).listCommands(organisation, environment, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ComposeApi - axios parameter creator
 * @export
 */
export const ComposeApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get the compose file for an environment
         * @param {string} organisation The organisation ID
         * @param {string} application The application ID
         * @param {string} environment The environment ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEnvironmentCompose: async (organisation: string, application: string, environment: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organisation' is not null or undefined
            assertParamExists('getEnvironmentCompose', 'organisation', organisation)
            // verify required parameter 'application' is not null or undefined
            assertParamExists('getEnvironmentCompose', 'application', application)
            // verify required parameter 'environment' is not null or undefined
            assertParamExists('getEnvironmentCompose', 'environment', environment)
            const localVarPath = `/api/v3/organizations/{organisation}/applications/{application}/environments/{environment}/compose`
                .replace(`{${"organisation"}}`, encodeURIComponent(String(organisation)))
                .replace(`{${"application"}}`, encodeURIComponent(String(application)))
                .replace(`{${"environment"}}`, encodeURIComponent(String(environment)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Accepts a docker-compose.yml file content, translates it into the internal compose definition format, and validates it. Supports image tag suffixing via the imageSuffix query parameter or by sending a JSON wrapper with yamlContent and imageSuffix fields. When provided, internal image tags are transformed to {containerName}-{suffix} format (e.g., \'nginx-feature-xyz\').
         * @summary Validate a compose file
         * @param {string} organisation The organisation ID
         * @param {ValidateComposeRequest} validateComposeRequest The docker-compose.yml file content. Can be sent as raw YAML string or as a JSON wrapper containing both yamlContent (string) and imageSuffix (string) fields. Query parameter imageSuffix takes precedence if both are provided.
         * @param {string} [imageSuffix] Optional. Image tag suffix to apply during translation. Transforms internal image tags to consistent \&#39;{containerName}-{suffix}\&#39; format (e.g., \&#39;nginx-pr-456\&#39;). External images are left unchanged. Useful for feature branch deployments.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        validateCompose: async (organisation: string, validateComposeRequest: ValidateComposeRequest, imageSuffix?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organisation' is not null or undefined
            assertParamExists('validateCompose', 'organisation', organisation)
            // verify required parameter 'validateComposeRequest' is not null or undefined
            assertParamExists('validateCompose', 'validateComposeRequest', validateComposeRequest)
            const localVarPath = `/api/v3/organizations/{organisation}/compose/validate`
                .replace(`{${"organisation"}}`, encodeURIComponent(String(organisation)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (imageSuffix !== undefined) {
                localVarQueryParameter['imageSuffix'] = imageSuffix;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(validateComposeRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ComposeApi - functional programming interface
 * @export
 */
export const ComposeApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ComposeApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Get the compose file for an environment
         * @param {string} organisation The organisation ID
         * @param {string} application The application ID
         * @param {string} environment The environment ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getEnvironmentCompose(organisation: string, application: string, environment: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Compose>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getEnvironmentCompose(organisation, application, environment, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ComposeApi.getEnvironmentCompose']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Accepts a docker-compose.yml file content, translates it into the internal compose definition format, and validates it. Supports image tag suffixing via the imageSuffix query parameter or by sending a JSON wrapper with yamlContent and imageSuffix fields. When provided, internal image tags are transformed to {containerName}-{suffix} format (e.g., \'nginx-feature-xyz\').
         * @summary Validate a compose file
         * @param {string} organisation The organisation ID
         * @param {ValidateComposeRequest} validateComposeRequest The docker-compose.yml file content. Can be sent as raw YAML string or as a JSON wrapper containing both yamlContent (string) and imageSuffix (string) fields. Query parameter imageSuffix takes precedence if both are provided.
         * @param {string} [imageSuffix] Optional. Image tag suffix to apply during translation. Transforms internal image tags to consistent \&#39;{containerName}-{suffix}\&#39; format (e.g., \&#39;nginx-pr-456\&#39;). External images are left unchanged. Useful for feature branch deployments.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async validateCompose(organisation: string, validateComposeRequest: ValidateComposeRequest, imageSuffix?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ValidateCompose200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.validateCompose(organisation, validateComposeRequest, imageSuffix, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ComposeApi.validateCompose']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ComposeApi - factory interface
 * @export
 */
export const ComposeApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ComposeApiFp(configuration)
    return {
        /**
         * 
         * @summary Get the compose file for an environment
         * @param {string} organisation The organisation ID
         * @param {string} application The application ID
         * @param {string} environment The environment ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEnvironmentCompose(organisation: string, application: string, environment: string, options?: RawAxiosRequestConfig): AxiosPromise<Compose> {
            return localVarFp.getEnvironmentCompose(organisation, application, environment, options).then((request) => request(axios, basePath));
        },
        /**
         * Accepts a docker-compose.yml file content, translates it into the internal compose definition format, and validates it. Supports image tag suffixing via the imageSuffix query parameter or by sending a JSON wrapper with yamlContent and imageSuffix fields. When provided, internal image tags are transformed to {containerName}-{suffix} format (e.g., \'nginx-feature-xyz\').
         * @summary Validate a compose file
         * @param {string} organisation The organisation ID
         * @param {ValidateComposeRequest} validateComposeRequest The docker-compose.yml file content. Can be sent as raw YAML string or as a JSON wrapper containing both yamlContent (string) and imageSuffix (string) fields. Query parameter imageSuffix takes precedence if both are provided.
         * @param {string} [imageSuffix] Optional. Image tag suffix to apply during translation. Transforms internal image tags to consistent \&#39;{containerName}-{suffix}\&#39; format (e.g., \&#39;nginx-pr-456\&#39;). External images are left unchanged. Useful for feature branch deployments.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        validateCompose(organisation: string, validateComposeRequest: ValidateComposeRequest, imageSuffix?: string, options?: RawAxiosRequestConfig): AxiosPromise<ValidateCompose200Response> {
            return localVarFp.validateCompose(organisation, validateComposeRequest, imageSuffix, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ComposeApi - object-oriented interface
 * @export
 * @class ComposeApi
 * @extends {BaseAPI}
 */
export class ComposeApi extends BaseAPI {
    /**
     * 
     * @summary Get the compose file for an environment
     * @param {string} organisation The organisation ID
     * @param {string} application The application ID
     * @param {string} environment The environment ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ComposeApi
     */
    public getEnvironmentCompose(organisation: string, application: string, environment: string, options?: RawAxiosRequestConfig) {
        return ComposeApiFp(this.configuration).getEnvironmentCompose(organisation, application, environment, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Accepts a docker-compose.yml file content, translates it into the internal compose definition format, and validates it. Supports image tag suffixing via the imageSuffix query parameter or by sending a JSON wrapper with yamlContent and imageSuffix fields. When provided, internal image tags are transformed to {containerName}-{suffix} format (e.g., \'nginx-feature-xyz\').
     * @summary Validate a compose file
     * @param {string} organisation The organisation ID
     * @param {ValidateComposeRequest} validateComposeRequest The docker-compose.yml file content. Can be sent as raw YAML string or as a JSON wrapper containing both yamlContent (string) and imageSuffix (string) fields. Query parameter imageSuffix takes precedence if both are provided.
     * @param {string} [imageSuffix] Optional. Image tag suffix to apply during translation. Transforms internal image tags to consistent \&#39;{containerName}-{suffix}\&#39; format (e.g., \&#39;nginx-pr-456\&#39;). External images are left unchanged. Useful for feature branch deployments.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ComposeApi
     */
    public validateCompose(organisation: string, validateComposeRequest: ValidateComposeRequest, imageSuffix?: string, options?: RawAxiosRequestConfig) {
        return ComposeApiFp(this.configuration).validateCompose(organisation, validateComposeRequest, imageSuffix, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ContainersApi - axios parameter creator
 * @export
 */
export const ContainersApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get the containers in an environment
         * @param {string} organisation The organisation ID
         * @param {string} application The application ID
         * @param {string} environment The environment ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listContainers: async (organisation: string, application: string, environment: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organisation' is not null or undefined
            assertParamExists('listContainers', 'organisation', organisation)
            // verify required parameter 'application' is not null or undefined
            assertParamExists('listContainers', 'application', application)
            // verify required parameter 'environment' is not null or undefined
            assertParamExists('listContainers', 'environment', environment)
            const localVarPath = `/api/v3/organizations/{organisation}/applications/{application}/environments/{environment}/containers`
                .replace(`{${"organisation"}}`, encodeURIComponent(String(organisation)))
                .replace(`{${"application"}}`, encodeURIComponent(String(application)))
                .replace(`{${"environment"}}`, encodeURIComponent(String(environment)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update a container in an environment
         * @param {string} organisation The organisation ID
         * @param {string} application The application ID
         * @param {string} environment The environment ID
         * @param {string} container The container ID
         * @param {Container} container2 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateContainer: async (organisation: string, application: string, environment: string, container: string, container2: Container, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organisation' is not null or undefined
            assertParamExists('updateContainer', 'organisation', organisation)
            // verify required parameter 'application' is not null or undefined
            assertParamExists('updateContainer', 'application', application)
            // verify required parameter 'environment' is not null or undefined
            assertParamExists('updateContainer', 'environment', environment)
            // verify required parameter 'container' is not null or undefined
            assertParamExists('updateContainer', 'container', container)
            // verify required parameter 'container2' is not null or undefined
            assertParamExists('updateContainer', 'container2', container2)
            const localVarPath = `/api/v3/organizations/{organisation}/applications/{application}/environments/{environment}/containers/{container}`
                .replace(`{${"organisation"}}`, encodeURIComponent(String(organisation)))
                .replace(`{${"application"}}`, encodeURIComponent(String(application)))
                .replace(`{${"environment"}}`, encodeURIComponent(String(environment)))
                .replace(`{${"container"}}`, encodeURIComponent(String(container)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(container2, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ContainersApi - functional programming interface
 * @export
 */
export const ContainersApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ContainersApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Get the containers in an environment
         * @param {string} organisation The organisation ID
         * @param {string} application The application ID
         * @param {string} environment The environment ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listContainers(organisation: string, application: string, environment: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listContainers(organisation, application, environment, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ContainersApi.listContainers']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update a container in an environment
         * @param {string} organisation The organisation ID
         * @param {string} application The application ID
         * @param {string} environment The environment ID
         * @param {string} container The container ID
         * @param {Container} container2 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateContainer(organisation: string, application: string, environment: string, container: string, container2: Container, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateContainer(organisation, application, environment, container, container2, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ContainersApi.updateContainer']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ContainersApi - factory interface
 * @export
 */
export const ContainersApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ContainersApiFp(configuration)
    return {
        /**
         * 
         * @summary Get the containers in an environment
         * @param {string} organisation The organisation ID
         * @param {string} application The application ID
         * @param {string} environment The environment ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listContainers(organisation: string, application: string, environment: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.listContainers(organisation, application, environment, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update a container in an environment
         * @param {string} organisation The organisation ID
         * @param {string} application The application ID
         * @param {string} environment The environment ID
         * @param {string} container The container ID
         * @param {Container} container2 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateContainer(organisation: string, application: string, environment: string, container: string, container2: Container, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.updateContainer(organisation, application, environment, container, container2, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ContainersApi - object-oriented interface
 * @export
 * @class ContainersApi
 * @extends {BaseAPI}
 */
export class ContainersApi extends BaseAPI {
    /**
     * 
     * @summary Get the containers in an environment
     * @param {string} organisation The organisation ID
     * @param {string} application The application ID
     * @param {string} environment The environment ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContainersApi
     */
    public listContainers(organisation: string, application: string, environment: string, options?: RawAxiosRequestConfig) {
        return ContainersApiFp(this.configuration).listContainers(organisation, application, environment, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update a container in an environment
     * @param {string} organisation The organisation ID
     * @param {string} application The application ID
     * @param {string} environment The environment ID
     * @param {string} container The container ID
     * @param {Container} container2 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContainersApi
     */
    public updateContainer(organisation: string, application: string, environment: string, container: string, container2: Container, options?: RawAxiosRequestConfig) {
        return ContainersApiFp(this.configuration).updateContainer(organisation, application, environment, container, container2, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * CrawlerSchedulesApi - axios parameter creator
 * @export
 */
export const CrawlerSchedulesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Add a new schedule
         * @param {string} organization Organization identifier
         * @param {string} project Project identifier
         * @param {string} crawler Crawler identifier
         * @param {V2CrawlerScheduleRequest} v2CrawlerScheduleRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        crawlerSchedulesAdd: async (organization: string, project: string, crawler: string, v2CrawlerScheduleRequest: V2CrawlerScheduleRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organization' is not null or undefined
            assertParamExists('crawlerSchedulesAdd', 'organization', organization)
            // verify required parameter 'project' is not null or undefined
            assertParamExists('crawlerSchedulesAdd', 'project', project)
            // verify required parameter 'crawler' is not null or undefined
            assertParamExists('crawlerSchedulesAdd', 'crawler', crawler)
            // verify required parameter 'v2CrawlerScheduleRequest' is not null or undefined
            assertParamExists('crawlerSchedulesAdd', 'v2CrawlerScheduleRequest', v2CrawlerScheduleRequest)
            const localVarPath = `/api/v2/organizations/{organization}/projects/{project}/crawlers/{crawler}/schedules`
                .replace(`{${"organization"}}`, encodeURIComponent(String(organization)))
                .replace(`{${"project"}}`, encodeURIComponent(String(project)))
                .replace(`{${"crawler"}}`, encodeURIComponent(String(crawler)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(v2CrawlerScheduleRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a schedule
         * @param {string} organization Organization identifier
         * @param {string} project Project identifier
         * @param {string} crawler Crawler identifier
         * @param {string} crawlerSchedule Crawler schedule identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        crawlerSchedulesDelete: async (organization: string, project: string, crawler: string, crawlerSchedule: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organization' is not null or undefined
            assertParamExists('crawlerSchedulesDelete', 'organization', organization)
            // verify required parameter 'project' is not null or undefined
            assertParamExists('crawlerSchedulesDelete', 'project', project)
            // verify required parameter 'crawler' is not null or undefined
            assertParamExists('crawlerSchedulesDelete', 'crawler', crawler)
            // verify required parameter 'crawlerSchedule' is not null or undefined
            assertParamExists('crawlerSchedulesDelete', 'crawlerSchedule', crawlerSchedule)
            const localVarPath = `/api/v2/organizations/{organization}/projects/{project}/crawlers/{crawler}/schedules`
                .replace(`{${"organization"}}`, encodeURIComponent(String(organization)))
                .replace(`{${"project"}}`, encodeURIComponent(String(project)))
                .replace(`{${"crawler"}}`, encodeURIComponent(String(crawler)))
                .replace(`{${"crawler_schedule"}}`, encodeURIComponent(String(crawlerSchedule)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Edit a schedule
         * @param {string} organization Organization identifier
         * @param {string} project Project identifier
         * @param {string} crawler Crawler identifier
         * @param {V2CrawlerScheduleRequest} v2CrawlerScheduleRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        crawlerSchedulesEdit: async (organization: string, project: string, crawler: string, v2CrawlerScheduleRequest: V2CrawlerScheduleRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organization' is not null or undefined
            assertParamExists('crawlerSchedulesEdit', 'organization', organization)
            // verify required parameter 'project' is not null or undefined
            assertParamExists('crawlerSchedulesEdit', 'project', project)
            // verify required parameter 'crawler' is not null or undefined
            assertParamExists('crawlerSchedulesEdit', 'crawler', crawler)
            // verify required parameter 'v2CrawlerScheduleRequest' is not null or undefined
            assertParamExists('crawlerSchedulesEdit', 'v2CrawlerScheduleRequest', v2CrawlerScheduleRequest)
            const localVarPath = `/api/v2/organizations/{organization}/projects/{project}/crawlers/{crawler}/schedules`
                .replace(`{${"organization"}}`, encodeURIComponent(String(organization)))
                .replace(`{${"project"}}`, encodeURIComponent(String(project)))
                .replace(`{${"crawler"}}`, encodeURIComponent(String(crawler)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(v2CrawlerScheduleRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List schedules for a crawler
         * @param {string} organization 
         * @param {string} project 
         * @param {string} crawler 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        crawlerSchedulesList: async (organization: string, project: string, crawler: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organization' is not null or undefined
            assertParamExists('crawlerSchedulesList', 'organization', organization)
            // verify required parameter 'project' is not null or undefined
            assertParamExists('crawlerSchedulesList', 'project', project)
            // verify required parameter 'crawler' is not null or undefined
            assertParamExists('crawlerSchedulesList', 'crawler', crawler)
            const localVarPath = `/api/v2/organizations/{organization}/projects/{project}/crawlers/{crawler}/schedules`
                .replace(`{${"organization"}}`, encodeURIComponent(String(organization)))
                .replace(`{${"project"}}`, encodeURIComponent(String(project)))
                .replace(`{${"crawler"}}`, encodeURIComponent(String(crawler)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Show a specific schedule
         * @param {string} organization Organization identifier
         * @param {string} project Project identifier
         * @param {string} crawler Crawler identifier
         * @param {string} crawlerSchedule Crawler schedule identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        crawlerSchedulesShow: async (organization: string, project: string, crawler: string, crawlerSchedule: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organization' is not null or undefined
            assertParamExists('crawlerSchedulesShow', 'organization', organization)
            // verify required parameter 'project' is not null or undefined
            assertParamExists('crawlerSchedulesShow', 'project', project)
            // verify required parameter 'crawler' is not null or undefined
            assertParamExists('crawlerSchedulesShow', 'crawler', crawler)
            // verify required parameter 'crawlerSchedule' is not null or undefined
            assertParamExists('crawlerSchedulesShow', 'crawlerSchedule', crawlerSchedule)
            const localVarPath = `/api/v2/organizations/{organization}/projects/{project}/crawlers/{crawler}/schedules/{crawler_schedule}`
                .replace(`{${"organization"}}`, encodeURIComponent(String(organization)))
                .replace(`{${"project"}}`, encodeURIComponent(String(project)))
                .replace(`{${"crawler"}}`, encodeURIComponent(String(crawler)))
                .replace(`{${"crawler_schedule"}}`, encodeURIComponent(String(crawlerSchedule)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CrawlerSchedulesApi - functional programming interface
 * @export
 */
export const CrawlerSchedulesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = CrawlerSchedulesApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Add a new schedule
         * @param {string} organization Organization identifier
         * @param {string} project Project identifier
         * @param {string} crawler Crawler identifier
         * @param {V2CrawlerScheduleRequest} v2CrawlerScheduleRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async crawlerSchedulesAdd(organization: string, project: string, crawler: string, v2CrawlerScheduleRequest: V2CrawlerScheduleRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<V2CrawlerSchedule>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.crawlerSchedulesAdd(organization, project, crawler, v2CrawlerScheduleRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CrawlerSchedulesApi.crawlerSchedulesAdd']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete a schedule
         * @param {string} organization Organization identifier
         * @param {string} project Project identifier
         * @param {string} crawler Crawler identifier
         * @param {string} crawlerSchedule Crawler schedule identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async crawlerSchedulesDelete(organization: string, project: string, crawler: string, crawlerSchedule: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.crawlerSchedulesDelete(organization, project, crawler, crawlerSchedule, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CrawlerSchedulesApi.crawlerSchedulesDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Edit a schedule
         * @param {string} organization Organization identifier
         * @param {string} project Project identifier
         * @param {string} crawler Crawler identifier
         * @param {V2CrawlerScheduleRequest} v2CrawlerScheduleRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async crawlerSchedulesEdit(organization: string, project: string, crawler: string, v2CrawlerScheduleRequest: V2CrawlerScheduleRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<V2CrawlerSchedule>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.crawlerSchedulesEdit(organization, project, crawler, v2CrawlerScheduleRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CrawlerSchedulesApi.crawlerSchedulesEdit']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary List schedules for a crawler
         * @param {string} organization 
         * @param {string} project 
         * @param {string} crawler 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async crawlerSchedulesList(organization: string, project: string, crawler: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<V2CrawlerSchedule>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.crawlerSchedulesList(organization, project, crawler, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CrawlerSchedulesApi.crawlerSchedulesList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Show a specific schedule
         * @param {string} organization Organization identifier
         * @param {string} project Project identifier
         * @param {string} crawler Crawler identifier
         * @param {string} crawlerSchedule Crawler schedule identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async crawlerSchedulesShow(organization: string, project: string, crawler: string, crawlerSchedule: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<V2CrawlerSchedule>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.crawlerSchedulesShow(organization, project, crawler, crawlerSchedule, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CrawlerSchedulesApi.crawlerSchedulesShow']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * CrawlerSchedulesApi - factory interface
 * @export
 */
export const CrawlerSchedulesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CrawlerSchedulesApiFp(configuration)
    return {
        /**
         * 
         * @summary Add a new schedule
         * @param {string} organization Organization identifier
         * @param {string} project Project identifier
         * @param {string} crawler Crawler identifier
         * @param {V2CrawlerScheduleRequest} v2CrawlerScheduleRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        crawlerSchedulesAdd(organization: string, project: string, crawler: string, v2CrawlerScheduleRequest: V2CrawlerScheduleRequest, options?: RawAxiosRequestConfig): AxiosPromise<V2CrawlerSchedule> {
            return localVarFp.crawlerSchedulesAdd(organization, project, crawler, v2CrawlerScheduleRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete a schedule
         * @param {string} organization Organization identifier
         * @param {string} project Project identifier
         * @param {string} crawler Crawler identifier
         * @param {string} crawlerSchedule Crawler schedule identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        crawlerSchedulesDelete(organization: string, project: string, crawler: string, crawlerSchedule: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.crawlerSchedulesDelete(organization, project, crawler, crawlerSchedule, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Edit a schedule
         * @param {string} organization Organization identifier
         * @param {string} project Project identifier
         * @param {string} crawler Crawler identifier
         * @param {V2CrawlerScheduleRequest} v2CrawlerScheduleRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        crawlerSchedulesEdit(organization: string, project: string, crawler: string, v2CrawlerScheduleRequest: V2CrawlerScheduleRequest, options?: RawAxiosRequestConfig): AxiosPromise<V2CrawlerSchedule> {
            return localVarFp.crawlerSchedulesEdit(organization, project, crawler, v2CrawlerScheduleRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List schedules for a crawler
         * @param {string} organization 
         * @param {string} project 
         * @param {string} crawler 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        crawlerSchedulesList(organization: string, project: string, crawler: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<V2CrawlerSchedule>> {
            return localVarFp.crawlerSchedulesList(organization, project, crawler, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Show a specific schedule
         * @param {string} organization Organization identifier
         * @param {string} project Project identifier
         * @param {string} crawler Crawler identifier
         * @param {string} crawlerSchedule Crawler schedule identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        crawlerSchedulesShow(organization: string, project: string, crawler: string, crawlerSchedule: string, options?: RawAxiosRequestConfig): AxiosPromise<V2CrawlerSchedule> {
            return localVarFp.crawlerSchedulesShow(organization, project, crawler, crawlerSchedule, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * CrawlerSchedulesApi - object-oriented interface
 * @export
 * @class CrawlerSchedulesApi
 * @extends {BaseAPI}
 */
export class CrawlerSchedulesApi extends BaseAPI {
    /**
     * 
     * @summary Add a new schedule
     * @param {string} organization Organization identifier
     * @param {string} project Project identifier
     * @param {string} crawler Crawler identifier
     * @param {V2CrawlerScheduleRequest} v2CrawlerScheduleRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CrawlerSchedulesApi
     */
    public crawlerSchedulesAdd(organization: string, project: string, crawler: string, v2CrawlerScheduleRequest: V2CrawlerScheduleRequest, options?: RawAxiosRequestConfig) {
        return CrawlerSchedulesApiFp(this.configuration).crawlerSchedulesAdd(organization, project, crawler, v2CrawlerScheduleRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete a schedule
     * @param {string} organization Organization identifier
     * @param {string} project Project identifier
     * @param {string} crawler Crawler identifier
     * @param {string} crawlerSchedule Crawler schedule identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CrawlerSchedulesApi
     */
    public crawlerSchedulesDelete(organization: string, project: string, crawler: string, crawlerSchedule: string, options?: RawAxiosRequestConfig) {
        return CrawlerSchedulesApiFp(this.configuration).crawlerSchedulesDelete(organization, project, crawler, crawlerSchedule, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Edit a schedule
     * @param {string} organization Organization identifier
     * @param {string} project Project identifier
     * @param {string} crawler Crawler identifier
     * @param {V2CrawlerScheduleRequest} v2CrawlerScheduleRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CrawlerSchedulesApi
     */
    public crawlerSchedulesEdit(organization: string, project: string, crawler: string, v2CrawlerScheduleRequest: V2CrawlerScheduleRequest, options?: RawAxiosRequestConfig) {
        return CrawlerSchedulesApiFp(this.configuration).crawlerSchedulesEdit(organization, project, crawler, v2CrawlerScheduleRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List schedules for a crawler
     * @param {string} organization 
     * @param {string} project 
     * @param {string} crawler 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CrawlerSchedulesApi
     */
    public crawlerSchedulesList(organization: string, project: string, crawler: string, options?: RawAxiosRequestConfig) {
        return CrawlerSchedulesApiFp(this.configuration).crawlerSchedulesList(organization, project, crawler, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Show a specific schedule
     * @param {string} organization Organization identifier
     * @param {string} project Project identifier
     * @param {string} crawler Crawler identifier
     * @param {string} crawlerSchedule Crawler schedule identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CrawlerSchedulesApi
     */
    public crawlerSchedulesShow(organization: string, project: string, crawler: string, crawlerSchedule: string, options?: RawAxiosRequestConfig) {
        return CrawlerSchedulesApiFp(this.configuration).crawlerSchedulesShow(organization, project, crawler, crawlerSchedule, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * CrawlersApi - axios parameter creator
 * @export
 */
export const CrawlersApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create a new crawler
         * @param {string} organization Organization identifier
         * @param {string} project Project identifier
         * @param {V2CrawlerRequest} v2CrawlerRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        crawlersCreate: async (organization: string, project: string, v2CrawlerRequest: V2CrawlerRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organization' is not null or undefined
            assertParamExists('crawlersCreate', 'organization', organization)
            // verify required parameter 'project' is not null or undefined
            assertParamExists('crawlersCreate', 'project', project)
            // verify required parameter 'v2CrawlerRequest' is not null or undefined
            assertParamExists('crawlersCreate', 'v2CrawlerRequest', v2CrawlerRequest)
            const localVarPath = `/api/v2/organizations/{organization}/projects/{project}/crawlers`
                .replace(`{${"organization"}}`, encodeURIComponent(String(organization)))
                .replace(`{${"project"}}`, encodeURIComponent(String(project)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(v2CrawlerRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a crawler
         * @param {string} organization Organization identifier
         * @param {string} project Project identifier
         * @param {string} crawler 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        crawlersDelete: async (organization: string, project: string, crawler: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organization' is not null or undefined
            assertParamExists('crawlersDelete', 'organization', organization)
            // verify required parameter 'project' is not null or undefined
            assertParamExists('crawlersDelete', 'project', project)
            // verify required parameter 'crawler' is not null or undefined
            assertParamExists('crawlersDelete', 'crawler', crawler)
            const localVarPath = `/api/v2/organizations/{organization}/projects/{project}/crawlers/{crawler}`
                .replace(`{${"organization"}}`, encodeURIComponent(String(organization)))
                .replace(`{${"project"}}`, encodeURIComponent(String(project)))
                .replace(`{${"crawler"}}`, encodeURIComponent(String(crawler)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List crawlers for the project
         * @param {string} organization Organization identifier
         * @param {string} project Project identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        crawlersList: async (organization: string, project: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organization' is not null or undefined
            assertParamExists('crawlersList', 'organization', organization)
            // verify required parameter 'project' is not null or undefined
            assertParamExists('crawlersList', 'project', project)
            const localVarPath = `/api/v2/organizations/{organization}/projects/{project}/crawlers`
                .replace(`{${"organization"}}`, encodeURIComponent(String(organization)))
                .replace(`{${"project"}}`, encodeURIComponent(String(project)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get details of a single crawler
         * @param {string} organization Organization identifier
         * @param {string} project Project identifier
         * @param {string} crawler 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        crawlersRead: async (organization: string, project: string, crawler: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organization' is not null or undefined
            assertParamExists('crawlersRead', 'organization', organization)
            // verify required parameter 'project' is not null or undefined
            assertParamExists('crawlersRead', 'project', project)
            // verify required parameter 'crawler' is not null or undefined
            assertParamExists('crawlersRead', 'crawler', crawler)
            const localVarPath = `/api/v2/organizations/{organization}/projects/{project}/crawlers/{crawler}`
                .replace(`{${"organization"}}`, encodeURIComponent(String(organization)))
                .replace(`{${"project"}}`, encodeURIComponent(String(project)))
                .replace(`{${"crawler"}}`, encodeURIComponent(String(crawler)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update a crawler
         * @param {string} organization Organization identifier
         * @param {string} project Project identifier
         * @param {string} crawler 
         * @param {V2CrawlerRequest} v2CrawlerRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        crawlersUpdate: async (organization: string, project: string, crawler: string, v2CrawlerRequest: V2CrawlerRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organization' is not null or undefined
            assertParamExists('crawlersUpdate', 'organization', organization)
            // verify required parameter 'project' is not null or undefined
            assertParamExists('crawlersUpdate', 'project', project)
            // verify required parameter 'crawler' is not null or undefined
            assertParamExists('crawlersUpdate', 'crawler', crawler)
            // verify required parameter 'v2CrawlerRequest' is not null or undefined
            assertParamExists('crawlersUpdate', 'v2CrawlerRequest', v2CrawlerRequest)
            const localVarPath = `/api/v2/organizations/{organization}/projects/{project}/crawlers/{crawler}`
                .replace(`{${"organization"}}`, encodeURIComponent(String(organization)))
                .replace(`{${"project"}}`, encodeURIComponent(String(project)))
                .replace(`{${"crawler"}}`, encodeURIComponent(String(crawler)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(v2CrawlerRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CrawlersApi - functional programming interface
 * @export
 */
export const CrawlersApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = CrawlersApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Create a new crawler
         * @param {string} organization Organization identifier
         * @param {string} project Project identifier
         * @param {V2CrawlerRequest} v2CrawlerRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async crawlersCreate(organization: string, project: string, v2CrawlerRequest: V2CrawlerRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<V2Crawler>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.crawlersCreate(organization, project, v2CrawlerRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CrawlersApi.crawlersCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete a crawler
         * @param {string} organization Organization identifier
         * @param {string} project Project identifier
         * @param {string} crawler 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async crawlersDelete(organization: string, project: string, crawler: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.crawlersDelete(organization, project, crawler, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CrawlersApi.crawlersDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary List crawlers for the project
         * @param {string} organization Organization identifier
         * @param {string} project Project identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async crawlersList(organization: string, project: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<V2Crawler>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.crawlersList(organization, project, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CrawlersApi.crawlersList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get details of a single crawler
         * @param {string} organization Organization identifier
         * @param {string} project Project identifier
         * @param {string} crawler 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async crawlersRead(organization: string, project: string, crawler: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<V2Crawler>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.crawlersRead(organization, project, crawler, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CrawlersApi.crawlersRead']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update a crawler
         * @param {string} organization Organization identifier
         * @param {string} project Project identifier
         * @param {string} crawler 
         * @param {V2CrawlerRequest} v2CrawlerRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async crawlersUpdate(organization: string, project: string, crawler: string, v2CrawlerRequest: V2CrawlerRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<V2Crawler>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.crawlersUpdate(organization, project, crawler, v2CrawlerRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CrawlersApi.crawlersUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * CrawlersApi - factory interface
 * @export
 */
export const CrawlersApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CrawlersApiFp(configuration)
    return {
        /**
         * 
         * @summary Create a new crawler
         * @param {string} organization Organization identifier
         * @param {string} project Project identifier
         * @param {V2CrawlerRequest} v2CrawlerRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        crawlersCreate(organization: string, project: string, v2CrawlerRequest: V2CrawlerRequest, options?: RawAxiosRequestConfig): AxiosPromise<V2Crawler> {
            return localVarFp.crawlersCreate(organization, project, v2CrawlerRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete a crawler
         * @param {string} organization Organization identifier
         * @param {string} project Project identifier
         * @param {string} crawler 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        crawlersDelete(organization: string, project: string, crawler: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.crawlersDelete(organization, project, crawler, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List crawlers for the project
         * @param {string} organization Organization identifier
         * @param {string} project Project identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        crawlersList(organization: string, project: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<V2Crawler>> {
            return localVarFp.crawlersList(organization, project, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get details of a single crawler
         * @param {string} organization Organization identifier
         * @param {string} project Project identifier
         * @param {string} crawler 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        crawlersRead(organization: string, project: string, crawler: string, options?: RawAxiosRequestConfig): AxiosPromise<V2Crawler> {
            return localVarFp.crawlersRead(organization, project, crawler, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update a crawler
         * @param {string} organization Organization identifier
         * @param {string} project Project identifier
         * @param {string} crawler 
         * @param {V2CrawlerRequest} v2CrawlerRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        crawlersUpdate(organization: string, project: string, crawler: string, v2CrawlerRequest: V2CrawlerRequest, options?: RawAxiosRequestConfig): AxiosPromise<V2Crawler> {
            return localVarFp.crawlersUpdate(organization, project, crawler, v2CrawlerRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * CrawlersApi - object-oriented interface
 * @export
 * @class CrawlersApi
 * @extends {BaseAPI}
 */
export class CrawlersApi extends BaseAPI {
    /**
     * 
     * @summary Create a new crawler
     * @param {string} organization Organization identifier
     * @param {string} project Project identifier
     * @param {V2CrawlerRequest} v2CrawlerRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CrawlersApi
     */
    public crawlersCreate(organization: string, project: string, v2CrawlerRequest: V2CrawlerRequest, options?: RawAxiosRequestConfig) {
        return CrawlersApiFp(this.configuration).crawlersCreate(organization, project, v2CrawlerRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete a crawler
     * @param {string} organization Organization identifier
     * @param {string} project Project identifier
     * @param {string} crawler 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CrawlersApi
     */
    public crawlersDelete(organization: string, project: string, crawler: string, options?: RawAxiosRequestConfig) {
        return CrawlersApiFp(this.configuration).crawlersDelete(organization, project, crawler, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List crawlers for the project
     * @param {string} organization Organization identifier
     * @param {string} project Project identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CrawlersApi
     */
    public crawlersList(organization: string, project: string, options?: RawAxiosRequestConfig) {
        return CrawlersApiFp(this.configuration).crawlersList(organization, project, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get details of a single crawler
     * @param {string} organization Organization identifier
     * @param {string} project Project identifier
     * @param {string} crawler 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CrawlersApi
     */
    public crawlersRead(organization: string, project: string, crawler: string, options?: RawAxiosRequestConfig) {
        return CrawlersApiFp(this.configuration).crawlersRead(organization, project, crawler, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update a crawler
     * @param {string} organization Organization identifier
     * @param {string} project Project identifier
     * @param {string} crawler 
     * @param {V2CrawlerRequest} v2CrawlerRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CrawlersApi
     */
    public crawlersUpdate(organization: string, project: string, crawler: string, v2CrawlerRequest: V2CrawlerRequest, options?: RawAxiosRequestConfig) {
        return CrawlersApiFp(this.configuration).crawlersUpdate(organization, project, crawler, v2CrawlerRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * CronApi - axios parameter creator
 * @export
 */
export const CronApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create a new cron job
         * @param {string} organisation The organisation ID
         * @param {string} application The application ID
         * @param {string} environment The environment ID
         * @param {CreateCronJobRequest} createCronJobRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCronJob: async (organisation: string, application: string, environment: string, createCronJobRequest: CreateCronJobRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organisation' is not null or undefined
            assertParamExists('createCronJob', 'organisation', organisation)
            // verify required parameter 'application' is not null or undefined
            assertParamExists('createCronJob', 'application', application)
            // verify required parameter 'environment' is not null or undefined
            assertParamExists('createCronJob', 'environment', environment)
            // verify required parameter 'createCronJobRequest' is not null or undefined
            assertParamExists('createCronJob', 'createCronJobRequest', createCronJobRequest)
            const localVarPath = `/api/v3/organizations/{organisation}/applications/{application}/environments/{environment}/cron`
                .replace(`{${"organisation"}}`, encodeURIComponent(String(organisation)))
                .replace(`{${"application"}}`, encodeURIComponent(String(application)))
                .replace(`{${"environment"}}`, encodeURIComponent(String(environment)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createCronJobRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a cron job
         * @param {string} organisation The organisation ID
         * @param {string} application The application ID
         * @param {string} environment The environment ID
         * @param {string} cron The cron job ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCronJob: async (organisation: string, application: string, environment: string, cron: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organisation' is not null or undefined
            assertParamExists('deleteCronJob', 'organisation', organisation)
            // verify required parameter 'application' is not null or undefined
            assertParamExists('deleteCronJob', 'application', application)
            // verify required parameter 'environment' is not null or undefined
            assertParamExists('deleteCronJob', 'environment', environment)
            // verify required parameter 'cron' is not null or undefined
            assertParamExists('deleteCronJob', 'cron', cron)
            const localVarPath = `/api/v3/organizations/{organisation}/applications/{application}/environments/{environment}/cron/{cron}`
                .replace(`{${"organisation"}}`, encodeURIComponent(String(organisation)))
                .replace(`{${"application"}}`, encodeURIComponent(String(application)))
                .replace(`{${"environment"}}`, encodeURIComponent(String(environment)))
                .replace(`{${"cron"}}`, encodeURIComponent(String(cron)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a cron job
         * @param {string} organisation The organisation ID
         * @param {string} application The application ID
         * @param {string} environment The environment ID
         * @param {string} cron The cron job ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCronJob: async (organisation: string, application: string, environment: string, cron: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organisation' is not null or undefined
            assertParamExists('getCronJob', 'organisation', organisation)
            // verify required parameter 'application' is not null or undefined
            assertParamExists('getCronJob', 'application', application)
            // verify required parameter 'environment' is not null or undefined
            assertParamExists('getCronJob', 'environment', environment)
            // verify required parameter 'cron' is not null or undefined
            assertParamExists('getCronJob', 'cron', cron)
            const localVarPath = `/api/v3/organizations/{organisation}/applications/{application}/environments/{environment}/cron/{cron}`
                .replace(`{${"organisation"}}`, encodeURIComponent(String(organisation)))
                .replace(`{${"application"}}`, encodeURIComponent(String(application)))
                .replace(`{${"environment"}}`, encodeURIComponent(String(environment)))
                .replace(`{${"cron"}}`, encodeURIComponent(String(cron)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a cron run
         * @param {string} organisation The organisation ID
         * @param {string} application The application ID
         * @param {string} environment The environment ID
         * @param {string} cron The cron job ID
         * @param {string} run The cron run ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCronRun: async (organisation: string, application: string, environment: string, cron: string, run: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organisation' is not null or undefined
            assertParamExists('getCronRun', 'organisation', organisation)
            // verify required parameter 'application' is not null or undefined
            assertParamExists('getCronRun', 'application', application)
            // verify required parameter 'environment' is not null or undefined
            assertParamExists('getCronRun', 'environment', environment)
            // verify required parameter 'cron' is not null or undefined
            assertParamExists('getCronRun', 'cron', cron)
            // verify required parameter 'run' is not null or undefined
            assertParamExists('getCronRun', 'run', run)
            const localVarPath = `/api/v3/organizations/{organisation}/applications/{application}/environments/{environment}/cron/{cron}/runs/{run}`
                .replace(`{${"organisation"}}`, encodeURIComponent(String(organisation)))
                .replace(`{${"application"}}`, encodeURIComponent(String(application)))
                .replace(`{${"environment"}}`, encodeURIComponent(String(environment)))
                .replace(`{${"cron"}}`, encodeURIComponent(String(cron)))
                .replace(`{${"run"}}`, encodeURIComponent(String(run)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get all runs for a cron job
         * @param {string} organisation The organisation ID
         * @param {string} application The application ID
         * @param {string} environment The environment ID
         * @param {string} cron The cron job ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listCronJobRuns: async (organisation: string, application: string, environment: string, cron: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organisation' is not null or undefined
            assertParamExists('listCronJobRuns', 'organisation', organisation)
            // verify required parameter 'application' is not null or undefined
            assertParamExists('listCronJobRuns', 'application', application)
            // verify required parameter 'environment' is not null or undefined
            assertParamExists('listCronJobRuns', 'environment', environment)
            // verify required parameter 'cron' is not null or undefined
            assertParamExists('listCronJobRuns', 'cron', cron)
            const localVarPath = `/api/v3/organizations/{organisation}/applications/{application}/environments/{environment}/cron/{cron}/runs`
                .replace(`{${"organisation"}}`, encodeURIComponent(String(organisation)))
                .replace(`{${"application"}}`, encodeURIComponent(String(application)))
                .replace(`{${"environment"}}`, encodeURIComponent(String(environment)))
                .replace(`{${"cron"}}`, encodeURIComponent(String(cron)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get all cron jobs for an environment
         * @param {string} organisation The organisation ID
         * @param {string} application The application ID
         * @param {string} environment The environment ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listCronJobs: async (organisation: string, application: string, environment: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organisation' is not null or undefined
            assertParamExists('listCronJobs', 'organisation', organisation)
            // verify required parameter 'application' is not null or undefined
            assertParamExists('listCronJobs', 'application', application)
            // verify required parameter 'environment' is not null or undefined
            assertParamExists('listCronJobs', 'environment', environment)
            const localVarPath = `/api/v3/organizations/{organisation}/applications/{application}/environments/{environment}/cron`
                .replace(`{${"organisation"}}`, encodeURIComponent(String(organisation)))
                .replace(`{${"application"}}`, encodeURIComponent(String(application)))
                .replace(`{${"environment"}}`, encodeURIComponent(String(environment)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update a cron job
         * @param {string} organisation The organisation ID
         * @param {string} application The application ID
         * @param {string} environment The environment ID
         * @param {string} cron The cron job ID
         * @param {UpdateCronJobRequest} updateCronJobRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCronJob: async (organisation: string, application: string, environment: string, cron: string, updateCronJobRequest: UpdateCronJobRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organisation' is not null or undefined
            assertParamExists('updateCronJob', 'organisation', organisation)
            // verify required parameter 'application' is not null or undefined
            assertParamExists('updateCronJob', 'application', application)
            // verify required parameter 'environment' is not null or undefined
            assertParamExists('updateCronJob', 'environment', environment)
            // verify required parameter 'cron' is not null or undefined
            assertParamExists('updateCronJob', 'cron', cron)
            // verify required parameter 'updateCronJobRequest' is not null or undefined
            assertParamExists('updateCronJob', 'updateCronJobRequest', updateCronJobRequest)
            const localVarPath = `/api/v3/organizations/{organisation}/applications/{application}/environments/{environment}/cron/{cron}`
                .replace(`{${"organisation"}}`, encodeURIComponent(String(organisation)))
                .replace(`{${"application"}}`, encodeURIComponent(String(application)))
                .replace(`{${"environment"}}`, encodeURIComponent(String(environment)))
                .replace(`{${"cron"}}`, encodeURIComponent(String(cron)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateCronJobRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CronApi - functional programming interface
 * @export
 */
export const CronApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = CronApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Create a new cron job
         * @param {string} organisation The organisation ID
         * @param {string} application The application ID
         * @param {string} environment The environment ID
         * @param {CreateCronJobRequest} createCronJobRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createCronJob(organisation: string, application: string, environment: string, createCronJobRequest: CreateCronJobRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Cron>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createCronJob(organisation, application, environment, createCronJobRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CronApi.createCronJob']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete a cron job
         * @param {string} organisation The organisation ID
         * @param {string} application The application ID
         * @param {string} environment The environment ID
         * @param {string} cron The cron job ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteCronJob(organisation: string, application: string, environment: string, cron: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteCronJob(organisation, application, environment, cron, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CronApi.deleteCronJob']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get a cron job
         * @param {string} organisation The organisation ID
         * @param {string} application The application ID
         * @param {string} environment The environment ID
         * @param {string} cron The cron job ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCronJob(organisation: string, application: string, environment: string, cron: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Cron>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCronJob(organisation, application, environment, cron, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CronApi.getCronJob']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get a cron run
         * @param {string} organisation The organisation ID
         * @param {string} application The application ID
         * @param {string} environment The environment ID
         * @param {string} cron The cron job ID
         * @param {string} run The cron run ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCronRun(organisation: string, application: string, environment: string, cron: string, run: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CronRun>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCronRun(organisation, application, environment, cron, run, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CronApi.getCronRun']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get all runs for a cron job
         * @param {string} organisation The organisation ID
         * @param {string} application The application ID
         * @param {string} environment The environment ID
         * @param {string} cron The cron job ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listCronJobRuns(organisation: string, application: string, environment: string, cron: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<CronRun>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listCronJobRuns(organisation, application, environment, cron, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CronApi.listCronJobRuns']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get all cron jobs for an environment
         * @param {string} organisation The organisation ID
         * @param {string} application The application ID
         * @param {string} environment The environment ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listCronJobs(organisation: string, application: string, environment: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Cron>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listCronJobs(organisation, application, environment, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CronApi.listCronJobs']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update a cron job
         * @param {string} organisation The organisation ID
         * @param {string} application The application ID
         * @param {string} environment The environment ID
         * @param {string} cron The cron job ID
         * @param {UpdateCronJobRequest} updateCronJobRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateCronJob(organisation: string, application: string, environment: string, cron: string, updateCronJobRequest: UpdateCronJobRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Cron>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateCronJob(organisation, application, environment, cron, updateCronJobRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CronApi.updateCronJob']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * CronApi - factory interface
 * @export
 */
export const CronApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CronApiFp(configuration)
    return {
        /**
         * 
         * @summary Create a new cron job
         * @param {string} organisation The organisation ID
         * @param {string} application The application ID
         * @param {string} environment The environment ID
         * @param {CreateCronJobRequest} createCronJobRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCronJob(organisation: string, application: string, environment: string, createCronJobRequest: CreateCronJobRequest, options?: RawAxiosRequestConfig): AxiosPromise<Cron> {
            return localVarFp.createCronJob(organisation, application, environment, createCronJobRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete a cron job
         * @param {string} organisation The organisation ID
         * @param {string} application The application ID
         * @param {string} environment The environment ID
         * @param {string} cron The cron job ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCronJob(organisation: string, application: string, environment: string, cron: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteCronJob(organisation, application, environment, cron, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a cron job
         * @param {string} organisation The organisation ID
         * @param {string} application The application ID
         * @param {string} environment The environment ID
         * @param {string} cron The cron job ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCronJob(organisation: string, application: string, environment: string, cron: string, options?: RawAxiosRequestConfig): AxiosPromise<Cron> {
            return localVarFp.getCronJob(organisation, application, environment, cron, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a cron run
         * @param {string} organisation The organisation ID
         * @param {string} application The application ID
         * @param {string} environment The environment ID
         * @param {string} cron The cron job ID
         * @param {string} run The cron run ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCronRun(organisation: string, application: string, environment: string, cron: string, run: string, options?: RawAxiosRequestConfig): AxiosPromise<CronRun> {
            return localVarFp.getCronRun(organisation, application, environment, cron, run, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get all runs for a cron job
         * @param {string} organisation The organisation ID
         * @param {string} application The application ID
         * @param {string} environment The environment ID
         * @param {string} cron The cron job ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listCronJobRuns(organisation: string, application: string, environment: string, cron: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<CronRun>> {
            return localVarFp.listCronJobRuns(organisation, application, environment, cron, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get all cron jobs for an environment
         * @param {string} organisation The organisation ID
         * @param {string} application The application ID
         * @param {string} environment The environment ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listCronJobs(organisation: string, application: string, environment: string, options?: RawAxiosRequestConfig): AxiosPromise<Cron> {
            return localVarFp.listCronJobs(organisation, application, environment, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update a cron job
         * @param {string} organisation The organisation ID
         * @param {string} application The application ID
         * @param {string} environment The environment ID
         * @param {string} cron The cron job ID
         * @param {UpdateCronJobRequest} updateCronJobRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCronJob(organisation: string, application: string, environment: string, cron: string, updateCronJobRequest: UpdateCronJobRequest, options?: RawAxiosRequestConfig): AxiosPromise<Cron> {
            return localVarFp.updateCronJob(organisation, application, environment, cron, updateCronJobRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * CronApi - object-oriented interface
 * @export
 * @class CronApi
 * @extends {BaseAPI}
 */
export class CronApi extends BaseAPI {
    /**
     * 
     * @summary Create a new cron job
     * @param {string} organisation The organisation ID
     * @param {string} application The application ID
     * @param {string} environment The environment ID
     * @param {CreateCronJobRequest} createCronJobRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CronApi
     */
    public createCronJob(organisation: string, application: string, environment: string, createCronJobRequest: CreateCronJobRequest, options?: RawAxiosRequestConfig) {
        return CronApiFp(this.configuration).createCronJob(organisation, application, environment, createCronJobRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete a cron job
     * @param {string} organisation The organisation ID
     * @param {string} application The application ID
     * @param {string} environment The environment ID
     * @param {string} cron The cron job ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CronApi
     */
    public deleteCronJob(organisation: string, application: string, environment: string, cron: string, options?: RawAxiosRequestConfig) {
        return CronApiFp(this.configuration).deleteCronJob(organisation, application, environment, cron, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a cron job
     * @param {string} organisation The organisation ID
     * @param {string} application The application ID
     * @param {string} environment The environment ID
     * @param {string} cron The cron job ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CronApi
     */
    public getCronJob(organisation: string, application: string, environment: string, cron: string, options?: RawAxiosRequestConfig) {
        return CronApiFp(this.configuration).getCronJob(organisation, application, environment, cron, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a cron run
     * @param {string} organisation The organisation ID
     * @param {string} application The application ID
     * @param {string} environment The environment ID
     * @param {string} cron The cron job ID
     * @param {string} run The cron run ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CronApi
     */
    public getCronRun(organisation: string, application: string, environment: string, cron: string, run: string, options?: RawAxiosRequestConfig) {
        return CronApiFp(this.configuration).getCronRun(organisation, application, environment, cron, run, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get all runs for a cron job
     * @param {string} organisation The organisation ID
     * @param {string} application The application ID
     * @param {string} environment The environment ID
     * @param {string} cron The cron job ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CronApi
     */
    public listCronJobRuns(organisation: string, application: string, environment: string, cron: string, options?: RawAxiosRequestConfig) {
        return CronApiFp(this.configuration).listCronJobRuns(organisation, application, environment, cron, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get all cron jobs for an environment
     * @param {string} organisation The organisation ID
     * @param {string} application The application ID
     * @param {string} environment The environment ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CronApi
     */
    public listCronJobs(organisation: string, application: string, environment: string, options?: RawAxiosRequestConfig) {
        return CronApiFp(this.configuration).listCronJobs(organisation, application, environment, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update a cron job
     * @param {string} organisation The organisation ID
     * @param {string} application The application ID
     * @param {string} environment The environment ID
     * @param {string} cron The cron job ID
     * @param {UpdateCronJobRequest} updateCronJobRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CronApi
     */
    public updateCronJob(organisation: string, application: string, environment: string, cron: string, updateCronJobRequest: UpdateCronJobRequest, options?: RawAxiosRequestConfig) {
        return CronApiFp(this.configuration).updateCronJob(organisation, application, environment, cron, updateCronJobRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * DomainsApi - axios parameter creator
 * @export
 */
export const DomainsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Add a new domain
         * @param {string} organization Organization identifier
         * @param {string} project Project identifier
         * @param {V2DomainRequest} v2DomainRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        domainsCreate: async (organization: string, project: string, v2DomainRequest: V2DomainRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organization' is not null or undefined
            assertParamExists('domainsCreate', 'organization', organization)
            // verify required parameter 'project' is not null or undefined
            assertParamExists('domainsCreate', 'project', project)
            // verify required parameter 'v2DomainRequest' is not null or undefined
            assertParamExists('domainsCreate', 'v2DomainRequest', v2DomainRequest)
            const localVarPath = `/api/v2/organizations/{organization}/projects/{project}/domains`
                .replace(`{${"organization"}}`, encodeURIComponent(String(organization)))
                .replace(`{${"project"}}`, encodeURIComponent(String(project)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(v2DomainRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a domain
         * @param {string} organization Organization identifier
         * @param {string} project Project identifier
         * @param {string} domain 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        domainsDelete: async (organization: string, project: string, domain: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organization' is not null or undefined
            assertParamExists('domainsDelete', 'organization', organization)
            // verify required parameter 'project' is not null or undefined
            assertParamExists('domainsDelete', 'project', project)
            // verify required parameter 'domain' is not null or undefined
            assertParamExists('domainsDelete', 'domain', domain)
            const localVarPath = `/api/v2/organizations/{organization}/projects/{project}/domains/{domain}`
                .replace(`{${"organization"}}`, encodeURIComponent(String(organization)))
                .replace(`{${"project"}}`, encodeURIComponent(String(project)))
                .replace(`{${"domain"}}`, encodeURIComponent(String(domain)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List all domains for a project
         * @param {string} organization Organization identifier
         * @param {string} project Project identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        domainsList: async (organization: string, project: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organization' is not null or undefined
            assertParamExists('domainsList', 'organization', organization)
            // verify required parameter 'project' is not null or undefined
            assertParamExists('domainsList', 'project', project)
            const localVarPath = `/api/v2/organizations/{organization}/projects/{project}/domains`
                .replace(`{${"organization"}}`, encodeURIComponent(String(organization)))
                .replace(`{${"project"}}`, encodeURIComponent(String(project)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get details of a single domain
         * @param {string} organization Organization identifier
         * @param {string} project Project identifier
         * @param {string} domain 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        domainsRead: async (organization: string, project: string, domain: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organization' is not null or undefined
            assertParamExists('domainsRead', 'organization', organization)
            // verify required parameter 'project' is not null or undefined
            assertParamExists('domainsRead', 'project', project)
            // verify required parameter 'domain' is not null or undefined
            assertParamExists('domainsRead', 'domain', domain)
            const localVarPath = `/api/v2/organizations/{organization}/projects/{project}/domains/{domain}`
                .replace(`{${"organization"}}`, encodeURIComponent(String(organization)))
                .replace(`{${"project"}}`, encodeURIComponent(String(project)))
                .replace(`{${"domain"}}`, encodeURIComponent(String(domain)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Renew the SSL certificate for a domain
         * @param {string} organization Organization identifier
         * @param {string} project Project identifier
         * @param {string} domain Domain identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        domainsRenew: async (organization: string, project: string, domain: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organization' is not null or undefined
            assertParamExists('domainsRenew', 'organization', organization)
            // verify required parameter 'project' is not null or undefined
            assertParamExists('domainsRenew', 'project', project)
            // verify required parameter 'domain' is not null or undefined
            assertParamExists('domainsRenew', 'domain', domain)
            const localVarPath = `/api/v2/organizations/{organization}/projects/{project}/domains/{domain}/renew`
                .replace(`{${"organization"}}`, encodeURIComponent(String(organization)))
                .replace(`{${"project"}}`, encodeURIComponent(String(project)))
                .replace(`{${"domain"}}`, encodeURIComponent(String(domain)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DomainsApi - functional programming interface
 * @export
 */
export const DomainsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DomainsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Add a new domain
         * @param {string} organization Organization identifier
         * @param {string} project Project identifier
         * @param {V2DomainRequest} v2DomainRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async domainsCreate(organization: string, project: string, v2DomainRequest: V2DomainRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<V2Domain>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.domainsCreate(organization, project, v2DomainRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DomainsApi.domainsCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete a domain
         * @param {string} organization Organization identifier
         * @param {string} project Project identifier
         * @param {string} domain 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async domainsDelete(organization: string, project: string, domain: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.domainsDelete(organization, project, domain, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DomainsApi.domainsDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary List all domains for a project
         * @param {string} organization Organization identifier
         * @param {string} project Project identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async domainsList(organization: string, project: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<V2Domain>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.domainsList(organization, project, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DomainsApi.domainsList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get details of a single domain
         * @param {string} organization Organization identifier
         * @param {string} project Project identifier
         * @param {string} domain 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async domainsRead(organization: string, project: string, domain: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<V2Domain>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.domainsRead(organization, project, domain, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DomainsApi.domainsRead']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Renew the SSL certificate for a domain
         * @param {string} organization Organization identifier
         * @param {string} project Project identifier
         * @param {string} domain Domain identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async domainsRenew(organization: string, project: string, domain: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.domainsRenew(organization, project, domain, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DomainsApi.domainsRenew']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * DomainsApi - factory interface
 * @export
 */
export const DomainsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DomainsApiFp(configuration)
    return {
        /**
         * 
         * @summary Add a new domain
         * @param {string} organization Organization identifier
         * @param {string} project Project identifier
         * @param {V2DomainRequest} v2DomainRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        domainsCreate(organization: string, project: string, v2DomainRequest: V2DomainRequest, options?: RawAxiosRequestConfig): AxiosPromise<V2Domain> {
            return localVarFp.domainsCreate(organization, project, v2DomainRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete a domain
         * @param {string} organization Organization identifier
         * @param {string} project Project identifier
         * @param {string} domain 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        domainsDelete(organization: string, project: string, domain: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.domainsDelete(organization, project, domain, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List all domains for a project
         * @param {string} organization Organization identifier
         * @param {string} project Project identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        domainsList(organization: string, project: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<V2Domain>> {
            return localVarFp.domainsList(organization, project, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get details of a single domain
         * @param {string} organization Organization identifier
         * @param {string} project Project identifier
         * @param {string} domain 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        domainsRead(organization: string, project: string, domain: string, options?: RawAxiosRequestConfig): AxiosPromise<V2Domain> {
            return localVarFp.domainsRead(organization, project, domain, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Renew the SSL certificate for a domain
         * @param {string} organization Organization identifier
         * @param {string} project Project identifier
         * @param {string} domain Domain identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        domainsRenew(organization: string, project: string, domain: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.domainsRenew(organization, project, domain, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DomainsApi - object-oriented interface
 * @export
 * @class DomainsApi
 * @extends {BaseAPI}
 */
export class DomainsApi extends BaseAPI {
    /**
     * 
     * @summary Add a new domain
     * @param {string} organization Organization identifier
     * @param {string} project Project identifier
     * @param {V2DomainRequest} v2DomainRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DomainsApi
     */
    public domainsCreate(organization: string, project: string, v2DomainRequest: V2DomainRequest, options?: RawAxiosRequestConfig) {
        return DomainsApiFp(this.configuration).domainsCreate(organization, project, v2DomainRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete a domain
     * @param {string} organization Organization identifier
     * @param {string} project Project identifier
     * @param {string} domain 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DomainsApi
     */
    public domainsDelete(organization: string, project: string, domain: string, options?: RawAxiosRequestConfig) {
        return DomainsApiFp(this.configuration).domainsDelete(organization, project, domain, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List all domains for a project
     * @param {string} organization Organization identifier
     * @param {string} project Project identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DomainsApi
     */
    public domainsList(organization: string, project: string, options?: RawAxiosRequestConfig) {
        return DomainsApiFp(this.configuration).domainsList(organization, project, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get details of a single domain
     * @param {string} organization Organization identifier
     * @param {string} project Project identifier
     * @param {string} domain 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DomainsApi
     */
    public domainsRead(organization: string, project: string, domain: string, options?: RawAxiosRequestConfig) {
        return DomainsApiFp(this.configuration).domainsRead(organization, project, domain, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Renew the SSL certificate for a domain
     * @param {string} organization Organization identifier
     * @param {string} project Project identifier
     * @param {string} domain Domain identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DomainsApi
     */
    public domainsRenew(organization: string, project: string, domain: string, options?: RawAxiosRequestConfig) {
        return DomainsApiFp(this.configuration).domainsRenew(organization, project, domain, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * EnvironmentsApi - axios parameter creator
 * @export
 */
export const EnvironmentsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create a new environment
         * @param {string} organisation The organisation ID
         * @param {string} application The application ID
         * @param {CreateEnvironmentRequest} createEnvironmentRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createEnvironment: async (organisation: string, application: string, createEnvironmentRequest: CreateEnvironmentRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organisation' is not null or undefined
            assertParamExists('createEnvironment', 'organisation', organisation)
            // verify required parameter 'application' is not null or undefined
            assertParamExists('createEnvironment', 'application', application)
            // verify required parameter 'createEnvironmentRequest' is not null or undefined
            assertParamExists('createEnvironment', 'createEnvironmentRequest', createEnvironmentRequest)
            const localVarPath = `/api/v3/organizations/{organisation}/applications/{application}/environments`
                .replace(`{${"organisation"}}`, encodeURIComponent(String(organisation)))
                .replace(`{${"application"}}`, encodeURIComponent(String(application)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createEnvironmentRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete an environment
         * @param {string} organisation The organisation ID
         * @param {string} application The application ID
         * @param {string} environment The environment ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteEnvironment: async (organisation: string, application: string, environment: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organisation' is not null or undefined
            assertParamExists('deleteEnvironment', 'organisation', organisation)
            // verify required parameter 'application' is not null or undefined
            assertParamExists('deleteEnvironment', 'application', application)
            // verify required parameter 'environment' is not null or undefined
            assertParamExists('deleteEnvironment', 'environment', environment)
            const localVarPath = `/api/v3/organizations/{organisation}/applications/{application}/environments/{environment}`
                .replace(`{${"organisation"}}`, encodeURIComponent(String(organisation)))
                .replace(`{${"application"}}`, encodeURIComponent(String(application)))
                .replace(`{${"environment"}}`, encodeURIComponent(String(environment)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a single environment
         * @param {string} organisation The organisation ID
         * @param {string} application The application ID
         * @param {string} environment The environment ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEnvironment: async (organisation: string, application: string, environment: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organisation' is not null or undefined
            assertParamExists('getEnvironment', 'organisation', organisation)
            // verify required parameter 'application' is not null or undefined
            assertParamExists('getEnvironment', 'application', application)
            // verify required parameter 'environment' is not null or undefined
            assertParamExists('getEnvironment', 'environment', environment)
            const localVarPath = `/api/v3/organizations/{organisation}/applications/{application}/environments/{environment}`
                .replace(`{${"organisation"}}`, encodeURIComponent(String(organisation)))
                .replace(`{${"application"}}`, encodeURIComponent(String(application)))
                .replace(`{${"environment"}}`, encodeURIComponent(String(environment)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves logs from CloudWatch for the specified environment with optional filtering by time range, container, and pattern matching. Supports pagination via nextToken.
         * @summary Get the logs for an environment
         * @param {string} organisation The organisation ID
         * @param {string} application The application ID
         * @param {string} environment The environment ID
         * @param {string} [startTime] Start time for log retrieval (ISO 8601 format or Unix timestamp)
         * @param {string} [endTime] End time for log retrieval (ISO 8601 format or Unix timestamp)
         * @param {string} [containerName] Filter logs by specific container name
         * @param {string} [filterPattern] CloudWatch Logs filter pattern for searching log content
         * @param {number} [limit] Maximum number of log entries to return per page
         * @param {string} [nextToken] Pagination token from previous response for retrieving next page of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEnvironmentLogs: async (organisation: string, application: string, environment: string, startTime?: string, endTime?: string, containerName?: string, filterPattern?: string, limit?: number, nextToken?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organisation' is not null or undefined
            assertParamExists('getEnvironmentLogs', 'organisation', organisation)
            // verify required parameter 'application' is not null or undefined
            assertParamExists('getEnvironmentLogs', 'application', application)
            // verify required parameter 'environment' is not null or undefined
            assertParamExists('getEnvironmentLogs', 'environment', environment)
            const localVarPath = `/api/v3/organizations/{organisation}/applications/{application}/environments/{environment}/logs`
                .replace(`{${"organisation"}}`, encodeURIComponent(String(organisation)))
                .replace(`{${"application"}}`, encodeURIComponent(String(application)))
                .replace(`{${"environment"}}`, encodeURIComponent(String(environment)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (startTime !== undefined) {
                localVarQueryParameter['startTime'] = startTime;
            }

            if (endTime !== undefined) {
                localVarQueryParameter['endTime'] = endTime;
            }

            if (containerName !== undefined) {
                localVarQueryParameter['containerName'] = containerName;
            }

            if (filterPattern !== undefined) {
                localVarQueryParameter['filterPattern'] = filterPattern;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (nextToken !== undefined) {
                localVarQueryParameter['nextToken'] = nextToken;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves CloudWatch metrics for the specified environment with optional filtering by time range, container, and metric configuration.
         * @summary Get the metrics for an environment
         * @param {string} organisation The organisation ID
         * @param {string} application The application ID
         * @param {string} environment The environment ID
         * @param {number} [startTime] Start time for metrics retrieval (Unix timestamp in milliseconds)
         * @param {number} [endTime] End time for metrics retrieval (Unix timestamp in milliseconds)
         * @param {number} [period] Period in seconds for metric aggregation (e.g., 60 for 1 minute, 300 for 5 minutes)
         * @param {string} [statistics] Comma-separated list of CloudWatch statistics (e.g., Average, Maximum, Minimum, Sum, SampleCount)
         * @param {string} [containerName] Filter metrics by specific container name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEnvironmentMetrics: async (organisation: string, application: string, environment: string, startTime?: number, endTime?: number, period?: number, statistics?: string, containerName?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organisation' is not null or undefined
            assertParamExists('getEnvironmentMetrics', 'organisation', organisation)
            // verify required parameter 'application' is not null or undefined
            assertParamExists('getEnvironmentMetrics', 'application', application)
            // verify required parameter 'environment' is not null or undefined
            assertParamExists('getEnvironmentMetrics', 'environment', environment)
            const localVarPath = `/api/v3/organizations/{organisation}/applications/{application}/environments/{environment}/metrics`
                .replace(`{${"organisation"}}`, encodeURIComponent(String(organisation)))
                .replace(`{${"application"}}`, encodeURIComponent(String(application)))
                .replace(`{${"environment"}}`, encodeURIComponent(String(environment)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (startTime !== undefined) {
                localVarQueryParameter['startTime'] = startTime;
            }

            if (endTime !== undefined) {
                localVarQueryParameter['endTime'] = endTime;
            }

            if (period !== undefined) {
                localVarQueryParameter['period'] = period;
            }

            if (statistics !== undefined) {
                localVarQueryParameter['statistics'] = statistics;
            }

            if (containerName !== undefined) {
                localVarQueryParameter['containerName'] = containerName;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get all environments for an application
         * @param {string} organisation The organisation ID
         * @param {string} application The application ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listEnvironments: async (organisation: string, application: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organisation' is not null or undefined
            assertParamExists('listEnvironments', 'organisation', organisation)
            // verify required parameter 'application' is not null or undefined
            assertParamExists('listEnvironments', 'application', application)
            const localVarPath = `/api/v3/organizations/{organisation}/applications/{application}/environments`
                .replace(`{${"organisation"}}`, encodeURIComponent(String(organisation)))
                .replace(`{${"application"}}`, encodeURIComponent(String(application)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List the sync operations for an environment
         * @param {string} organisation The organisation ID
         * @param {string} application The application ID
         * @param {string} environment The environment ID
         * @param {ListSyncOperationsTypeEnum} type The sync type
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSyncOperations: async (organisation: string, application: string, environment: string, type: ListSyncOperationsTypeEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organisation' is not null or undefined
            assertParamExists('listSyncOperations', 'organisation', organisation)
            // verify required parameter 'application' is not null or undefined
            assertParamExists('listSyncOperations', 'application', application)
            // verify required parameter 'environment' is not null or undefined
            assertParamExists('listSyncOperations', 'environment', environment)
            // verify required parameter 'type' is not null or undefined
            assertParamExists('listSyncOperations', 'type', type)
            const localVarPath = `/api/v3/organizations/{organisation}/applications/{application}/environments/{environment}/sync/{type}`
                .replace(`{${"organisation"}}`, encodeURIComponent(String(organisation)))
                .replace(`{${"application"}}`, encodeURIComponent(String(application)))
                .replace(`{${"environment"}}`, encodeURIComponent(String(environment)))
                .replace(`{${"type"}}`, encodeURIComponent(String(type)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Perform a sync operation from a source environment to the current environment
         * @param {string} organisation The organisation ID
         * @param {string} application The application ID
         * @param {string} environment The environment ID
         * @param {SyncToEnvironmentTypeEnum} type The sync type
         * @param {SyncToEnvironmentRequest} syncToEnvironmentRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        syncToEnvironment: async (organisation: string, application: string, environment: string, type: SyncToEnvironmentTypeEnum, syncToEnvironmentRequest: SyncToEnvironmentRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organisation' is not null or undefined
            assertParamExists('syncToEnvironment', 'organisation', organisation)
            // verify required parameter 'application' is not null or undefined
            assertParamExists('syncToEnvironment', 'application', application)
            // verify required parameter 'environment' is not null or undefined
            assertParamExists('syncToEnvironment', 'environment', environment)
            // verify required parameter 'type' is not null or undefined
            assertParamExists('syncToEnvironment', 'type', type)
            // verify required parameter 'syncToEnvironmentRequest' is not null or undefined
            assertParamExists('syncToEnvironment', 'syncToEnvironmentRequest', syncToEnvironmentRequest)
            const localVarPath = `/api/v3/organizations/{organisation}/applications/{application}/environments/{environment}/sync/{type}`
                .replace(`{${"organisation"}}`, encodeURIComponent(String(organisation)))
                .replace(`{${"application"}}`, encodeURIComponent(String(application)))
                .replace(`{${"environment"}}`, encodeURIComponent(String(environment)))
                .replace(`{${"type"}}`, encodeURIComponent(String(type)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(syncToEnvironmentRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Replaces the entire task definition for the environment based on the provided multi-container compose definition. This will create a new task definition revision and update the ECS service, triggering a redeployment. Optionally accepts minCapacity and maxCapacity at the root level for convenience.
         * @summary Update Environment Compose Definition
         * @param {string} organisation The organisation ID
         * @param {string} application The application ID
         * @param {string} environment The environment ID
         * @param {UpdateEnvironmentRequest} updateEnvironmentRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateEnvironment: async (organisation: string, application: string, environment: string, updateEnvironmentRequest: UpdateEnvironmentRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organisation' is not null or undefined
            assertParamExists('updateEnvironment', 'organisation', organisation)
            // verify required parameter 'application' is not null or undefined
            assertParamExists('updateEnvironment', 'application', application)
            // verify required parameter 'environment' is not null or undefined
            assertParamExists('updateEnvironment', 'environment', environment)
            // verify required parameter 'updateEnvironmentRequest' is not null or undefined
            assertParamExists('updateEnvironment', 'updateEnvironmentRequest', updateEnvironmentRequest)
            const localVarPath = `/api/v3/organizations/{organisation}/applications/{application}/environments/{environment}`
                .replace(`{${"organisation"}}`, encodeURIComponent(String(organisation)))
                .replace(`{${"application"}}`, encodeURIComponent(String(application)))
                .replace(`{${"environment"}}`, encodeURIComponent(String(environment)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateEnvironmentRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update the state of an environment
         * @param {string} organisation The organisation ID
         * @param {string} application The application ID
         * @param {string} environment The environment ID
         * @param {UpdateEnvironmentStateRequest} updateEnvironmentStateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateEnvironmentState: async (organisation: string, application: string, environment: string, updateEnvironmentStateRequest: UpdateEnvironmentStateRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organisation' is not null or undefined
            assertParamExists('updateEnvironmentState', 'organisation', organisation)
            // verify required parameter 'application' is not null or undefined
            assertParamExists('updateEnvironmentState', 'application', application)
            // verify required parameter 'environment' is not null or undefined
            assertParamExists('updateEnvironmentState', 'environment', environment)
            // verify required parameter 'updateEnvironmentStateRequest' is not null or undefined
            assertParamExists('updateEnvironmentState', 'updateEnvironmentStateRequest', updateEnvironmentStateRequest)
            const localVarPath = `/api/v3/organizations/{organisation}/applications/{application}/environments/{environment}/state`
                .replace(`{${"organisation"}}`, encodeURIComponent(String(organisation)))
                .replace(`{${"application"}}`, encodeURIComponent(String(application)))
                .replace(`{${"environment"}}`, encodeURIComponent(String(environment)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateEnvironmentStateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * EnvironmentsApi - functional programming interface
 * @export
 */
export const EnvironmentsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = EnvironmentsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Create a new environment
         * @param {string} organisation The organisation ID
         * @param {string} application The application ID
         * @param {CreateEnvironmentRequest} createEnvironmentRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createEnvironment(organisation: string, application: string, createEnvironmentRequest: CreateEnvironmentRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Environment>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createEnvironment(organisation, application, createEnvironmentRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EnvironmentsApi.createEnvironment']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete an environment
         * @param {string} organisation The organisation ID
         * @param {string} application The application ID
         * @param {string} environment The environment ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteEnvironment(organisation: string, application: string, environment: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteEnvironment(organisation, application, environment, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EnvironmentsApi.deleteEnvironment']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get a single environment
         * @param {string} organisation The organisation ID
         * @param {string} application The application ID
         * @param {string} environment The environment ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getEnvironment(organisation: string, application: string, environment: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Environment>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getEnvironment(organisation, application, environment, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EnvironmentsApi.getEnvironment']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieves logs from CloudWatch for the specified environment with optional filtering by time range, container, and pattern matching. Supports pagination via nextToken.
         * @summary Get the logs for an environment
         * @param {string} organisation The organisation ID
         * @param {string} application The application ID
         * @param {string} environment The environment ID
         * @param {string} [startTime] Start time for log retrieval (ISO 8601 format or Unix timestamp)
         * @param {string} [endTime] End time for log retrieval (ISO 8601 format or Unix timestamp)
         * @param {string} [containerName] Filter logs by specific container name
         * @param {string} [filterPattern] CloudWatch Logs filter pattern for searching log content
         * @param {number} [limit] Maximum number of log entries to return per page
         * @param {string} [nextToken] Pagination token from previous response for retrieving next page of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getEnvironmentLogs(organisation: string, application: string, environment: string, startTime?: string, endTime?: string, containerName?: string, filterPattern?: string, limit?: number, nextToken?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetEnvironmentLogs200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getEnvironmentLogs(organisation, application, environment, startTime, endTime, containerName, filterPattern, limit, nextToken, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EnvironmentsApi.getEnvironmentLogs']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieves CloudWatch metrics for the specified environment with optional filtering by time range, container, and metric configuration.
         * @summary Get the metrics for an environment
         * @param {string} organisation The organisation ID
         * @param {string} application The application ID
         * @param {string} environment The environment ID
         * @param {number} [startTime] Start time for metrics retrieval (Unix timestamp in milliseconds)
         * @param {number} [endTime] End time for metrics retrieval (Unix timestamp in milliseconds)
         * @param {number} [period] Period in seconds for metric aggregation (e.g., 60 for 1 minute, 300 for 5 minutes)
         * @param {string} [statistics] Comma-separated list of CloudWatch statistics (e.g., Average, Maximum, Minimum, Sum, SampleCount)
         * @param {string} [containerName] Filter metrics by specific container name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getEnvironmentMetrics(organisation: string, application: string, environment: string, startTime?: number, endTime?: number, period?: number, statistics?: string, containerName?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getEnvironmentMetrics(organisation, application, environment, startTime, endTime, period, statistics, containerName, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EnvironmentsApi.getEnvironmentMetrics']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get all environments for an application
         * @param {string} organisation The organisation ID
         * @param {string} application The application ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listEnvironments(organisation: string, application: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Environment>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listEnvironments(organisation, application, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EnvironmentsApi.listEnvironments']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary List the sync operations for an environment
         * @param {string} organisation The organisation ID
         * @param {string} application The application ID
         * @param {string} environment The environment ID
         * @param {ListSyncOperationsTypeEnum} type The sync type
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listSyncOperations(organisation: string, application: string, environment: string, type: ListSyncOperationsTypeEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<SyncOperation>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listSyncOperations(organisation, application, environment, type, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EnvironmentsApi.listSyncOperations']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Perform a sync operation from a source environment to the current environment
         * @param {string} organisation The organisation ID
         * @param {string} application The application ID
         * @param {string} environment The environment ID
         * @param {SyncToEnvironmentTypeEnum} type The sync type
         * @param {SyncToEnvironmentRequest} syncToEnvironmentRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async syncToEnvironment(organisation: string, application: string, environment: string, type: SyncToEnvironmentTypeEnum, syncToEnvironmentRequest: SyncToEnvironmentRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SyncOperation>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.syncToEnvironment(organisation, application, environment, type, syncToEnvironmentRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EnvironmentsApi.syncToEnvironment']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Replaces the entire task definition for the environment based on the provided multi-container compose definition. This will create a new task definition revision and update the ECS service, triggering a redeployment. Optionally accepts minCapacity and maxCapacity at the root level for convenience.
         * @summary Update Environment Compose Definition
         * @param {string} organisation The organisation ID
         * @param {string} application The application ID
         * @param {string} environment The environment ID
         * @param {UpdateEnvironmentRequest} updateEnvironmentRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateEnvironment(organisation: string, application: string, environment: string, updateEnvironmentRequest: UpdateEnvironmentRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateEnvironment(organisation, application, environment, updateEnvironmentRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EnvironmentsApi.updateEnvironment']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update the state of an environment
         * @param {string} organisation The organisation ID
         * @param {string} application The application ID
         * @param {string} environment The environment ID
         * @param {UpdateEnvironmentStateRequest} updateEnvironmentStateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateEnvironmentState(organisation: string, application: string, environment: string, updateEnvironmentStateRequest: UpdateEnvironmentStateRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateEnvironmentState(organisation, application, environment, updateEnvironmentStateRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EnvironmentsApi.updateEnvironmentState']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * EnvironmentsApi - factory interface
 * @export
 */
export const EnvironmentsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = EnvironmentsApiFp(configuration)
    return {
        /**
         * 
         * @summary Create a new environment
         * @param {string} organisation The organisation ID
         * @param {string} application The application ID
         * @param {CreateEnvironmentRequest} createEnvironmentRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createEnvironment(organisation: string, application: string, createEnvironmentRequest: CreateEnvironmentRequest, options?: RawAxiosRequestConfig): AxiosPromise<Environment> {
            return localVarFp.createEnvironment(organisation, application, createEnvironmentRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete an environment
         * @param {string} organisation The organisation ID
         * @param {string} application The application ID
         * @param {string} environment The environment ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteEnvironment(organisation: string, application: string, environment: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteEnvironment(organisation, application, environment, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a single environment
         * @param {string} organisation The organisation ID
         * @param {string} application The application ID
         * @param {string} environment The environment ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEnvironment(organisation: string, application: string, environment: string, options?: RawAxiosRequestConfig): AxiosPromise<Environment> {
            return localVarFp.getEnvironment(organisation, application, environment, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves logs from CloudWatch for the specified environment with optional filtering by time range, container, and pattern matching. Supports pagination via nextToken.
         * @summary Get the logs for an environment
         * @param {string} organisation The organisation ID
         * @param {string} application The application ID
         * @param {string} environment The environment ID
         * @param {string} [startTime] Start time for log retrieval (ISO 8601 format or Unix timestamp)
         * @param {string} [endTime] End time for log retrieval (ISO 8601 format or Unix timestamp)
         * @param {string} [containerName] Filter logs by specific container name
         * @param {string} [filterPattern] CloudWatch Logs filter pattern for searching log content
         * @param {number} [limit] Maximum number of log entries to return per page
         * @param {string} [nextToken] Pagination token from previous response for retrieving next page of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEnvironmentLogs(organisation: string, application: string, environment: string, startTime?: string, endTime?: string, containerName?: string, filterPattern?: string, limit?: number, nextToken?: string, options?: RawAxiosRequestConfig): AxiosPromise<GetEnvironmentLogs200Response> {
            return localVarFp.getEnvironmentLogs(organisation, application, environment, startTime, endTime, containerName, filterPattern, limit, nextToken, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves CloudWatch metrics for the specified environment with optional filtering by time range, container, and metric configuration.
         * @summary Get the metrics for an environment
         * @param {string} organisation The organisation ID
         * @param {string} application The application ID
         * @param {string} environment The environment ID
         * @param {number} [startTime] Start time for metrics retrieval (Unix timestamp in milliseconds)
         * @param {number} [endTime] End time for metrics retrieval (Unix timestamp in milliseconds)
         * @param {number} [period] Period in seconds for metric aggregation (e.g., 60 for 1 minute, 300 for 5 minutes)
         * @param {string} [statistics] Comma-separated list of CloudWatch statistics (e.g., Average, Maximum, Minimum, Sum, SampleCount)
         * @param {string} [containerName] Filter metrics by specific container name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEnvironmentMetrics(organisation: string, application: string, environment: string, startTime?: number, endTime?: number, period?: number, statistics?: string, containerName?: string, options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.getEnvironmentMetrics(organisation, application, environment, startTime, endTime, period, statistics, containerName, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get all environments for an application
         * @param {string} organisation The organisation ID
         * @param {string} application The application ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listEnvironments(organisation: string, application: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<Environment>> {
            return localVarFp.listEnvironments(organisation, application, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List the sync operations for an environment
         * @param {string} organisation The organisation ID
         * @param {string} application The application ID
         * @param {string} environment The environment ID
         * @param {ListSyncOperationsTypeEnum} type The sync type
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSyncOperations(organisation: string, application: string, environment: string, type: ListSyncOperationsTypeEnum, options?: RawAxiosRequestConfig): AxiosPromise<Array<SyncOperation>> {
            return localVarFp.listSyncOperations(organisation, application, environment, type, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Perform a sync operation from a source environment to the current environment
         * @param {string} organisation The organisation ID
         * @param {string} application The application ID
         * @param {string} environment The environment ID
         * @param {SyncToEnvironmentTypeEnum} type The sync type
         * @param {SyncToEnvironmentRequest} syncToEnvironmentRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        syncToEnvironment(organisation: string, application: string, environment: string, type: SyncToEnvironmentTypeEnum, syncToEnvironmentRequest: SyncToEnvironmentRequest, options?: RawAxiosRequestConfig): AxiosPromise<SyncOperation> {
            return localVarFp.syncToEnvironment(organisation, application, environment, type, syncToEnvironmentRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Replaces the entire task definition for the environment based on the provided multi-container compose definition. This will create a new task definition revision and update the ECS service, triggering a redeployment. Optionally accepts minCapacity and maxCapacity at the root level for convenience.
         * @summary Update Environment Compose Definition
         * @param {string} organisation The organisation ID
         * @param {string} application The application ID
         * @param {string} environment The environment ID
         * @param {UpdateEnvironmentRequest} updateEnvironmentRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateEnvironment(organisation: string, application: string, environment: string, updateEnvironmentRequest: UpdateEnvironmentRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.updateEnvironment(organisation, application, environment, updateEnvironmentRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update the state of an environment
         * @param {string} organisation The organisation ID
         * @param {string} application The application ID
         * @param {string} environment The environment ID
         * @param {UpdateEnvironmentStateRequest} updateEnvironmentStateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateEnvironmentState(organisation: string, application: string, environment: string, updateEnvironmentStateRequest: UpdateEnvironmentStateRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.updateEnvironmentState(organisation, application, environment, updateEnvironmentStateRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * EnvironmentsApi - object-oriented interface
 * @export
 * @class EnvironmentsApi
 * @extends {BaseAPI}
 */
export class EnvironmentsApi extends BaseAPI {
    /**
     * 
     * @summary Create a new environment
     * @param {string} organisation The organisation ID
     * @param {string} application The application ID
     * @param {CreateEnvironmentRequest} createEnvironmentRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EnvironmentsApi
     */
    public createEnvironment(organisation: string, application: string, createEnvironmentRequest: CreateEnvironmentRequest, options?: RawAxiosRequestConfig) {
        return EnvironmentsApiFp(this.configuration).createEnvironment(organisation, application, createEnvironmentRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete an environment
     * @param {string} organisation The organisation ID
     * @param {string} application The application ID
     * @param {string} environment The environment ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EnvironmentsApi
     */
    public deleteEnvironment(organisation: string, application: string, environment: string, options?: RawAxiosRequestConfig) {
        return EnvironmentsApiFp(this.configuration).deleteEnvironment(organisation, application, environment, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a single environment
     * @param {string} organisation The organisation ID
     * @param {string} application The application ID
     * @param {string} environment The environment ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EnvironmentsApi
     */
    public getEnvironment(organisation: string, application: string, environment: string, options?: RawAxiosRequestConfig) {
        return EnvironmentsApiFp(this.configuration).getEnvironment(organisation, application, environment, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves logs from CloudWatch for the specified environment with optional filtering by time range, container, and pattern matching. Supports pagination via nextToken.
     * @summary Get the logs for an environment
     * @param {string} organisation The organisation ID
     * @param {string} application The application ID
     * @param {string} environment The environment ID
     * @param {string} [startTime] Start time for log retrieval (ISO 8601 format or Unix timestamp)
     * @param {string} [endTime] End time for log retrieval (ISO 8601 format or Unix timestamp)
     * @param {string} [containerName] Filter logs by specific container name
     * @param {string} [filterPattern] CloudWatch Logs filter pattern for searching log content
     * @param {number} [limit] Maximum number of log entries to return per page
     * @param {string} [nextToken] Pagination token from previous response for retrieving next page of results
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EnvironmentsApi
     */
    public getEnvironmentLogs(organisation: string, application: string, environment: string, startTime?: string, endTime?: string, containerName?: string, filterPattern?: string, limit?: number, nextToken?: string, options?: RawAxiosRequestConfig) {
        return EnvironmentsApiFp(this.configuration).getEnvironmentLogs(organisation, application, environment, startTime, endTime, containerName, filterPattern, limit, nextToken, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves CloudWatch metrics for the specified environment with optional filtering by time range, container, and metric configuration.
     * @summary Get the metrics for an environment
     * @param {string} organisation The organisation ID
     * @param {string} application The application ID
     * @param {string} environment The environment ID
     * @param {number} [startTime] Start time for metrics retrieval (Unix timestamp in milliseconds)
     * @param {number} [endTime] End time for metrics retrieval (Unix timestamp in milliseconds)
     * @param {number} [period] Period in seconds for metric aggregation (e.g., 60 for 1 minute, 300 for 5 minutes)
     * @param {string} [statistics] Comma-separated list of CloudWatch statistics (e.g., Average, Maximum, Minimum, Sum, SampleCount)
     * @param {string} [containerName] Filter metrics by specific container name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EnvironmentsApi
     */
    public getEnvironmentMetrics(organisation: string, application: string, environment: string, startTime?: number, endTime?: number, period?: number, statistics?: string, containerName?: string, options?: RawAxiosRequestConfig) {
        return EnvironmentsApiFp(this.configuration).getEnvironmentMetrics(organisation, application, environment, startTime, endTime, period, statistics, containerName, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get all environments for an application
     * @param {string} organisation The organisation ID
     * @param {string} application The application ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EnvironmentsApi
     */
    public listEnvironments(organisation: string, application: string, options?: RawAxiosRequestConfig) {
        return EnvironmentsApiFp(this.configuration).listEnvironments(organisation, application, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List the sync operations for an environment
     * @param {string} organisation The organisation ID
     * @param {string} application The application ID
     * @param {string} environment The environment ID
     * @param {ListSyncOperationsTypeEnum} type The sync type
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EnvironmentsApi
     */
    public listSyncOperations(organisation: string, application: string, environment: string, type: ListSyncOperationsTypeEnum, options?: RawAxiosRequestConfig) {
        return EnvironmentsApiFp(this.configuration).listSyncOperations(organisation, application, environment, type, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Perform a sync operation from a source environment to the current environment
     * @param {string} organisation The organisation ID
     * @param {string} application The application ID
     * @param {string} environment The environment ID
     * @param {SyncToEnvironmentTypeEnum} type The sync type
     * @param {SyncToEnvironmentRequest} syncToEnvironmentRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EnvironmentsApi
     */
    public syncToEnvironment(organisation: string, application: string, environment: string, type: SyncToEnvironmentTypeEnum, syncToEnvironmentRequest: SyncToEnvironmentRequest, options?: RawAxiosRequestConfig) {
        return EnvironmentsApiFp(this.configuration).syncToEnvironment(organisation, application, environment, type, syncToEnvironmentRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Replaces the entire task definition for the environment based on the provided multi-container compose definition. This will create a new task definition revision and update the ECS service, triggering a redeployment. Optionally accepts minCapacity and maxCapacity at the root level for convenience.
     * @summary Update Environment Compose Definition
     * @param {string} organisation The organisation ID
     * @param {string} application The application ID
     * @param {string} environment The environment ID
     * @param {UpdateEnvironmentRequest} updateEnvironmentRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EnvironmentsApi
     */
    public updateEnvironment(organisation: string, application: string, environment: string, updateEnvironmentRequest: UpdateEnvironmentRequest, options?: RawAxiosRequestConfig) {
        return EnvironmentsApiFp(this.configuration).updateEnvironment(organisation, application, environment, updateEnvironmentRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update the state of an environment
     * @param {string} organisation The organisation ID
     * @param {string} application The application ID
     * @param {string} environment The environment ID
     * @param {UpdateEnvironmentStateRequest} updateEnvironmentStateRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EnvironmentsApi
     */
    public updateEnvironmentState(organisation: string, application: string, environment: string, updateEnvironmentStateRequest: UpdateEnvironmentStateRequest, options?: RawAxiosRequestConfig) {
        return EnvironmentsApiFp(this.configuration).updateEnvironmentState(organisation, application, environment, updateEnvironmentStateRequest, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const ListSyncOperationsTypeEnum = {
    Database: 'database',
    Filesystem: 'filesystem'
} as const;
export type ListSyncOperationsTypeEnum = typeof ListSyncOperationsTypeEnum[keyof typeof ListSyncOperationsTypeEnum];
/**
 * @export
 */
export const SyncToEnvironmentTypeEnum = {
    Database: 'database',
    Filesystem: 'filesystem'
} as const;
export type SyncToEnvironmentTypeEnum = typeof SyncToEnvironmentTypeEnum[keyof typeof SyncToEnvironmentTypeEnum];


/**
 * HeadersApi - axios parameter creator
 * @export
 */
export const HeadersApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create or update custom headers
         * @param {string} organization 
         * @param {string} project 
         * @param {V2CustomHeaderRequest} v2CustomHeaderRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        headersCreate: async (organization: string, project: string, v2CustomHeaderRequest: V2CustomHeaderRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organization' is not null or undefined
            assertParamExists('headersCreate', 'organization', organization)
            // verify required parameter 'project' is not null or undefined
            assertParamExists('headersCreate', 'project', project)
            // verify required parameter 'v2CustomHeaderRequest' is not null or undefined
            assertParamExists('headersCreate', 'v2CustomHeaderRequest', v2CustomHeaderRequest)
            const localVarPath = `/api/v2/organizations/{organization}/projects/{project}/custom-headers`
                .replace(`{${"organization"}}`, encodeURIComponent(String(organization)))
                .replace(`{${"project"}}`, encodeURIComponent(String(project)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(v2CustomHeaderRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete custom headers
         * @param {string} organization 
         * @param {string} project 
         * @param {V2CustomHeaderRequest} v2CustomHeaderRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        headersDelete: async (organization: string, project: string, v2CustomHeaderRequest: V2CustomHeaderRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organization' is not null or undefined
            assertParamExists('headersDelete', 'organization', organization)
            // verify required parameter 'project' is not null or undefined
            assertParamExists('headersDelete', 'project', project)
            // verify required parameter 'v2CustomHeaderRequest' is not null or undefined
            assertParamExists('headersDelete', 'v2CustomHeaderRequest', v2CustomHeaderRequest)
            const localVarPath = `/api/v2/organizations/{organization}/projects/{project}/custom-headers`
                .replace(`{${"organization"}}`, encodeURIComponent(String(organization)))
                .replace(`{${"project"}}`, encodeURIComponent(String(project)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(v2CustomHeaderRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List custom headers for a project
         * @param {string} organization 
         * @param {string} project 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        headersList: async (organization: string, project: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organization' is not null or undefined
            assertParamExists('headersList', 'organization', organization)
            // verify required parameter 'project' is not null or undefined
            assertParamExists('headersList', 'project', project)
            const localVarPath = `/api/v2/organizations/{organization}/projects/{project}/custom-headers`
                .replace(`{${"organization"}}`, encodeURIComponent(String(organization)))
                .replace(`{${"project"}}`, encodeURIComponent(String(project)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * HeadersApi - functional programming interface
 * @export
 */
export const HeadersApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = HeadersApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Create or update custom headers
         * @param {string} organization 
         * @param {string} project 
         * @param {V2CustomHeaderRequest} v2CustomHeaderRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async headersCreate(organization: string, project: string, v2CustomHeaderRequest: V2CustomHeaderRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<{ [key: string]: string; }>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.headersCreate(organization, project, v2CustomHeaderRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['HeadersApi.headersCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete custom headers
         * @param {string} organization 
         * @param {string} project 
         * @param {V2CustomHeaderRequest} v2CustomHeaderRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async headersDelete(organization: string, project: string, v2CustomHeaderRequest: V2CustomHeaderRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.headersDelete(organization, project, v2CustomHeaderRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['HeadersApi.headersDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary List custom headers for a project
         * @param {string} organization 
         * @param {string} project 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async headersList(organization: string, project: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<{ [key: string]: string; }>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.headersList(organization, project, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['HeadersApi.headersList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * HeadersApi - factory interface
 * @export
 */
export const HeadersApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = HeadersApiFp(configuration)
    return {
        /**
         * 
         * @summary Create or update custom headers
         * @param {string} organization 
         * @param {string} project 
         * @param {V2CustomHeaderRequest} v2CustomHeaderRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        headersCreate(organization: string, project: string, v2CustomHeaderRequest: V2CustomHeaderRequest, options?: RawAxiosRequestConfig): AxiosPromise<{ [key: string]: string; }> {
            return localVarFp.headersCreate(organization, project, v2CustomHeaderRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete custom headers
         * @param {string} organization 
         * @param {string} project 
         * @param {V2CustomHeaderRequest} v2CustomHeaderRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        headersDelete(organization: string, project: string, v2CustomHeaderRequest: V2CustomHeaderRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.headersDelete(organization, project, v2CustomHeaderRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List custom headers for a project
         * @param {string} organization 
         * @param {string} project 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        headersList(organization: string, project: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<{ [key: string]: string; }>> {
            return localVarFp.headersList(organization, project, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * HeadersApi - object-oriented interface
 * @export
 * @class HeadersApi
 * @extends {BaseAPI}
 */
export class HeadersApi extends BaseAPI {
    /**
     * 
     * @summary Create or update custom headers
     * @param {string} organization 
     * @param {string} project 
     * @param {V2CustomHeaderRequest} v2CustomHeaderRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HeadersApi
     */
    public headersCreate(organization: string, project: string, v2CustomHeaderRequest: V2CustomHeaderRequest, options?: RawAxiosRequestConfig) {
        return HeadersApiFp(this.configuration).headersCreate(organization, project, v2CustomHeaderRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete custom headers
     * @param {string} organization 
     * @param {string} project 
     * @param {V2CustomHeaderRequest} v2CustomHeaderRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HeadersApi
     */
    public headersDelete(organization: string, project: string, v2CustomHeaderRequest: V2CustomHeaderRequest, options?: RawAxiosRequestConfig) {
        return HeadersApiFp(this.configuration).headersDelete(organization, project, v2CustomHeaderRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List custom headers for a project
     * @param {string} organization 
     * @param {string} project 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HeadersApi
     */
    public headersList(organization: string, project: string, options?: RawAxiosRequestConfig) {
        return HeadersApiFp(this.configuration).headersList(organization, project, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * KVApi - axios parameter creator
 * @export
 */
export const KVApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Add a kv store
         * @param {string} organization 
         * @param {string} project 
         * @param {V2StoreRequest} v2StoreRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        kVCreate: async (organization: string, project: string, v2StoreRequest: V2StoreRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organization' is not null or undefined
            assertParamExists('kVCreate', 'organization', organization)
            // verify required parameter 'project' is not null or undefined
            assertParamExists('kVCreate', 'project', project)
            // verify required parameter 'v2StoreRequest' is not null or undefined
            assertParamExists('kVCreate', 'v2StoreRequest', v2StoreRequest)
            const localVarPath = `/api/v2/organizations/{organization}/projects/{project}/kv`
                .replace(`{${"organization"}}`, encodeURIComponent(String(organization)))
                .replace(`{${"project"}}`, encodeURIComponent(String(project)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(v2StoreRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a kv store
         * @param {string} organization 
         * @param {string} project 
         * @param {string} storeId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        kVDelete: async (organization: string, project: string, storeId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organization' is not null or undefined
            assertParamExists('kVDelete', 'organization', organization)
            // verify required parameter 'project' is not null or undefined
            assertParamExists('kVDelete', 'project', project)
            // verify required parameter 'storeId' is not null or undefined
            assertParamExists('kVDelete', 'storeId', storeId)
            const localVarPath = `/api/v2/organizations/{organization}/projects/{project}/kv/{store_id}`
                .replace(`{${"organization"}}`, encodeURIComponent(String(organization)))
                .replace(`{${"project"}}`, encodeURIComponent(String(project)))
                .replace(`{${"store_id"}}`, encodeURIComponent(String(storeId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Add an item to a kv store
         * @param {string} organization 
         * @param {string} project 
         * @param {string} storeId 
         * @param {V2StoreItemRequest} v2StoreItemRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        kVItemsCreate: async (organization: string, project: string, storeId: string, v2StoreItemRequest: V2StoreItemRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organization' is not null or undefined
            assertParamExists('kVItemsCreate', 'organization', organization)
            // verify required parameter 'project' is not null or undefined
            assertParamExists('kVItemsCreate', 'project', project)
            // verify required parameter 'storeId' is not null or undefined
            assertParamExists('kVItemsCreate', 'storeId', storeId)
            // verify required parameter 'v2StoreItemRequest' is not null or undefined
            assertParamExists('kVItemsCreate', 'v2StoreItemRequest', v2StoreItemRequest)
            const localVarPath = `/api/v2/organizations/{organization}/projects/{project}/kv/{store_id}/items`
                .replace(`{${"organization"}}`, encodeURIComponent(String(organization)))
                .replace(`{${"project"}}`, encodeURIComponent(String(project)))
                .replace(`{${"store_id"}}`, encodeURIComponent(String(storeId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(v2StoreItemRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete an item from a kv store
         * @param {string} organization 
         * @param {string} project 
         * @param {string} storeId 
         * @param {string} key 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        kVItemsDelete: async (organization: string, project: string, storeId: string, key: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organization' is not null or undefined
            assertParamExists('kVItemsDelete', 'organization', organization)
            // verify required parameter 'project' is not null or undefined
            assertParamExists('kVItemsDelete', 'project', project)
            // verify required parameter 'storeId' is not null or undefined
            assertParamExists('kVItemsDelete', 'storeId', storeId)
            // verify required parameter 'key' is not null or undefined
            assertParamExists('kVItemsDelete', 'key', key)
            const localVarPath = `/api/v2/organizations/{organization}/projects/{project}/kv/{store_id}/items/{key}`
                .replace(`{${"organization"}}`, encodeURIComponent(String(organization)))
                .replace(`{${"project"}}`, encodeURIComponent(String(project)))
                .replace(`{${"store_id"}}`, encodeURIComponent(String(storeId)))
                .replace(`{${"key"}}`, encodeURIComponent(String(key)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List items in a kv store
         * @param {string} organization 
         * @param {string} project 
         * @param {string} storeId 
         * @param {string} [cursor] Cursor for pagination
         * @param {number} [limit] Number of items to return
         * @param {string} [search] Search filter for keys
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        kVItemsList: async (organization: string, project: string, storeId: string, cursor?: string, limit?: number, search?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organization' is not null or undefined
            assertParamExists('kVItemsList', 'organization', organization)
            // verify required parameter 'project' is not null or undefined
            assertParamExists('kVItemsList', 'project', project)
            // verify required parameter 'storeId' is not null or undefined
            assertParamExists('kVItemsList', 'storeId', storeId)
            const localVarPath = `/api/v2/organizations/{organization}/projects/{project}/kv/{store_id}/items`
                .replace(`{${"organization"}}`, encodeURIComponent(String(organization)))
                .replace(`{${"project"}}`, encodeURIComponent(String(project)))
                .replace(`{${"store_id"}}`, encodeURIComponent(String(storeId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (cursor !== undefined) {
                localVarQueryParameter['cursor'] = cursor;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get an item from a kv store
         * @param {string} organization 
         * @param {string} project 
         * @param {string} storeId 
         * @param {string} key 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        kVItemsShow: async (organization: string, project: string, storeId: string, key: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organization' is not null or undefined
            assertParamExists('kVItemsShow', 'organization', organization)
            // verify required parameter 'project' is not null or undefined
            assertParamExists('kVItemsShow', 'project', project)
            // verify required parameter 'storeId' is not null or undefined
            assertParamExists('kVItemsShow', 'storeId', storeId)
            // verify required parameter 'key' is not null or undefined
            assertParamExists('kVItemsShow', 'key', key)
            const localVarPath = `/api/v2/organizations/{organization}/projects/{project}/kv/{store_id}/items/{key}`
                .replace(`{${"organization"}}`, encodeURIComponent(String(organization)))
                .replace(`{${"project"}}`, encodeURIComponent(String(project)))
                .replace(`{${"store_id"}}`, encodeURIComponent(String(storeId)))
                .replace(`{${"key"}}`, encodeURIComponent(String(key)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update an item in a kv store
         * @param {string} organization 
         * @param {string} project 
         * @param {string} storeId 
         * @param {string} key 
         * @param {V2StoreItemUpdateRequest} v2StoreItemUpdateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        kVItemsUpdate: async (organization: string, project: string, storeId: string, key: string, v2StoreItemUpdateRequest: V2StoreItemUpdateRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organization' is not null or undefined
            assertParamExists('kVItemsUpdate', 'organization', organization)
            // verify required parameter 'project' is not null or undefined
            assertParamExists('kVItemsUpdate', 'project', project)
            // verify required parameter 'storeId' is not null or undefined
            assertParamExists('kVItemsUpdate', 'storeId', storeId)
            // verify required parameter 'key' is not null or undefined
            assertParamExists('kVItemsUpdate', 'key', key)
            // verify required parameter 'v2StoreItemUpdateRequest' is not null or undefined
            assertParamExists('kVItemsUpdate', 'v2StoreItemUpdateRequest', v2StoreItemUpdateRequest)
            const localVarPath = `/api/v2/organizations/{organization}/projects/{project}/kv/{store_id}/items/{key}`
                .replace(`{${"organization"}}`, encodeURIComponent(String(organization)))
                .replace(`{${"project"}}`, encodeURIComponent(String(project)))
                .replace(`{${"store_id"}}`, encodeURIComponent(String(storeId)))
                .replace(`{${"key"}}`, encodeURIComponent(String(key)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(v2StoreItemUpdateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List key-value stores
         * @param {string} organization 
         * @param {string} project 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        kVList: async (organization: string, project: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organization' is not null or undefined
            assertParamExists('kVList', 'organization', organization)
            // verify required parameter 'project' is not null or undefined
            assertParamExists('kVList', 'project', project)
            const localVarPath = `/api/v2/organizations/{organization}/projects/{project}/kv`
                .replace(`{${"organization"}}`, encodeURIComponent(String(organization)))
                .replace(`{${"project"}}`, encodeURIComponent(String(project)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a kv store
         * @param {string} organization 
         * @param {string} project 
         * @param {string} storeId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        kVShow: async (organization: string, project: string, storeId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organization' is not null or undefined
            assertParamExists('kVShow', 'organization', organization)
            // verify required parameter 'project' is not null or undefined
            assertParamExists('kVShow', 'project', project)
            // verify required parameter 'storeId' is not null or undefined
            assertParamExists('kVShow', 'storeId', storeId)
            const localVarPath = `/api/v2/organizations/{organization}/projects/{project}/kv/{store_id}`
                .replace(`{${"organization"}}`, encodeURIComponent(String(organization)))
                .replace(`{${"project"}}`, encodeURIComponent(String(project)))
                .replace(`{${"store_id"}}`, encodeURIComponent(String(storeId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * KVApi - functional programming interface
 * @export
 */
export const KVApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = KVApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Add a kv store
         * @param {string} organization 
         * @param {string} project 
         * @param {V2StoreRequest} v2StoreRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async kVCreate(organization: string, project: string, v2StoreRequest: V2StoreRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<V2Store>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.kVCreate(organization, project, v2StoreRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['KVApi.kVCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete a kv store
         * @param {string} organization 
         * @param {string} project 
         * @param {string} storeId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async kVDelete(organization: string, project: string, storeId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.kVDelete(organization, project, storeId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['KVApi.kVDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Add an item to a kv store
         * @param {string} organization 
         * @param {string} project 
         * @param {string} storeId 
         * @param {V2StoreItemRequest} v2StoreItemRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async kVItemsCreate(organization: string, project: string, storeId: string, v2StoreItemRequest: V2StoreItemRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<KVItemsCreate200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.kVItemsCreate(organization, project, storeId, v2StoreItemRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['KVApi.kVItemsCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete an item from a kv store
         * @param {string} organization 
         * @param {string} project 
         * @param {string} storeId 
         * @param {string} key 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async kVItemsDelete(organization: string, project: string, storeId: string, key: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<KVItemsDelete200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.kVItemsDelete(organization, project, storeId, key, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['KVApi.kVItemsDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary List items in a kv store
         * @param {string} organization 
         * @param {string} project 
         * @param {string} storeId 
         * @param {string} [cursor] Cursor for pagination
         * @param {number} [limit] Number of items to return
         * @param {string} [search] Search filter for keys
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async kVItemsList(organization: string, project: string, storeId: string, cursor?: string, limit?: number, search?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<V2StoreItemsListResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.kVItemsList(organization, project, storeId, cursor, limit, search, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['KVApi.kVItemsList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get an item from a kv store
         * @param {string} organization 
         * @param {string} project 
         * @param {string} storeId 
         * @param {string} key 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async kVItemsShow(organization: string, project: string, storeId: string, key: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<KVItemsShow200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.kVItemsShow(organization, project, storeId, key, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['KVApi.kVItemsShow']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update an item in a kv store
         * @param {string} organization 
         * @param {string} project 
         * @param {string} storeId 
         * @param {string} key 
         * @param {V2StoreItemUpdateRequest} v2StoreItemUpdateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async kVItemsUpdate(organization: string, project: string, storeId: string, key: string, v2StoreItemUpdateRequest: V2StoreItemUpdateRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<KVItemsCreate200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.kVItemsUpdate(organization, project, storeId, key, v2StoreItemUpdateRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['KVApi.kVItemsUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary List key-value stores
         * @param {string} organization 
         * @param {string} project 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async kVList(organization: string, project: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<V2Store>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.kVList(organization, project, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['KVApi.kVList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get a kv store
         * @param {string} organization 
         * @param {string} project 
         * @param {string} storeId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async kVShow(organization: string, project: string, storeId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<V2Store>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.kVShow(organization, project, storeId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['KVApi.kVShow']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * KVApi - factory interface
 * @export
 */
export const KVApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = KVApiFp(configuration)
    return {
        /**
         * 
         * @summary Add a kv store
         * @param {string} organization 
         * @param {string} project 
         * @param {V2StoreRequest} v2StoreRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        kVCreate(organization: string, project: string, v2StoreRequest: V2StoreRequest, options?: RawAxiosRequestConfig): AxiosPromise<V2Store> {
            return localVarFp.kVCreate(organization, project, v2StoreRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete a kv store
         * @param {string} organization 
         * @param {string} project 
         * @param {string} storeId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        kVDelete(organization: string, project: string, storeId: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.kVDelete(organization, project, storeId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Add an item to a kv store
         * @param {string} organization 
         * @param {string} project 
         * @param {string} storeId 
         * @param {V2StoreItemRequest} v2StoreItemRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        kVItemsCreate(organization: string, project: string, storeId: string, v2StoreItemRequest: V2StoreItemRequest, options?: RawAxiosRequestConfig): AxiosPromise<KVItemsCreate200Response> {
            return localVarFp.kVItemsCreate(organization, project, storeId, v2StoreItemRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete an item from a kv store
         * @param {string} organization 
         * @param {string} project 
         * @param {string} storeId 
         * @param {string} key 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        kVItemsDelete(organization: string, project: string, storeId: string, key: string, options?: RawAxiosRequestConfig): AxiosPromise<KVItemsDelete200Response> {
            return localVarFp.kVItemsDelete(organization, project, storeId, key, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List items in a kv store
         * @param {string} organization 
         * @param {string} project 
         * @param {string} storeId 
         * @param {string} [cursor] Cursor for pagination
         * @param {number} [limit] Number of items to return
         * @param {string} [search] Search filter for keys
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        kVItemsList(organization: string, project: string, storeId: string, cursor?: string, limit?: number, search?: string, options?: RawAxiosRequestConfig): AxiosPromise<V2StoreItemsListResponse> {
            return localVarFp.kVItemsList(organization, project, storeId, cursor, limit, search, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get an item from a kv store
         * @param {string} organization 
         * @param {string} project 
         * @param {string} storeId 
         * @param {string} key 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        kVItemsShow(organization: string, project: string, storeId: string, key: string, options?: RawAxiosRequestConfig): AxiosPromise<KVItemsShow200Response> {
            return localVarFp.kVItemsShow(organization, project, storeId, key, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update an item in a kv store
         * @param {string} organization 
         * @param {string} project 
         * @param {string} storeId 
         * @param {string} key 
         * @param {V2StoreItemUpdateRequest} v2StoreItemUpdateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        kVItemsUpdate(organization: string, project: string, storeId: string, key: string, v2StoreItemUpdateRequest: V2StoreItemUpdateRequest, options?: RawAxiosRequestConfig): AxiosPromise<KVItemsCreate200Response> {
            return localVarFp.kVItemsUpdate(organization, project, storeId, key, v2StoreItemUpdateRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List key-value stores
         * @param {string} organization 
         * @param {string} project 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        kVList(organization: string, project: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<V2Store>> {
            return localVarFp.kVList(organization, project, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a kv store
         * @param {string} organization 
         * @param {string} project 
         * @param {string} storeId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        kVShow(organization: string, project: string, storeId: string, options?: RawAxiosRequestConfig): AxiosPromise<V2Store> {
            return localVarFp.kVShow(organization, project, storeId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * KVApi - object-oriented interface
 * @export
 * @class KVApi
 * @extends {BaseAPI}
 */
export class KVApi extends BaseAPI {
    /**
     * 
     * @summary Add a kv store
     * @param {string} organization 
     * @param {string} project 
     * @param {V2StoreRequest} v2StoreRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof KVApi
     */
    public kVCreate(organization: string, project: string, v2StoreRequest: V2StoreRequest, options?: RawAxiosRequestConfig) {
        return KVApiFp(this.configuration).kVCreate(organization, project, v2StoreRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete a kv store
     * @param {string} organization 
     * @param {string} project 
     * @param {string} storeId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof KVApi
     */
    public kVDelete(organization: string, project: string, storeId: string, options?: RawAxiosRequestConfig) {
        return KVApiFp(this.configuration).kVDelete(organization, project, storeId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Add an item to a kv store
     * @param {string} organization 
     * @param {string} project 
     * @param {string} storeId 
     * @param {V2StoreItemRequest} v2StoreItemRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof KVApi
     */
    public kVItemsCreate(organization: string, project: string, storeId: string, v2StoreItemRequest: V2StoreItemRequest, options?: RawAxiosRequestConfig) {
        return KVApiFp(this.configuration).kVItemsCreate(organization, project, storeId, v2StoreItemRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete an item from a kv store
     * @param {string} organization 
     * @param {string} project 
     * @param {string} storeId 
     * @param {string} key 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof KVApi
     */
    public kVItemsDelete(organization: string, project: string, storeId: string, key: string, options?: RawAxiosRequestConfig) {
        return KVApiFp(this.configuration).kVItemsDelete(organization, project, storeId, key, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List items in a kv store
     * @param {string} organization 
     * @param {string} project 
     * @param {string} storeId 
     * @param {string} [cursor] Cursor for pagination
     * @param {number} [limit] Number of items to return
     * @param {string} [search] Search filter for keys
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof KVApi
     */
    public kVItemsList(organization: string, project: string, storeId: string, cursor?: string, limit?: number, search?: string, options?: RawAxiosRequestConfig) {
        return KVApiFp(this.configuration).kVItemsList(organization, project, storeId, cursor, limit, search, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get an item from a kv store
     * @param {string} organization 
     * @param {string} project 
     * @param {string} storeId 
     * @param {string} key 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof KVApi
     */
    public kVItemsShow(organization: string, project: string, storeId: string, key: string, options?: RawAxiosRequestConfig) {
        return KVApiFp(this.configuration).kVItemsShow(organization, project, storeId, key, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update an item in a kv store
     * @param {string} organization 
     * @param {string} project 
     * @param {string} storeId 
     * @param {string} key 
     * @param {V2StoreItemUpdateRequest} v2StoreItemUpdateRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof KVApi
     */
    public kVItemsUpdate(organization: string, project: string, storeId: string, key: string, v2StoreItemUpdateRequest: V2StoreItemUpdateRequest, options?: RawAxiosRequestConfig) {
        return KVApiFp(this.configuration).kVItemsUpdate(organization, project, storeId, key, v2StoreItemUpdateRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List key-value stores
     * @param {string} organization 
     * @param {string} project 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof KVApi
     */
    public kVList(organization: string, project: string, options?: RawAxiosRequestConfig) {
        return KVApiFp(this.configuration).kVList(organization, project, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a kv store
     * @param {string} organization 
     * @param {string} project 
     * @param {string} storeId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof KVApi
     */
    public kVShow(organization: string, project: string, storeId: string, options?: RawAxiosRequestConfig) {
        return KVApiFp(this.configuration).kVShow(organization, project, storeId, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * OrganizationsApi - axios parameter creator
 * @export
 */
export const OrganizationsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Retrieve all organizations
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        organizationsList: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v2/organizations`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get details of a single organization
         * @param {string} organization 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        organizationsRead: async (organization: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organization' is not null or undefined
            assertParamExists('organizationsRead', 'organization', organization)
            const localVarPath = `/api/v2/organizations/{organization}`
                .replace(`{${"organization"}}`, encodeURIComponent(String(organization)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * OrganizationsApi - functional programming interface
 * @export
 */
export const OrganizationsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = OrganizationsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Retrieve all organizations
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async organizationsList(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<OrganizationsList200ResponseInner>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.organizationsList(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrganizationsApi.organizationsList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get details of a single organization
         * @param {string} organization 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async organizationsRead(organization: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<V2Organization>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.organizationsRead(organization, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrganizationsApi.organizationsRead']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * OrganizationsApi - factory interface
 * @export
 */
export const OrganizationsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = OrganizationsApiFp(configuration)
    return {
        /**
         * 
         * @summary Retrieve all organizations
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        organizationsList(options?: RawAxiosRequestConfig): AxiosPromise<Array<OrganizationsList200ResponseInner>> {
            return localVarFp.organizationsList(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get details of a single organization
         * @param {string} organization 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        organizationsRead(organization: string, options?: RawAxiosRequestConfig): AxiosPromise<V2Organization> {
            return localVarFp.organizationsRead(organization, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * OrganizationsApi - object-oriented interface
 * @export
 * @class OrganizationsApi
 * @extends {BaseAPI}
 */
export class OrganizationsApi extends BaseAPI {
    /**
     * 
     * @summary Retrieve all organizations
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationsApi
     */
    public organizationsList(options?: RawAxiosRequestConfig) {
        return OrganizationsApiFp(this.configuration).organizationsList(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get details of a single organization
     * @param {string} organization 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationsApi
     */
    public organizationsRead(organization: string, options?: RawAxiosRequestConfig) {
        return OrganizationsApiFp(this.configuration).organizationsRead(organization, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ProjectsApi - axios parameter creator
 * @export
 */
export const ProjectsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create a new project
         * @param {string} organization 
         * @param {V2ProjectRequest} v2ProjectRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectsCreate: async (organization: string, v2ProjectRequest: V2ProjectRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organization' is not null or undefined
            assertParamExists('projectsCreate', 'organization', organization)
            // verify required parameter 'v2ProjectRequest' is not null or undefined
            assertParamExists('projectsCreate', 'v2ProjectRequest', v2ProjectRequest)
            const localVarPath = `/api/v2/organizations/{organization}/projects`
                .replace(`{${"organization"}}`, encodeURIComponent(String(organization)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(v2ProjectRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a project
         * @param {string} organization 
         * @param {string} project 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectsDelete: async (organization: string, project: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organization' is not null or undefined
            assertParamExists('projectsDelete', 'organization', organization)
            // verify required parameter 'project' is not null or undefined
            assertParamExists('projectsDelete', 'project', project)
            const localVarPath = `/api/v2/organizations/{organization}/projects/{project}`
                .replace(`{${"organization"}}`, encodeURIComponent(String(organization)))
                .replace(`{${"project"}}`, encodeURIComponent(String(project)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve all projects for an organization
         * @param {string} organization 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectsList: async (organization: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organization' is not null or undefined
            assertParamExists('projectsList', 'organization', organization)
            const localVarPath = `/api/v2/organizations/{organization}/projects`
                .replace(`{${"organization"}}`, encodeURIComponent(String(organization)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get details of a single project
         * @param {string} organization 
         * @param {string} project 
         * @param {boolean} withToken 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectsRead: async (organization: string, project: string, withToken: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organization' is not null or undefined
            assertParamExists('projectsRead', 'organization', organization)
            // verify required parameter 'project' is not null or undefined
            assertParamExists('projectsRead', 'project', project)
            // verify required parameter 'withToken' is not null or undefined
            assertParamExists('projectsRead', 'withToken', withToken)
            const localVarPath = `/api/v2/organizations/{organization}/projects/{project}`
                .replace(`{${"organization"}}`, encodeURIComponent(String(organization)))
                .replace(`{${"project"}}`, encodeURIComponent(String(project)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (withToken !== undefined) {
                localVarQueryParameter['with_token'] = withToken;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update a project
         * @param {string} organization 
         * @param {string} project 
         * @param {V2ProjectRequest} v2ProjectRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectsUpdate: async (organization: string, project: string, v2ProjectRequest: V2ProjectRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organization' is not null or undefined
            assertParamExists('projectsUpdate', 'organization', organization)
            // verify required parameter 'project' is not null or undefined
            assertParamExists('projectsUpdate', 'project', project)
            // verify required parameter 'v2ProjectRequest' is not null or undefined
            assertParamExists('projectsUpdate', 'v2ProjectRequest', v2ProjectRequest)
            const localVarPath = `/api/v2/organizations/{organization}/projects/{project}`
                .replace(`{${"organization"}}`, encodeURIComponent(String(organization)))
                .replace(`{${"project"}}`, encodeURIComponent(String(project)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(v2ProjectRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ProjectsApi - functional programming interface
 * @export
 */
export const ProjectsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ProjectsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Create a new project
         * @param {string} organization 
         * @param {V2ProjectRequest} v2ProjectRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async projectsCreate(organization: string, v2ProjectRequest: V2ProjectRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<V2Project>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.projectsCreate(organization, v2ProjectRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProjectsApi.projectsCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete a project
         * @param {string} organization 
         * @param {string} project 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async projectsDelete(organization: string, project: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.projectsDelete(organization, project, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProjectsApi.projectsDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Retrieve all projects for an organization
         * @param {string} organization 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async projectsList(organization: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ProjectsList200ResponseInner>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.projectsList(organization, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProjectsApi.projectsList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get details of a single project
         * @param {string} organization 
         * @param {string} project 
         * @param {boolean} withToken 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async projectsRead(organization: string, project: string, withToken: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<V2Project>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.projectsRead(organization, project, withToken, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProjectsApi.projectsRead']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update a project
         * @param {string} organization 
         * @param {string} project 
         * @param {V2ProjectRequest} v2ProjectRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async projectsUpdate(organization: string, project: string, v2ProjectRequest: V2ProjectRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<V2Project>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.projectsUpdate(organization, project, v2ProjectRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProjectsApi.projectsUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ProjectsApi - factory interface
 * @export
 */
export const ProjectsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ProjectsApiFp(configuration)
    return {
        /**
         * 
         * @summary Create a new project
         * @param {string} organization 
         * @param {V2ProjectRequest} v2ProjectRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectsCreate(organization: string, v2ProjectRequest: V2ProjectRequest, options?: RawAxiosRequestConfig): AxiosPromise<V2Project> {
            return localVarFp.projectsCreate(organization, v2ProjectRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete a project
         * @param {string} organization 
         * @param {string} project 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectsDelete(organization: string, project: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.projectsDelete(organization, project, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieve all projects for an organization
         * @param {string} organization 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectsList(organization: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<ProjectsList200ResponseInner>> {
            return localVarFp.projectsList(organization, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get details of a single project
         * @param {string} organization 
         * @param {string} project 
         * @param {boolean} withToken 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectsRead(organization: string, project: string, withToken: boolean, options?: RawAxiosRequestConfig): AxiosPromise<V2Project> {
            return localVarFp.projectsRead(organization, project, withToken, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update a project
         * @param {string} organization 
         * @param {string} project 
         * @param {V2ProjectRequest} v2ProjectRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectsUpdate(organization: string, project: string, v2ProjectRequest: V2ProjectRequest, options?: RawAxiosRequestConfig): AxiosPromise<V2Project> {
            return localVarFp.projectsUpdate(organization, project, v2ProjectRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ProjectsApi - object-oriented interface
 * @export
 * @class ProjectsApi
 * @extends {BaseAPI}
 */
export class ProjectsApi extends BaseAPI {
    /**
     * 
     * @summary Create a new project
     * @param {string} organization 
     * @param {V2ProjectRequest} v2ProjectRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectsApi
     */
    public projectsCreate(organization: string, v2ProjectRequest: V2ProjectRequest, options?: RawAxiosRequestConfig) {
        return ProjectsApiFp(this.configuration).projectsCreate(organization, v2ProjectRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete a project
     * @param {string} organization 
     * @param {string} project 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectsApi
     */
    public projectsDelete(organization: string, project: string, options?: RawAxiosRequestConfig) {
        return ProjectsApiFp(this.configuration).projectsDelete(organization, project, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieve all projects for an organization
     * @param {string} organization 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectsApi
     */
    public projectsList(organization: string, options?: RawAxiosRequestConfig) {
        return ProjectsApiFp(this.configuration).projectsList(organization, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get details of a single project
     * @param {string} organization 
     * @param {string} project 
     * @param {boolean} withToken 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectsApi
     */
    public projectsRead(organization: string, project: string, withToken: boolean, options?: RawAxiosRequestConfig) {
        return ProjectsApiFp(this.configuration).projectsRead(organization, project, withToken, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update a project
     * @param {string} organization 
     * @param {string} project 
     * @param {V2ProjectRequest} v2ProjectRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectsApi
     */
    public projectsUpdate(organization: string, project: string, v2ProjectRequest: V2ProjectRequest, options?: RawAxiosRequestConfig) {
        return ProjectsApiFp(this.configuration).projectsUpdate(organization, project, v2ProjectRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * PurgeApi - axios parameter creator
 * @export
 */
export const PurgeApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Purge cache via URL or cache keys
         * @param {string} organization 
         * @param {string} project 
         * @param {PurgeCreateRequest} purgeCreateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        purgeCreate: async (organization: string, project: string, purgeCreateRequest: PurgeCreateRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organization' is not null or undefined
            assertParamExists('purgeCreate', 'organization', organization)
            // verify required parameter 'project' is not null or undefined
            assertParamExists('purgeCreate', 'project', project)
            // verify required parameter 'purgeCreateRequest' is not null or undefined
            assertParamExists('purgeCreate', 'purgeCreateRequest', purgeCreateRequest)
            const localVarPath = `/api/v2/organizations/{organization}/projects/{project}/purge`
                .replace(`{${"organization"}}`, encodeURIComponent(String(organization)))
                .replace(`{${"project"}}`, encodeURIComponent(String(project)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(purgeCreateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PurgeApi - functional programming interface
 * @export
 */
export const PurgeApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PurgeApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Purge cache via URL or cache keys
         * @param {string} organization 
         * @param {string} project 
         * @param {PurgeCreateRequest} purgeCreateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async purgeCreate(organization: string, project: string, purgeCreateRequest: PurgeCreateRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.purgeCreate(organization, project, purgeCreateRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PurgeApi.purgeCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * PurgeApi - factory interface
 * @export
 */
export const PurgeApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PurgeApiFp(configuration)
    return {
        /**
         * 
         * @summary Purge cache via URL or cache keys
         * @param {string} organization 
         * @param {string} project 
         * @param {PurgeCreateRequest} purgeCreateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        purgeCreate(organization: string, project: string, purgeCreateRequest: PurgeCreateRequest, options?: RawAxiosRequestConfig): AxiosPromise<string> {
            return localVarFp.purgeCreate(organization, project, purgeCreateRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * PurgeApi - object-oriented interface
 * @export
 * @class PurgeApi
 * @extends {BaseAPI}
 */
export class PurgeApi extends BaseAPI {
    /**
     * 
     * @summary Purge cache via URL or cache keys
     * @param {string} organization 
     * @param {string} project 
     * @param {PurgeCreateRequest} purgeCreateRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PurgeApi
     */
    public purgeCreate(organization: string, project: string, purgeCreateRequest: PurgeCreateRequest, options?: RawAxiosRequestConfig) {
        return PurgeApiFp(this.configuration).purgeCreate(organization, project, purgeCreateRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * RulesApi - axios parameter creator
 * @export
 */
export const RulesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create an authentication rule
         * @param {string} organization Organization identifier
         * @param {string} project Project identifier
         * @param {V2RuleAuthRequest} v2RuleAuthRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rulesAuthCreate: async (organization: string, project: string, v2RuleAuthRequest: V2RuleAuthRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organization' is not null or undefined
            assertParamExists('rulesAuthCreate', 'organization', organization)
            // verify required parameter 'project' is not null or undefined
            assertParamExists('rulesAuthCreate', 'project', project)
            // verify required parameter 'v2RuleAuthRequest' is not null or undefined
            assertParamExists('rulesAuthCreate', 'v2RuleAuthRequest', v2RuleAuthRequest)
            const localVarPath = `/api/v2/organizations/{organization}/projects/{project}/rules/auth`
                .replace(`{${"organization"}}`, encodeURIComponent(String(organization)))
                .replace(`{${"project"}}`, encodeURIComponent(String(project)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(v2RuleAuthRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete an authentication rule
         * @param {string} organization Organization identifier
         * @param {string} project Project identifier
         * @param {string} rule Rule identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rulesAuthDelete: async (organization: string, project: string, rule: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organization' is not null or undefined
            assertParamExists('rulesAuthDelete', 'organization', organization)
            // verify required parameter 'project' is not null or undefined
            assertParamExists('rulesAuthDelete', 'project', project)
            // verify required parameter 'rule' is not null or undefined
            assertParamExists('rulesAuthDelete', 'rule', rule)
            const localVarPath = `/api/v2/organizations/{organization}/projects/{project}/rules/auth/{rule}`
                .replace(`{${"organization"}}`, encodeURIComponent(String(organization)))
                .replace(`{${"project"}}`, encodeURIComponent(String(project)))
                .replace(`{${"rule"}}`, encodeURIComponent(String(rule)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List authentication rules
         * @param {string} organization Organization identifier
         * @param {string} project Project identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rulesAuthList: async (organization: string, project: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organization' is not null or undefined
            assertParamExists('rulesAuthList', 'organization', organization)
            // verify required parameter 'project' is not null or undefined
            assertParamExists('rulesAuthList', 'project', project)
            const localVarPath = `/api/v2/organizations/{organization}/projects/{project}/rules/auth`
                .replace(`{${"organization"}}`, encodeURIComponent(String(organization)))
                .replace(`{${"project"}}`, encodeURIComponent(String(project)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get details of an authentication rule
         * @param {string} organization Organization identifier
         * @param {string} project Project identifier
         * @param {string} rule Rule identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rulesAuthRead: async (organization: string, project: string, rule: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organization' is not null or undefined
            assertParamExists('rulesAuthRead', 'organization', organization)
            // verify required parameter 'project' is not null or undefined
            assertParamExists('rulesAuthRead', 'project', project)
            // verify required parameter 'rule' is not null or undefined
            assertParamExists('rulesAuthRead', 'rule', rule)
            const localVarPath = `/api/v2/organizations/{organization}/projects/{project}/rules/auth/{rule}`
                .replace(`{${"organization"}}`, encodeURIComponent(String(organization)))
                .replace(`{${"project"}}`, encodeURIComponent(String(project)))
                .replace(`{${"rule"}}`, encodeURIComponent(String(rule)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update an authentication rule
         * @param {string} organization Organization identifier
         * @param {string} project Project identifier
         * @param {string} rule Rule identifier
         * @param {V2RuleAuthRequest} v2RuleAuthRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rulesAuthUpdate: async (organization: string, project: string, rule: string, v2RuleAuthRequest: V2RuleAuthRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organization' is not null or undefined
            assertParamExists('rulesAuthUpdate', 'organization', organization)
            // verify required parameter 'project' is not null or undefined
            assertParamExists('rulesAuthUpdate', 'project', project)
            // verify required parameter 'rule' is not null or undefined
            assertParamExists('rulesAuthUpdate', 'rule', rule)
            // verify required parameter 'v2RuleAuthRequest' is not null or undefined
            assertParamExists('rulesAuthUpdate', 'v2RuleAuthRequest', v2RuleAuthRequest)
            const localVarPath = `/api/v2/organizations/{organization}/projects/{project}/rules/auth/{rule}`
                .replace(`{${"organization"}}`, encodeURIComponent(String(organization)))
                .replace(`{${"project"}}`, encodeURIComponent(String(project)))
                .replace(`{${"rule"}}`, encodeURIComponent(String(rule)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(v2RuleAuthRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create a bot challenge rule
         * @param {string} organization Organization identifier
         * @param {string} project Project identifier
         * @param {V2RuleBotChallengeRequest} v2RuleBotChallengeRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rulesBotChallengeCreate: async (organization: string, project: string, v2RuleBotChallengeRequest: V2RuleBotChallengeRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organization' is not null or undefined
            assertParamExists('rulesBotChallengeCreate', 'organization', organization)
            // verify required parameter 'project' is not null or undefined
            assertParamExists('rulesBotChallengeCreate', 'project', project)
            // verify required parameter 'v2RuleBotChallengeRequest' is not null or undefined
            assertParamExists('rulesBotChallengeCreate', 'v2RuleBotChallengeRequest', v2RuleBotChallengeRequest)
            const localVarPath = `/api/v2/organizations/{organization}/projects/{project}/rules/bot-challenge`
                .replace(`{${"organization"}}`, encodeURIComponent(String(organization)))
                .replace(`{${"project"}}`, encodeURIComponent(String(project)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(v2RuleBotChallengeRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a bot challenge rule
         * @param {string} organization Organization identifier
         * @param {string} project Project identifier
         * @param {string} rule Rule identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rulesBotChallengeDelete: async (organization: string, project: string, rule: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organization' is not null or undefined
            assertParamExists('rulesBotChallengeDelete', 'organization', organization)
            // verify required parameter 'project' is not null or undefined
            assertParamExists('rulesBotChallengeDelete', 'project', project)
            // verify required parameter 'rule' is not null or undefined
            assertParamExists('rulesBotChallengeDelete', 'rule', rule)
            const localVarPath = `/api/v2/organizations/{organization}/projects/{project}/rules/bot-challenge/{rule}`
                .replace(`{${"organization"}}`, encodeURIComponent(String(organization)))
                .replace(`{${"project"}}`, encodeURIComponent(String(project)))
                .replace(`{${"rule"}}`, encodeURIComponent(String(rule)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List bot challenge rules
         * @param {string} organization Organization identifier
         * @param {string} project Project identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rulesBotChallengeList: async (organization: string, project: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organization' is not null or undefined
            assertParamExists('rulesBotChallengeList', 'organization', organization)
            // verify required parameter 'project' is not null or undefined
            assertParamExists('rulesBotChallengeList', 'project', project)
            const localVarPath = `/api/v2/organizations/{organization}/projects/{project}/rules/bot-challenge`
                .replace(`{${"organization"}}`, encodeURIComponent(String(organization)))
                .replace(`{${"project"}}`, encodeURIComponent(String(project)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get details of a bot challenge rule
         * @param {string} organization Organization identifier
         * @param {string} project Project identifier
         * @param {string} rule Rule identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rulesBotChallengeRead: async (organization: string, project: string, rule: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organization' is not null or undefined
            assertParamExists('rulesBotChallengeRead', 'organization', organization)
            // verify required parameter 'project' is not null or undefined
            assertParamExists('rulesBotChallengeRead', 'project', project)
            // verify required parameter 'rule' is not null or undefined
            assertParamExists('rulesBotChallengeRead', 'rule', rule)
            const localVarPath = `/api/v2/organizations/{organization}/projects/{project}/rules/bot-challenge/{rule}`
                .replace(`{${"organization"}}`, encodeURIComponent(String(organization)))
                .replace(`{${"project"}}`, encodeURIComponent(String(project)))
                .replace(`{${"rule"}}`, encodeURIComponent(String(rule)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update a bot challenge rule
         * @param {string} organization Organization identifier
         * @param {string} project Project identifier
         * @param {string} rule Rule identifier
         * @param {V2RuleBotChallengeRequest} v2RuleBotChallengeRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rulesBotChallengeUpdate: async (organization: string, project: string, rule: string, v2RuleBotChallengeRequest: V2RuleBotChallengeRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organization' is not null or undefined
            assertParamExists('rulesBotChallengeUpdate', 'organization', organization)
            // verify required parameter 'project' is not null or undefined
            assertParamExists('rulesBotChallengeUpdate', 'project', project)
            // verify required parameter 'rule' is not null or undefined
            assertParamExists('rulesBotChallengeUpdate', 'rule', rule)
            // verify required parameter 'v2RuleBotChallengeRequest' is not null or undefined
            assertParamExists('rulesBotChallengeUpdate', 'v2RuleBotChallengeRequest', v2RuleBotChallengeRequest)
            const localVarPath = `/api/v2/organizations/{organization}/projects/{project}/rules/bot-challenge/{rule}`
                .replace(`{${"organization"}}`, encodeURIComponent(String(organization)))
                .replace(`{${"project"}}`, encodeURIComponent(String(project)))
                .replace(`{${"rule"}}`, encodeURIComponent(String(rule)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(v2RuleBotChallengeRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create a content filter rule
         * @param {string} organization Organization identifier
         * @param {string} project Project identifier
         * @param {V2RuleContentFilterRequest} v2RuleContentFilterRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rulesContentFilterCreate: async (organization: string, project: string, v2RuleContentFilterRequest: V2RuleContentFilterRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organization' is not null or undefined
            assertParamExists('rulesContentFilterCreate', 'organization', organization)
            // verify required parameter 'project' is not null or undefined
            assertParamExists('rulesContentFilterCreate', 'project', project)
            // verify required parameter 'v2RuleContentFilterRequest' is not null or undefined
            assertParamExists('rulesContentFilterCreate', 'v2RuleContentFilterRequest', v2RuleContentFilterRequest)
            const localVarPath = `/api/v2/organizations/{organization}/projects/{project}/rules/content-filter`
                .replace(`{${"organization"}}`, encodeURIComponent(String(organization)))
                .replace(`{${"project"}}`, encodeURIComponent(String(project)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(v2RuleContentFilterRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a content filter rule
         * @param {string} organization Organization identifier
         * @param {string} project Project identifier
         * @param {string} rule Rule identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rulesContentFilterDelete: async (organization: string, project: string, rule: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organization' is not null or undefined
            assertParamExists('rulesContentFilterDelete', 'organization', organization)
            // verify required parameter 'project' is not null or undefined
            assertParamExists('rulesContentFilterDelete', 'project', project)
            // verify required parameter 'rule' is not null or undefined
            assertParamExists('rulesContentFilterDelete', 'rule', rule)
            const localVarPath = `/api/v2/organizations/{organization}/projects/{project}/rules/content-filter/{rule}`
                .replace(`{${"organization"}}`, encodeURIComponent(String(organization)))
                .replace(`{${"project"}}`, encodeURIComponent(String(project)))
                .replace(`{${"rule"}}`, encodeURIComponent(String(rule)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List content filter rules
         * @param {string} organization Organization identifier
         * @param {string} project Project identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rulesContentFilterList: async (organization: string, project: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organization' is not null or undefined
            assertParamExists('rulesContentFilterList', 'organization', organization)
            // verify required parameter 'project' is not null or undefined
            assertParamExists('rulesContentFilterList', 'project', project)
            const localVarPath = `/api/v2/organizations/{organization}/projects/{project}/rules/content-filter`
                .replace(`{${"organization"}}`, encodeURIComponent(String(organization)))
                .replace(`{${"project"}}`, encodeURIComponent(String(project)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get details of a content filter rule
         * @param {string} organization Organization identifier
         * @param {string} project Project identifier
         * @param {string} rule Rule identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rulesContentFilterRead: async (organization: string, project: string, rule: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organization' is not null or undefined
            assertParamExists('rulesContentFilterRead', 'organization', organization)
            // verify required parameter 'project' is not null or undefined
            assertParamExists('rulesContentFilterRead', 'project', project)
            // verify required parameter 'rule' is not null or undefined
            assertParamExists('rulesContentFilterRead', 'rule', rule)
            const localVarPath = `/api/v2/organizations/{organization}/projects/{project}/rules/content-filter/{rule}`
                .replace(`{${"organization"}}`, encodeURIComponent(String(organization)))
                .replace(`{${"project"}}`, encodeURIComponent(String(project)))
                .replace(`{${"rule"}}`, encodeURIComponent(String(rule)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update a content filter rule
         * @param {string} organization Organization identifier
         * @param {string} project Project identifier
         * @param {string} rule Rule identifier
         * @param {V2RuleContentFilterRequest} v2RuleContentFilterRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rulesContentFilterUpdate: async (organization: string, project: string, rule: string, v2RuleContentFilterRequest: V2RuleContentFilterRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organization' is not null or undefined
            assertParamExists('rulesContentFilterUpdate', 'organization', organization)
            // verify required parameter 'project' is not null or undefined
            assertParamExists('rulesContentFilterUpdate', 'project', project)
            // verify required parameter 'rule' is not null or undefined
            assertParamExists('rulesContentFilterUpdate', 'rule', rule)
            // verify required parameter 'v2RuleContentFilterRequest' is not null or undefined
            assertParamExists('rulesContentFilterUpdate', 'v2RuleContentFilterRequest', v2RuleContentFilterRequest)
            const localVarPath = `/api/v2/organizations/{organization}/projects/{project}/rules/content-filter/{rule}`
                .replace(`{${"organization"}}`, encodeURIComponent(String(organization)))
                .replace(`{${"project"}}`, encodeURIComponent(String(project)))
                .replace(`{${"rule"}}`, encodeURIComponent(String(rule)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(v2RuleContentFilterRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create a custom response rule
         * @param {string} organization Organization identifier
         * @param {string} project Project identifier
         * @param {V2RuleCustomResponseRequest} v2RuleCustomResponseRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rulesCustomResponseCreate: async (organization: string, project: string, v2RuleCustomResponseRequest: V2RuleCustomResponseRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organization' is not null or undefined
            assertParamExists('rulesCustomResponseCreate', 'organization', organization)
            // verify required parameter 'project' is not null or undefined
            assertParamExists('rulesCustomResponseCreate', 'project', project)
            // verify required parameter 'v2RuleCustomResponseRequest' is not null or undefined
            assertParamExists('rulesCustomResponseCreate', 'v2RuleCustomResponseRequest', v2RuleCustomResponseRequest)
            const localVarPath = `/api/v2/organizations/{organization}/projects/{project}/rules/custom-response`
                .replace(`{${"organization"}}`, encodeURIComponent(String(organization)))
                .replace(`{${"project"}}`, encodeURIComponent(String(project)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(v2RuleCustomResponseRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a custom response rule
         * @param {string} organization Organization identifier
         * @param {string} project Project identifier
         * @param {string} rule Rule identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rulesCustomResponseDelete: async (organization: string, project: string, rule: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organization' is not null or undefined
            assertParamExists('rulesCustomResponseDelete', 'organization', organization)
            // verify required parameter 'project' is not null or undefined
            assertParamExists('rulesCustomResponseDelete', 'project', project)
            // verify required parameter 'rule' is not null or undefined
            assertParamExists('rulesCustomResponseDelete', 'rule', rule)
            const localVarPath = `/api/v2/organizations/{organization}/projects/{project}/rules/custom-response/{rule}`
                .replace(`{${"organization"}}`, encodeURIComponent(String(organization)))
                .replace(`{${"project"}}`, encodeURIComponent(String(project)))
                .replace(`{${"rule"}}`, encodeURIComponent(String(rule)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List custom response rules
         * @param {string} organization Organization identifier
         * @param {string} project Project identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rulesCustomResponseList: async (organization: string, project: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organization' is not null or undefined
            assertParamExists('rulesCustomResponseList', 'organization', organization)
            // verify required parameter 'project' is not null or undefined
            assertParamExists('rulesCustomResponseList', 'project', project)
            const localVarPath = `/api/v2/organizations/{organization}/projects/{project}/rules/custom-response`
                .replace(`{${"organization"}}`, encodeURIComponent(String(organization)))
                .replace(`{${"project"}}`, encodeURIComponent(String(project)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get details of a custom response rule
         * @param {string} organization Organization identifier
         * @param {string} project Project identifier
         * @param {string} rule Rule identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rulesCustomResponseRead: async (organization: string, project: string, rule: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organization' is not null or undefined
            assertParamExists('rulesCustomResponseRead', 'organization', organization)
            // verify required parameter 'project' is not null or undefined
            assertParamExists('rulesCustomResponseRead', 'project', project)
            // verify required parameter 'rule' is not null or undefined
            assertParamExists('rulesCustomResponseRead', 'rule', rule)
            const localVarPath = `/api/v2/organizations/{organization}/projects/{project}/rules/custom-response/{rule}`
                .replace(`{${"organization"}}`, encodeURIComponent(String(organization)))
                .replace(`{${"project"}}`, encodeURIComponent(String(project)))
                .replace(`{${"rule"}}`, encodeURIComponent(String(rule)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update a custom response rule
         * @param {string} organization Organization identifier
         * @param {string} project Project identifier
         * @param {string} rule Rule identifier
         * @param {V2RuleCustomResponseRequest} v2RuleCustomResponseRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rulesCustomResponseUpdate: async (organization: string, project: string, rule: string, v2RuleCustomResponseRequest: V2RuleCustomResponseRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organization' is not null or undefined
            assertParamExists('rulesCustomResponseUpdate', 'organization', organization)
            // verify required parameter 'project' is not null or undefined
            assertParamExists('rulesCustomResponseUpdate', 'project', project)
            // verify required parameter 'rule' is not null or undefined
            assertParamExists('rulesCustomResponseUpdate', 'rule', rule)
            // verify required parameter 'v2RuleCustomResponseRequest' is not null or undefined
            assertParamExists('rulesCustomResponseUpdate', 'v2RuleCustomResponseRequest', v2RuleCustomResponseRequest)
            const localVarPath = `/api/v2/organizations/{organization}/projects/{project}/rules/custom-response/{rule}`
                .replace(`{${"organization"}}`, encodeURIComponent(String(organization)))
                .replace(`{${"project"}}`, encodeURIComponent(String(project)))
                .replace(`{${"rule"}}`, encodeURIComponent(String(rule)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(v2RuleCustomResponseRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create an edge function rule
         * @param {string} organization Organization identifier
         * @param {string} project Project identifier
         * @param {V2RuleFunctionRequest} v2RuleFunctionRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rulesFunctionCreate: async (organization: string, project: string, v2RuleFunctionRequest: V2RuleFunctionRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organization' is not null or undefined
            assertParamExists('rulesFunctionCreate', 'organization', organization)
            // verify required parameter 'project' is not null or undefined
            assertParamExists('rulesFunctionCreate', 'project', project)
            // verify required parameter 'v2RuleFunctionRequest' is not null or undefined
            assertParamExists('rulesFunctionCreate', 'v2RuleFunctionRequest', v2RuleFunctionRequest)
            const localVarPath = `/api/v2/organizations/{organization}/projects/{project}/rules/function`
                .replace(`{${"organization"}}`, encodeURIComponent(String(organization)))
                .replace(`{${"project"}}`, encodeURIComponent(String(project)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(v2RuleFunctionRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete an edge function rule
         * @param {string} organization Organization identifier
         * @param {string} project Project identifier
         * @param {string} rule Rule identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rulesFunctionDelete: async (organization: string, project: string, rule: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organization' is not null or undefined
            assertParamExists('rulesFunctionDelete', 'organization', organization)
            // verify required parameter 'project' is not null or undefined
            assertParamExists('rulesFunctionDelete', 'project', project)
            // verify required parameter 'rule' is not null or undefined
            assertParamExists('rulesFunctionDelete', 'rule', rule)
            const localVarPath = `/api/v2/organizations/{organization}/projects/{project}/rules/function/{rule}`
                .replace(`{${"organization"}}`, encodeURIComponent(String(organization)))
                .replace(`{${"project"}}`, encodeURIComponent(String(project)))
                .replace(`{${"rule"}}`, encodeURIComponent(String(rule)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List edge function rules
         * @param {string} organization Organization identifier
         * @param {string} project Project identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rulesFunctionList: async (organization: string, project: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organization' is not null or undefined
            assertParamExists('rulesFunctionList', 'organization', organization)
            // verify required parameter 'project' is not null or undefined
            assertParamExists('rulesFunctionList', 'project', project)
            const localVarPath = `/api/v2/organizations/{organization}/projects/{project}/rules/function`
                .replace(`{${"organization"}}`, encodeURIComponent(String(organization)))
                .replace(`{${"project"}}`, encodeURIComponent(String(project)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get details of an edge function rule
         * @param {string} organization Organization identifier
         * @param {string} project Project identifier
         * @param {string} rule Rule identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rulesFunctionRead: async (organization: string, project: string, rule: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organization' is not null or undefined
            assertParamExists('rulesFunctionRead', 'organization', organization)
            // verify required parameter 'project' is not null or undefined
            assertParamExists('rulesFunctionRead', 'project', project)
            // verify required parameter 'rule' is not null or undefined
            assertParamExists('rulesFunctionRead', 'rule', rule)
            const localVarPath = `/api/v2/organizations/{organization}/projects/{project}/rules/function/{rule}`
                .replace(`{${"organization"}}`, encodeURIComponent(String(organization)))
                .replace(`{${"project"}}`, encodeURIComponent(String(project)))
                .replace(`{${"rule"}}`, encodeURIComponent(String(rule)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update an edge function rule
         * @param {string} organization Organization identifier
         * @param {string} project Project identifier
         * @param {string} rule Rule identifier
         * @param {V2RuleFunctionRequest} v2RuleFunctionRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rulesFunctionUpdate: async (organization: string, project: string, rule: string, v2RuleFunctionRequest: V2RuleFunctionRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organization' is not null or undefined
            assertParamExists('rulesFunctionUpdate', 'organization', organization)
            // verify required parameter 'project' is not null or undefined
            assertParamExists('rulesFunctionUpdate', 'project', project)
            // verify required parameter 'rule' is not null or undefined
            assertParamExists('rulesFunctionUpdate', 'rule', rule)
            // verify required parameter 'v2RuleFunctionRequest' is not null or undefined
            assertParamExists('rulesFunctionUpdate', 'v2RuleFunctionRequest', v2RuleFunctionRequest)
            const localVarPath = `/api/v2/organizations/{organization}/projects/{project}/rules/function/{rule}`
                .replace(`{${"organization"}}`, encodeURIComponent(String(organization)))
                .replace(`{${"project"}}`, encodeURIComponent(String(project)))
                .replace(`{${"rule"}}`, encodeURIComponent(String(rule)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(v2RuleFunctionRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create a header rule
         * @param {string} organization Organization identifier
         * @param {string} project Project identifier
         * @param {V2RuleHeaderRequest} v2RuleHeaderRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rulesHeadersCreate: async (organization: string, project: string, v2RuleHeaderRequest: V2RuleHeaderRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organization' is not null or undefined
            assertParamExists('rulesHeadersCreate', 'organization', organization)
            // verify required parameter 'project' is not null or undefined
            assertParamExists('rulesHeadersCreate', 'project', project)
            // verify required parameter 'v2RuleHeaderRequest' is not null or undefined
            assertParamExists('rulesHeadersCreate', 'v2RuleHeaderRequest', v2RuleHeaderRequest)
            const localVarPath = `/api/v2/organizations/{organization}/projects/{project}/rules/headers`
                .replace(`{${"organization"}}`, encodeURIComponent(String(organization)))
                .replace(`{${"project"}}`, encodeURIComponent(String(project)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(v2RuleHeaderRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a header rule
         * @param {string} organization Organization identifier
         * @param {string} project Project identifier
         * @param {string} rule Rule identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rulesHeadersDelete: async (organization: string, project: string, rule: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organization' is not null or undefined
            assertParamExists('rulesHeadersDelete', 'organization', organization)
            // verify required parameter 'project' is not null or undefined
            assertParamExists('rulesHeadersDelete', 'project', project)
            // verify required parameter 'rule' is not null or undefined
            assertParamExists('rulesHeadersDelete', 'rule', rule)
            const localVarPath = `/api/v2/organizations/{organization}/projects/{project}/rules/headers/{rule}`
                .replace(`{${"organization"}}`, encodeURIComponent(String(organization)))
                .replace(`{${"project"}}`, encodeURIComponent(String(project)))
                .replace(`{${"rule"}}`, encodeURIComponent(String(rule)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List header rules
         * @param {string} organization Organization identifier
         * @param {string} project Project identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rulesHeadersList: async (organization: string, project: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organization' is not null or undefined
            assertParamExists('rulesHeadersList', 'organization', organization)
            // verify required parameter 'project' is not null or undefined
            assertParamExists('rulesHeadersList', 'project', project)
            const localVarPath = `/api/v2/organizations/{organization}/projects/{project}/rules/headers`
                .replace(`{${"organization"}}`, encodeURIComponent(String(organization)))
                .replace(`{${"project"}}`, encodeURIComponent(String(project)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get details of a header rule
         * @param {string} organization Organization identifier
         * @param {string} project Project identifier
         * @param {string} rule Rule identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rulesHeadersRead: async (organization: string, project: string, rule: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organization' is not null or undefined
            assertParamExists('rulesHeadersRead', 'organization', organization)
            // verify required parameter 'project' is not null or undefined
            assertParamExists('rulesHeadersRead', 'project', project)
            // verify required parameter 'rule' is not null or undefined
            assertParamExists('rulesHeadersRead', 'rule', rule)
            const localVarPath = `/api/v2/organizations/{organization}/projects/{project}/rules/headers/{rule}`
                .replace(`{${"organization"}}`, encodeURIComponent(String(organization)))
                .replace(`{${"project"}}`, encodeURIComponent(String(project)))
                .replace(`{${"rule"}}`, encodeURIComponent(String(rule)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update a header rule
         * @param {string} organization Organization identifier
         * @param {string} project Project identifier
         * @param {string} rule Rule identifier
         * @param {V2RuleHeaderRequest} v2RuleHeaderRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rulesHeadersUpdate: async (organization: string, project: string, rule: string, v2RuleHeaderRequest: V2RuleHeaderRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organization' is not null or undefined
            assertParamExists('rulesHeadersUpdate', 'organization', organization)
            // verify required parameter 'project' is not null or undefined
            assertParamExists('rulesHeadersUpdate', 'project', project)
            // verify required parameter 'rule' is not null or undefined
            assertParamExists('rulesHeadersUpdate', 'rule', rule)
            // verify required parameter 'v2RuleHeaderRequest' is not null or undefined
            assertParamExists('rulesHeadersUpdate', 'v2RuleHeaderRequest', v2RuleHeaderRequest)
            const localVarPath = `/api/v2/organizations/{organization}/projects/{project}/rules/headers/{rule}`
                .replace(`{${"organization"}}`, encodeURIComponent(String(organization)))
                .replace(`{${"project"}}`, encodeURIComponent(String(project)))
                .replace(`{${"rule"}}`, encodeURIComponent(String(rule)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(v2RuleHeaderRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create a proxy rule
         * @param {string} organization 
         * @param {string} project 
         * @param {V2RuleProxyRequest} v2RuleProxyRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rulesProxyCreate: async (organization: string, project: string, v2RuleProxyRequest: V2RuleProxyRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organization' is not null or undefined
            assertParamExists('rulesProxyCreate', 'organization', organization)
            // verify required parameter 'project' is not null or undefined
            assertParamExists('rulesProxyCreate', 'project', project)
            // verify required parameter 'v2RuleProxyRequest' is not null or undefined
            assertParamExists('rulesProxyCreate', 'v2RuleProxyRequest', v2RuleProxyRequest)
            const localVarPath = `/api/v2/organizations/{organization}/projects/{project}/rules/proxy`
                .replace(`{${"organization"}}`, encodeURIComponent(String(organization)))
                .replace(`{${"project"}}`, encodeURIComponent(String(project)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(v2RuleProxyRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a proxy rule
         * @param {string} organization 
         * @param {string} project 
         * @param {string} rule 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rulesProxyDelete: async (organization: string, project: string, rule: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organization' is not null or undefined
            assertParamExists('rulesProxyDelete', 'organization', organization)
            // verify required parameter 'project' is not null or undefined
            assertParamExists('rulesProxyDelete', 'project', project)
            // verify required parameter 'rule' is not null or undefined
            assertParamExists('rulesProxyDelete', 'rule', rule)
            const localVarPath = `/api/v2/organizations/{organization}/projects/{project}/rules/proxy/{rule}`
                .replace(`{${"organization"}}`, encodeURIComponent(String(organization)))
                .replace(`{${"project"}}`, encodeURIComponent(String(project)))
                .replace(`{${"rule"}}`, encodeURIComponent(String(rule)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List proxy rules
         * @param {string} organization 
         * @param {string} project 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rulesProxyList: async (organization: string, project: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organization' is not null or undefined
            assertParamExists('rulesProxyList', 'organization', organization)
            // verify required parameter 'project' is not null or undefined
            assertParamExists('rulesProxyList', 'project', project)
            const localVarPath = `/api/v2/organizations/{organization}/projects/{project}/rules/proxy`
                .replace(`{${"organization"}}`, encodeURIComponent(String(organization)))
                .replace(`{${"project"}}`, encodeURIComponent(String(project)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get details of a proxy rule
         * @param {string} organization 
         * @param {string} project 
         * @param {string} rule 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rulesProxyRead: async (organization: string, project: string, rule: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organization' is not null or undefined
            assertParamExists('rulesProxyRead', 'organization', organization)
            // verify required parameter 'project' is not null or undefined
            assertParamExists('rulesProxyRead', 'project', project)
            // verify required parameter 'rule' is not null or undefined
            assertParamExists('rulesProxyRead', 'rule', rule)
            const localVarPath = `/api/v2/organizations/{organization}/projects/{project}/rules/proxy/{rule}`
                .replace(`{${"organization"}}`, encodeURIComponent(String(organization)))
                .replace(`{${"project"}}`, encodeURIComponent(String(project)))
                .replace(`{${"rule"}}`, encodeURIComponent(String(rule)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update a proxy rule
         * @param {string} organization 
         * @param {string} project 
         * @param {string} rule 
         * @param {V2RuleProxyRequest} v2RuleProxyRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rulesProxyUpdate: async (organization: string, project: string, rule: string, v2RuleProxyRequest: V2RuleProxyRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organization' is not null or undefined
            assertParamExists('rulesProxyUpdate', 'organization', organization)
            // verify required parameter 'project' is not null or undefined
            assertParamExists('rulesProxyUpdate', 'project', project)
            // verify required parameter 'rule' is not null or undefined
            assertParamExists('rulesProxyUpdate', 'rule', rule)
            // verify required parameter 'v2RuleProxyRequest' is not null or undefined
            assertParamExists('rulesProxyUpdate', 'v2RuleProxyRequest', v2RuleProxyRequest)
            const localVarPath = `/api/v2/organizations/{organization}/projects/{project}/rules/proxy/{rule}`
                .replace(`{${"organization"}}`, encodeURIComponent(String(organization)))
                .replace(`{${"project"}}`, encodeURIComponent(String(project)))
                .replace(`{${"rule"}}`, encodeURIComponent(String(rule)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(v2RuleProxyRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create a redirect rule
         * @param {string} organization 
         * @param {string} project 
         * @param {V2RuleRedirectRequest} v2RuleRedirectRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rulesRedirectCreate: async (organization: string, project: string, v2RuleRedirectRequest: V2RuleRedirectRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organization' is not null or undefined
            assertParamExists('rulesRedirectCreate', 'organization', organization)
            // verify required parameter 'project' is not null or undefined
            assertParamExists('rulesRedirectCreate', 'project', project)
            // verify required parameter 'v2RuleRedirectRequest' is not null or undefined
            assertParamExists('rulesRedirectCreate', 'v2RuleRedirectRequest', v2RuleRedirectRequest)
            const localVarPath = `/api/v2/organizations/{organization}/projects/{project}/rules/redirect`
                .replace(`{${"organization"}}`, encodeURIComponent(String(organization)))
                .replace(`{${"project"}}`, encodeURIComponent(String(project)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(v2RuleRedirectRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a redirect rule
         * @param {string} organization 
         * @param {string} project 
         * @param {string} rule 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rulesRedirectDelete: async (organization: string, project: string, rule: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organization' is not null or undefined
            assertParamExists('rulesRedirectDelete', 'organization', organization)
            // verify required parameter 'project' is not null or undefined
            assertParamExists('rulesRedirectDelete', 'project', project)
            // verify required parameter 'rule' is not null or undefined
            assertParamExists('rulesRedirectDelete', 'rule', rule)
            const localVarPath = `/api/v2/organizations/{organization}/projects/{project}/rules/redirect/{rule}`
                .replace(`{${"organization"}}`, encodeURIComponent(String(organization)))
                .replace(`{${"project"}}`, encodeURIComponent(String(project)))
                .replace(`{${"rule"}}`, encodeURIComponent(String(rule)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List redirect rules
         * @param {string} organization 
         * @param {string} project 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rulesRedirectList: async (organization: string, project: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organization' is not null or undefined
            assertParamExists('rulesRedirectList', 'organization', organization)
            // verify required parameter 'project' is not null or undefined
            assertParamExists('rulesRedirectList', 'project', project)
            const localVarPath = `/api/v2/organizations/{organization}/projects/{project}/rules/redirect`
                .replace(`{${"organization"}}`, encodeURIComponent(String(organization)))
                .replace(`{${"project"}}`, encodeURIComponent(String(project)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get details of a redirect rule
         * @param {string} organization 
         * @param {string} project 
         * @param {string} rule 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rulesRedirectRead: async (organization: string, project: string, rule: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organization' is not null or undefined
            assertParamExists('rulesRedirectRead', 'organization', organization)
            // verify required parameter 'project' is not null or undefined
            assertParamExists('rulesRedirectRead', 'project', project)
            // verify required parameter 'rule' is not null or undefined
            assertParamExists('rulesRedirectRead', 'rule', rule)
            const localVarPath = `/api/v2/organizations/{organization}/projects/{project}/rules/redirect/{rule}`
                .replace(`{${"organization"}}`, encodeURIComponent(String(organization)))
                .replace(`{${"project"}}`, encodeURIComponent(String(project)))
                .replace(`{${"rule"}}`, encodeURIComponent(String(rule)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update a redirect rule
         * @param {string} organization 
         * @param {string} project 
         * @param {string} rule 
         * @param {V2RuleRedirectRequest} v2RuleRedirectRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rulesRedirectUpdate: async (organization: string, project: string, rule: string, v2RuleRedirectRequest: V2RuleRedirectRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organization' is not null or undefined
            assertParamExists('rulesRedirectUpdate', 'organization', organization)
            // verify required parameter 'project' is not null or undefined
            assertParamExists('rulesRedirectUpdate', 'project', project)
            // verify required parameter 'rule' is not null or undefined
            assertParamExists('rulesRedirectUpdate', 'rule', rule)
            // verify required parameter 'v2RuleRedirectRequest' is not null or undefined
            assertParamExists('rulesRedirectUpdate', 'v2RuleRedirectRequest', v2RuleRedirectRequest)
            const localVarPath = `/api/v2/organizations/{organization}/projects/{project}/rules/redirect/{rule}`
                .replace(`{${"organization"}}`, encodeURIComponent(String(organization)))
                .replace(`{${"project"}}`, encodeURIComponent(String(project)))
                .replace(`{${"rule"}}`, encodeURIComponent(String(rule)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(v2RuleRedirectRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create a serve static rule
         * @param {string} organization Organization identifier
         * @param {string} project Project identifier
         * @param {V2RuleServeStaticRequest} v2RuleServeStaticRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rulesServeStaticCreate: async (organization: string, project: string, v2RuleServeStaticRequest: V2RuleServeStaticRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organization' is not null or undefined
            assertParamExists('rulesServeStaticCreate', 'organization', organization)
            // verify required parameter 'project' is not null or undefined
            assertParamExists('rulesServeStaticCreate', 'project', project)
            // verify required parameter 'v2RuleServeStaticRequest' is not null or undefined
            assertParamExists('rulesServeStaticCreate', 'v2RuleServeStaticRequest', v2RuleServeStaticRequest)
            const localVarPath = `/api/v2/organizations/{organization}/projects/{project}/rules/serve-static`
                .replace(`{${"organization"}}`, encodeURIComponent(String(organization)))
                .replace(`{${"project"}}`, encodeURIComponent(String(project)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(v2RuleServeStaticRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a serve static rule
         * @param {string} organization Organization identifier
         * @param {string} project Project identifier
         * @param {string} rule Rule identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rulesServeStaticDelete: async (organization: string, project: string, rule: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organization' is not null or undefined
            assertParamExists('rulesServeStaticDelete', 'organization', organization)
            // verify required parameter 'project' is not null or undefined
            assertParamExists('rulesServeStaticDelete', 'project', project)
            // verify required parameter 'rule' is not null or undefined
            assertParamExists('rulesServeStaticDelete', 'rule', rule)
            const localVarPath = `/api/v2/organizations/{organization}/projects/{project}/rules/serve-static/{rule}`
                .replace(`{${"organization"}}`, encodeURIComponent(String(organization)))
                .replace(`{${"project"}}`, encodeURIComponent(String(project)))
                .replace(`{${"rule"}}`, encodeURIComponent(String(rule)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List serve static rules
         * @param {string} organization Organization identifier
         * @param {string} project Project identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rulesServeStaticList: async (organization: string, project: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organization' is not null or undefined
            assertParamExists('rulesServeStaticList', 'organization', organization)
            // verify required parameter 'project' is not null or undefined
            assertParamExists('rulesServeStaticList', 'project', project)
            const localVarPath = `/api/v2/organizations/{organization}/projects/{project}/rules/serve-static`
                .replace(`{${"organization"}}`, encodeURIComponent(String(organization)))
                .replace(`{${"project"}}`, encodeURIComponent(String(project)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get details of a serve static rule
         * @param {string} organization Organization identifier
         * @param {string} project Project identifier
         * @param {string} rule Rule identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rulesServeStaticRead: async (organization: string, project: string, rule: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organization' is not null or undefined
            assertParamExists('rulesServeStaticRead', 'organization', organization)
            // verify required parameter 'project' is not null or undefined
            assertParamExists('rulesServeStaticRead', 'project', project)
            // verify required parameter 'rule' is not null or undefined
            assertParamExists('rulesServeStaticRead', 'rule', rule)
            const localVarPath = `/api/v2/organizations/{organization}/projects/{project}/rules/serve-static/{rule}`
                .replace(`{${"organization"}}`, encodeURIComponent(String(organization)))
                .replace(`{${"project"}}`, encodeURIComponent(String(project)))
                .replace(`{${"rule"}}`, encodeURIComponent(String(rule)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update a serve static rule
         * @param {string} organization Organization identifier
         * @param {string} project Project identifier
         * @param {string} rule Rule identifier
         * @param {V2RuleServeStaticRequest} v2RuleServeStaticRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rulesServeStaticUpdate: async (organization: string, project: string, rule: string, v2RuleServeStaticRequest: V2RuleServeStaticRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organization' is not null or undefined
            assertParamExists('rulesServeStaticUpdate', 'organization', organization)
            // verify required parameter 'project' is not null or undefined
            assertParamExists('rulesServeStaticUpdate', 'project', project)
            // verify required parameter 'rule' is not null or undefined
            assertParamExists('rulesServeStaticUpdate', 'rule', rule)
            // verify required parameter 'v2RuleServeStaticRequest' is not null or undefined
            assertParamExists('rulesServeStaticUpdate', 'v2RuleServeStaticRequest', v2RuleServeStaticRequest)
            const localVarPath = `/api/v2/organizations/{organization}/projects/{project}/rules/serve-static/{rule}`
                .replace(`{${"organization"}}`, encodeURIComponent(String(organization)))
                .replace(`{${"project"}}`, encodeURIComponent(String(project)))
                .replace(`{${"rule"}}`, encodeURIComponent(String(rule)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(v2RuleServeStaticRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * RulesApi - functional programming interface
 * @export
 */
export const RulesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = RulesApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Create an authentication rule
         * @param {string} organization Organization identifier
         * @param {string} project Project identifier
         * @param {V2RuleAuthRequest} v2RuleAuthRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async rulesAuthCreate(organization: string, project: string, v2RuleAuthRequest: V2RuleAuthRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<V2RuleAuth>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.rulesAuthCreate(organization, project, v2RuleAuthRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RulesApi.rulesAuthCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete an authentication rule
         * @param {string} organization Organization identifier
         * @param {string} project Project identifier
         * @param {string} rule Rule identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async rulesAuthDelete(organization: string, project: string, rule: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.rulesAuthDelete(organization, project, rule, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RulesApi.rulesAuthDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary List authentication rules
         * @param {string} organization Organization identifier
         * @param {string} project Project identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async rulesAuthList(organization: string, project: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<V2RuleAuth>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.rulesAuthList(organization, project, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RulesApi.rulesAuthList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get details of an authentication rule
         * @param {string} organization Organization identifier
         * @param {string} project Project identifier
         * @param {string} rule Rule identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async rulesAuthRead(organization: string, project: string, rule: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<V2RuleAuth>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.rulesAuthRead(organization, project, rule, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RulesApi.rulesAuthRead']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update an authentication rule
         * @param {string} organization Organization identifier
         * @param {string} project Project identifier
         * @param {string} rule Rule identifier
         * @param {V2RuleAuthRequest} v2RuleAuthRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async rulesAuthUpdate(organization: string, project: string, rule: string, v2RuleAuthRequest: V2RuleAuthRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<V2RuleAuth>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.rulesAuthUpdate(organization, project, rule, v2RuleAuthRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RulesApi.rulesAuthUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Create a bot challenge rule
         * @param {string} organization Organization identifier
         * @param {string} project Project identifier
         * @param {V2RuleBotChallengeRequest} v2RuleBotChallengeRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async rulesBotChallengeCreate(organization: string, project: string, v2RuleBotChallengeRequest: V2RuleBotChallengeRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<V2RuleBotChallenge>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.rulesBotChallengeCreate(organization, project, v2RuleBotChallengeRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RulesApi.rulesBotChallengeCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete a bot challenge rule
         * @param {string} organization Organization identifier
         * @param {string} project Project identifier
         * @param {string} rule Rule identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async rulesBotChallengeDelete(organization: string, project: string, rule: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.rulesBotChallengeDelete(organization, project, rule, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RulesApi.rulesBotChallengeDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary List bot challenge rules
         * @param {string} organization Organization identifier
         * @param {string} project Project identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async rulesBotChallengeList(organization: string, project: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<V2RuleBotChallenge>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.rulesBotChallengeList(organization, project, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RulesApi.rulesBotChallengeList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get details of a bot challenge rule
         * @param {string} organization Organization identifier
         * @param {string} project Project identifier
         * @param {string} rule Rule identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async rulesBotChallengeRead(organization: string, project: string, rule: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<V2RuleBotChallenge>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.rulesBotChallengeRead(organization, project, rule, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RulesApi.rulesBotChallengeRead']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update a bot challenge rule
         * @param {string} organization Organization identifier
         * @param {string} project Project identifier
         * @param {string} rule Rule identifier
         * @param {V2RuleBotChallengeRequest} v2RuleBotChallengeRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async rulesBotChallengeUpdate(organization: string, project: string, rule: string, v2RuleBotChallengeRequest: V2RuleBotChallengeRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<V2RuleBotChallenge>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.rulesBotChallengeUpdate(organization, project, rule, v2RuleBotChallengeRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RulesApi.rulesBotChallengeUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Create a content filter rule
         * @param {string} organization Organization identifier
         * @param {string} project Project identifier
         * @param {V2RuleContentFilterRequest} v2RuleContentFilterRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async rulesContentFilterCreate(organization: string, project: string, v2RuleContentFilterRequest: V2RuleContentFilterRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<V2RuleContentFilter>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.rulesContentFilterCreate(organization, project, v2RuleContentFilterRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RulesApi.rulesContentFilterCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete a content filter rule
         * @param {string} organization Organization identifier
         * @param {string} project Project identifier
         * @param {string} rule Rule identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async rulesContentFilterDelete(organization: string, project: string, rule: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.rulesContentFilterDelete(organization, project, rule, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RulesApi.rulesContentFilterDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary List content filter rules
         * @param {string} organization Organization identifier
         * @param {string} project Project identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async rulesContentFilterList(organization: string, project: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<V2RuleContentFilter>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.rulesContentFilterList(organization, project, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RulesApi.rulesContentFilterList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get details of a content filter rule
         * @param {string} organization Organization identifier
         * @param {string} project Project identifier
         * @param {string} rule Rule identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async rulesContentFilterRead(organization: string, project: string, rule: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<V2RuleContentFilter>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.rulesContentFilterRead(organization, project, rule, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RulesApi.rulesContentFilterRead']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update a content filter rule
         * @param {string} organization Organization identifier
         * @param {string} project Project identifier
         * @param {string} rule Rule identifier
         * @param {V2RuleContentFilterRequest} v2RuleContentFilterRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async rulesContentFilterUpdate(organization: string, project: string, rule: string, v2RuleContentFilterRequest: V2RuleContentFilterRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<V2RuleContentFilter>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.rulesContentFilterUpdate(organization, project, rule, v2RuleContentFilterRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RulesApi.rulesContentFilterUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Create a custom response rule
         * @param {string} organization Organization identifier
         * @param {string} project Project identifier
         * @param {V2RuleCustomResponseRequest} v2RuleCustomResponseRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async rulesCustomResponseCreate(organization: string, project: string, v2RuleCustomResponseRequest: V2RuleCustomResponseRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<V2RuleCustomResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.rulesCustomResponseCreate(organization, project, v2RuleCustomResponseRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RulesApi.rulesCustomResponseCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete a custom response rule
         * @param {string} organization Organization identifier
         * @param {string} project Project identifier
         * @param {string} rule Rule identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async rulesCustomResponseDelete(organization: string, project: string, rule: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.rulesCustomResponseDelete(organization, project, rule, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RulesApi.rulesCustomResponseDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary List custom response rules
         * @param {string} organization Organization identifier
         * @param {string} project Project identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async rulesCustomResponseList(organization: string, project: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<V2RuleCustomResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.rulesCustomResponseList(organization, project, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RulesApi.rulesCustomResponseList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get details of a custom response rule
         * @param {string} organization Organization identifier
         * @param {string} project Project identifier
         * @param {string} rule Rule identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async rulesCustomResponseRead(organization: string, project: string, rule: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<V2RuleCustomResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.rulesCustomResponseRead(organization, project, rule, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RulesApi.rulesCustomResponseRead']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update a custom response rule
         * @param {string} organization Organization identifier
         * @param {string} project Project identifier
         * @param {string} rule Rule identifier
         * @param {V2RuleCustomResponseRequest} v2RuleCustomResponseRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async rulesCustomResponseUpdate(organization: string, project: string, rule: string, v2RuleCustomResponseRequest: V2RuleCustomResponseRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<V2RuleCustomResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.rulesCustomResponseUpdate(organization, project, rule, v2RuleCustomResponseRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RulesApi.rulesCustomResponseUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Create an edge function rule
         * @param {string} organization Organization identifier
         * @param {string} project Project identifier
         * @param {V2RuleFunctionRequest} v2RuleFunctionRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async rulesFunctionCreate(organization: string, project: string, v2RuleFunctionRequest: V2RuleFunctionRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<V2RuleFunction>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.rulesFunctionCreate(organization, project, v2RuleFunctionRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RulesApi.rulesFunctionCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete an edge function rule
         * @param {string} organization Organization identifier
         * @param {string} project Project identifier
         * @param {string} rule Rule identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async rulesFunctionDelete(organization: string, project: string, rule: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.rulesFunctionDelete(organization, project, rule, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RulesApi.rulesFunctionDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary List edge function rules
         * @param {string} organization Organization identifier
         * @param {string} project Project identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async rulesFunctionList(organization: string, project: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<V2RuleFunction>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.rulesFunctionList(organization, project, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RulesApi.rulesFunctionList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get details of an edge function rule
         * @param {string} organization Organization identifier
         * @param {string} project Project identifier
         * @param {string} rule Rule identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async rulesFunctionRead(organization: string, project: string, rule: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<V2RuleFunction>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.rulesFunctionRead(organization, project, rule, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RulesApi.rulesFunctionRead']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update an edge function rule
         * @param {string} organization Organization identifier
         * @param {string} project Project identifier
         * @param {string} rule Rule identifier
         * @param {V2RuleFunctionRequest} v2RuleFunctionRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async rulesFunctionUpdate(organization: string, project: string, rule: string, v2RuleFunctionRequest: V2RuleFunctionRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<V2RuleFunction>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.rulesFunctionUpdate(organization, project, rule, v2RuleFunctionRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RulesApi.rulesFunctionUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Create a header rule
         * @param {string} organization Organization identifier
         * @param {string} project Project identifier
         * @param {V2RuleHeaderRequest} v2RuleHeaderRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async rulesHeadersCreate(organization: string, project: string, v2RuleHeaderRequest: V2RuleHeaderRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<V2RuleHeader>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.rulesHeadersCreate(organization, project, v2RuleHeaderRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RulesApi.rulesHeadersCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete a header rule
         * @param {string} organization Organization identifier
         * @param {string} project Project identifier
         * @param {string} rule Rule identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async rulesHeadersDelete(organization: string, project: string, rule: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.rulesHeadersDelete(organization, project, rule, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RulesApi.rulesHeadersDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary List header rules
         * @param {string} organization Organization identifier
         * @param {string} project Project identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async rulesHeadersList(organization: string, project: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<V2RuleHeader>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.rulesHeadersList(organization, project, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RulesApi.rulesHeadersList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get details of a header rule
         * @param {string} organization Organization identifier
         * @param {string} project Project identifier
         * @param {string} rule Rule identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async rulesHeadersRead(organization: string, project: string, rule: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<V2RuleHeader>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.rulesHeadersRead(organization, project, rule, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RulesApi.rulesHeadersRead']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update a header rule
         * @param {string} organization Organization identifier
         * @param {string} project Project identifier
         * @param {string} rule Rule identifier
         * @param {V2RuleHeaderRequest} v2RuleHeaderRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async rulesHeadersUpdate(organization: string, project: string, rule: string, v2RuleHeaderRequest: V2RuleHeaderRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<V2RuleHeader>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.rulesHeadersUpdate(organization, project, rule, v2RuleHeaderRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RulesApi.rulesHeadersUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Create a proxy rule
         * @param {string} organization 
         * @param {string} project 
         * @param {V2RuleProxyRequest} v2RuleProxyRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async rulesProxyCreate(organization: string, project: string, v2RuleProxyRequest: V2RuleProxyRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<V2RuleProxy>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.rulesProxyCreate(organization, project, v2RuleProxyRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RulesApi.rulesProxyCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete a proxy rule
         * @param {string} organization 
         * @param {string} project 
         * @param {string} rule 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async rulesProxyDelete(organization: string, project: string, rule: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.rulesProxyDelete(organization, project, rule, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RulesApi.rulesProxyDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary List proxy rules
         * @param {string} organization 
         * @param {string} project 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async rulesProxyList(organization: string, project: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<V2RuleProxy>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.rulesProxyList(organization, project, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RulesApi.rulesProxyList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get details of a proxy rule
         * @param {string} organization 
         * @param {string} project 
         * @param {string} rule 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async rulesProxyRead(organization: string, project: string, rule: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<V2RuleProxy>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.rulesProxyRead(organization, project, rule, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RulesApi.rulesProxyRead']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update a proxy rule
         * @param {string} organization 
         * @param {string} project 
         * @param {string} rule 
         * @param {V2RuleProxyRequest} v2RuleProxyRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async rulesProxyUpdate(organization: string, project: string, rule: string, v2RuleProxyRequest: V2RuleProxyRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<V2RuleProxy>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.rulesProxyUpdate(organization, project, rule, v2RuleProxyRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RulesApi.rulesProxyUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Create a redirect rule
         * @param {string} organization 
         * @param {string} project 
         * @param {V2RuleRedirectRequest} v2RuleRedirectRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async rulesRedirectCreate(organization: string, project: string, v2RuleRedirectRequest: V2RuleRedirectRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<V2RuleRedirect>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.rulesRedirectCreate(organization, project, v2RuleRedirectRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RulesApi.rulesRedirectCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete a redirect rule
         * @param {string} organization 
         * @param {string} project 
         * @param {string} rule 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async rulesRedirectDelete(organization: string, project: string, rule: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.rulesRedirectDelete(organization, project, rule, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RulesApi.rulesRedirectDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary List redirect rules
         * @param {string} organization 
         * @param {string} project 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async rulesRedirectList(organization: string, project: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<V2RuleRedirect>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.rulesRedirectList(organization, project, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RulesApi.rulesRedirectList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get details of a redirect rule
         * @param {string} organization 
         * @param {string} project 
         * @param {string} rule 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async rulesRedirectRead(organization: string, project: string, rule: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<V2RuleRedirect>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.rulesRedirectRead(organization, project, rule, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RulesApi.rulesRedirectRead']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update a redirect rule
         * @param {string} organization 
         * @param {string} project 
         * @param {string} rule 
         * @param {V2RuleRedirectRequest} v2RuleRedirectRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async rulesRedirectUpdate(organization: string, project: string, rule: string, v2RuleRedirectRequest: V2RuleRedirectRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<V2RuleRedirect>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.rulesRedirectUpdate(organization, project, rule, v2RuleRedirectRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RulesApi.rulesRedirectUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Create a serve static rule
         * @param {string} organization Organization identifier
         * @param {string} project Project identifier
         * @param {V2RuleServeStaticRequest} v2RuleServeStaticRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async rulesServeStaticCreate(organization: string, project: string, v2RuleServeStaticRequest: V2RuleServeStaticRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<V2RuleServeStatic>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.rulesServeStaticCreate(organization, project, v2RuleServeStaticRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RulesApi.rulesServeStaticCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete a serve static rule
         * @param {string} organization Organization identifier
         * @param {string} project Project identifier
         * @param {string} rule Rule identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async rulesServeStaticDelete(organization: string, project: string, rule: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.rulesServeStaticDelete(organization, project, rule, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RulesApi.rulesServeStaticDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary List serve static rules
         * @param {string} organization Organization identifier
         * @param {string} project Project identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async rulesServeStaticList(organization: string, project: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<V2RuleServeStatic>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.rulesServeStaticList(organization, project, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RulesApi.rulesServeStaticList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get details of a serve static rule
         * @param {string} organization Organization identifier
         * @param {string} project Project identifier
         * @param {string} rule Rule identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async rulesServeStaticRead(organization: string, project: string, rule: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<V2RuleServeStatic>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.rulesServeStaticRead(organization, project, rule, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RulesApi.rulesServeStaticRead']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update a serve static rule
         * @param {string} organization Organization identifier
         * @param {string} project Project identifier
         * @param {string} rule Rule identifier
         * @param {V2RuleServeStaticRequest} v2RuleServeStaticRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async rulesServeStaticUpdate(organization: string, project: string, rule: string, v2RuleServeStaticRequest: V2RuleServeStaticRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<V2RuleServeStatic>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.rulesServeStaticUpdate(organization, project, rule, v2RuleServeStaticRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RulesApi.rulesServeStaticUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * RulesApi - factory interface
 * @export
 */
export const RulesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = RulesApiFp(configuration)
    return {
        /**
         * 
         * @summary Create an authentication rule
         * @param {string} organization Organization identifier
         * @param {string} project Project identifier
         * @param {V2RuleAuthRequest} v2RuleAuthRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rulesAuthCreate(organization: string, project: string, v2RuleAuthRequest: V2RuleAuthRequest, options?: RawAxiosRequestConfig): AxiosPromise<V2RuleAuth> {
            return localVarFp.rulesAuthCreate(organization, project, v2RuleAuthRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete an authentication rule
         * @param {string} organization Organization identifier
         * @param {string} project Project identifier
         * @param {string} rule Rule identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rulesAuthDelete(organization: string, project: string, rule: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.rulesAuthDelete(organization, project, rule, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List authentication rules
         * @param {string} organization Organization identifier
         * @param {string} project Project identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rulesAuthList(organization: string, project: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<V2RuleAuth>> {
            return localVarFp.rulesAuthList(organization, project, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get details of an authentication rule
         * @param {string} organization Organization identifier
         * @param {string} project Project identifier
         * @param {string} rule Rule identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rulesAuthRead(organization: string, project: string, rule: string, options?: RawAxiosRequestConfig): AxiosPromise<V2RuleAuth> {
            return localVarFp.rulesAuthRead(organization, project, rule, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update an authentication rule
         * @param {string} organization Organization identifier
         * @param {string} project Project identifier
         * @param {string} rule Rule identifier
         * @param {V2RuleAuthRequest} v2RuleAuthRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rulesAuthUpdate(organization: string, project: string, rule: string, v2RuleAuthRequest: V2RuleAuthRequest, options?: RawAxiosRequestConfig): AxiosPromise<V2RuleAuth> {
            return localVarFp.rulesAuthUpdate(organization, project, rule, v2RuleAuthRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create a bot challenge rule
         * @param {string} organization Organization identifier
         * @param {string} project Project identifier
         * @param {V2RuleBotChallengeRequest} v2RuleBotChallengeRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rulesBotChallengeCreate(organization: string, project: string, v2RuleBotChallengeRequest: V2RuleBotChallengeRequest, options?: RawAxiosRequestConfig): AxiosPromise<V2RuleBotChallenge> {
            return localVarFp.rulesBotChallengeCreate(organization, project, v2RuleBotChallengeRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete a bot challenge rule
         * @param {string} organization Organization identifier
         * @param {string} project Project identifier
         * @param {string} rule Rule identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rulesBotChallengeDelete(organization: string, project: string, rule: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.rulesBotChallengeDelete(organization, project, rule, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List bot challenge rules
         * @param {string} organization Organization identifier
         * @param {string} project Project identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rulesBotChallengeList(organization: string, project: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<V2RuleBotChallenge>> {
            return localVarFp.rulesBotChallengeList(organization, project, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get details of a bot challenge rule
         * @param {string} organization Organization identifier
         * @param {string} project Project identifier
         * @param {string} rule Rule identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rulesBotChallengeRead(organization: string, project: string, rule: string, options?: RawAxiosRequestConfig): AxiosPromise<V2RuleBotChallenge> {
            return localVarFp.rulesBotChallengeRead(organization, project, rule, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update a bot challenge rule
         * @param {string} organization Organization identifier
         * @param {string} project Project identifier
         * @param {string} rule Rule identifier
         * @param {V2RuleBotChallengeRequest} v2RuleBotChallengeRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rulesBotChallengeUpdate(organization: string, project: string, rule: string, v2RuleBotChallengeRequest: V2RuleBotChallengeRequest, options?: RawAxiosRequestConfig): AxiosPromise<V2RuleBotChallenge> {
            return localVarFp.rulesBotChallengeUpdate(organization, project, rule, v2RuleBotChallengeRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create a content filter rule
         * @param {string} organization Organization identifier
         * @param {string} project Project identifier
         * @param {V2RuleContentFilterRequest} v2RuleContentFilterRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rulesContentFilterCreate(organization: string, project: string, v2RuleContentFilterRequest: V2RuleContentFilterRequest, options?: RawAxiosRequestConfig): AxiosPromise<V2RuleContentFilter> {
            return localVarFp.rulesContentFilterCreate(organization, project, v2RuleContentFilterRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete a content filter rule
         * @param {string} organization Organization identifier
         * @param {string} project Project identifier
         * @param {string} rule Rule identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rulesContentFilterDelete(organization: string, project: string, rule: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.rulesContentFilterDelete(organization, project, rule, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List content filter rules
         * @param {string} organization Organization identifier
         * @param {string} project Project identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rulesContentFilterList(organization: string, project: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<V2RuleContentFilter>> {
            return localVarFp.rulesContentFilterList(organization, project, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get details of a content filter rule
         * @param {string} organization Organization identifier
         * @param {string} project Project identifier
         * @param {string} rule Rule identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rulesContentFilterRead(organization: string, project: string, rule: string, options?: RawAxiosRequestConfig): AxiosPromise<V2RuleContentFilter> {
            return localVarFp.rulesContentFilterRead(organization, project, rule, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update a content filter rule
         * @param {string} organization Organization identifier
         * @param {string} project Project identifier
         * @param {string} rule Rule identifier
         * @param {V2RuleContentFilterRequest} v2RuleContentFilterRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rulesContentFilterUpdate(organization: string, project: string, rule: string, v2RuleContentFilterRequest: V2RuleContentFilterRequest, options?: RawAxiosRequestConfig): AxiosPromise<V2RuleContentFilter> {
            return localVarFp.rulesContentFilterUpdate(organization, project, rule, v2RuleContentFilterRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create a custom response rule
         * @param {string} organization Organization identifier
         * @param {string} project Project identifier
         * @param {V2RuleCustomResponseRequest} v2RuleCustomResponseRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rulesCustomResponseCreate(organization: string, project: string, v2RuleCustomResponseRequest: V2RuleCustomResponseRequest, options?: RawAxiosRequestConfig): AxiosPromise<V2RuleCustomResponse> {
            return localVarFp.rulesCustomResponseCreate(organization, project, v2RuleCustomResponseRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete a custom response rule
         * @param {string} organization Organization identifier
         * @param {string} project Project identifier
         * @param {string} rule Rule identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rulesCustomResponseDelete(organization: string, project: string, rule: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.rulesCustomResponseDelete(organization, project, rule, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List custom response rules
         * @param {string} organization Organization identifier
         * @param {string} project Project identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rulesCustomResponseList(organization: string, project: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<V2RuleCustomResponse>> {
            return localVarFp.rulesCustomResponseList(organization, project, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get details of a custom response rule
         * @param {string} organization Organization identifier
         * @param {string} project Project identifier
         * @param {string} rule Rule identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rulesCustomResponseRead(organization: string, project: string, rule: string, options?: RawAxiosRequestConfig): AxiosPromise<V2RuleCustomResponse> {
            return localVarFp.rulesCustomResponseRead(organization, project, rule, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update a custom response rule
         * @param {string} organization Organization identifier
         * @param {string} project Project identifier
         * @param {string} rule Rule identifier
         * @param {V2RuleCustomResponseRequest} v2RuleCustomResponseRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rulesCustomResponseUpdate(organization: string, project: string, rule: string, v2RuleCustomResponseRequest: V2RuleCustomResponseRequest, options?: RawAxiosRequestConfig): AxiosPromise<V2RuleCustomResponse> {
            return localVarFp.rulesCustomResponseUpdate(organization, project, rule, v2RuleCustomResponseRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create an edge function rule
         * @param {string} organization Organization identifier
         * @param {string} project Project identifier
         * @param {V2RuleFunctionRequest} v2RuleFunctionRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rulesFunctionCreate(organization: string, project: string, v2RuleFunctionRequest: V2RuleFunctionRequest, options?: RawAxiosRequestConfig): AxiosPromise<V2RuleFunction> {
            return localVarFp.rulesFunctionCreate(organization, project, v2RuleFunctionRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete an edge function rule
         * @param {string} organization Organization identifier
         * @param {string} project Project identifier
         * @param {string} rule Rule identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rulesFunctionDelete(organization: string, project: string, rule: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.rulesFunctionDelete(organization, project, rule, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List edge function rules
         * @param {string} organization Organization identifier
         * @param {string} project Project identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rulesFunctionList(organization: string, project: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<V2RuleFunction>> {
            return localVarFp.rulesFunctionList(organization, project, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get details of an edge function rule
         * @param {string} organization Organization identifier
         * @param {string} project Project identifier
         * @param {string} rule Rule identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rulesFunctionRead(organization: string, project: string, rule: string, options?: RawAxiosRequestConfig): AxiosPromise<V2RuleFunction> {
            return localVarFp.rulesFunctionRead(organization, project, rule, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update an edge function rule
         * @param {string} organization Organization identifier
         * @param {string} project Project identifier
         * @param {string} rule Rule identifier
         * @param {V2RuleFunctionRequest} v2RuleFunctionRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rulesFunctionUpdate(organization: string, project: string, rule: string, v2RuleFunctionRequest: V2RuleFunctionRequest, options?: RawAxiosRequestConfig): AxiosPromise<V2RuleFunction> {
            return localVarFp.rulesFunctionUpdate(organization, project, rule, v2RuleFunctionRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create a header rule
         * @param {string} organization Organization identifier
         * @param {string} project Project identifier
         * @param {V2RuleHeaderRequest} v2RuleHeaderRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rulesHeadersCreate(organization: string, project: string, v2RuleHeaderRequest: V2RuleHeaderRequest, options?: RawAxiosRequestConfig): AxiosPromise<V2RuleHeader> {
            return localVarFp.rulesHeadersCreate(organization, project, v2RuleHeaderRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete a header rule
         * @param {string} organization Organization identifier
         * @param {string} project Project identifier
         * @param {string} rule Rule identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rulesHeadersDelete(organization: string, project: string, rule: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.rulesHeadersDelete(organization, project, rule, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List header rules
         * @param {string} organization Organization identifier
         * @param {string} project Project identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rulesHeadersList(organization: string, project: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<V2RuleHeader>> {
            return localVarFp.rulesHeadersList(organization, project, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get details of a header rule
         * @param {string} organization Organization identifier
         * @param {string} project Project identifier
         * @param {string} rule Rule identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rulesHeadersRead(organization: string, project: string, rule: string, options?: RawAxiosRequestConfig): AxiosPromise<V2RuleHeader> {
            return localVarFp.rulesHeadersRead(organization, project, rule, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update a header rule
         * @param {string} organization Organization identifier
         * @param {string} project Project identifier
         * @param {string} rule Rule identifier
         * @param {V2RuleHeaderRequest} v2RuleHeaderRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rulesHeadersUpdate(organization: string, project: string, rule: string, v2RuleHeaderRequest: V2RuleHeaderRequest, options?: RawAxiosRequestConfig): AxiosPromise<V2RuleHeader> {
            return localVarFp.rulesHeadersUpdate(organization, project, rule, v2RuleHeaderRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create a proxy rule
         * @param {string} organization 
         * @param {string} project 
         * @param {V2RuleProxyRequest} v2RuleProxyRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rulesProxyCreate(organization: string, project: string, v2RuleProxyRequest: V2RuleProxyRequest, options?: RawAxiosRequestConfig): AxiosPromise<V2RuleProxy> {
            return localVarFp.rulesProxyCreate(organization, project, v2RuleProxyRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete a proxy rule
         * @param {string} organization 
         * @param {string} project 
         * @param {string} rule 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rulesProxyDelete(organization: string, project: string, rule: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.rulesProxyDelete(organization, project, rule, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List proxy rules
         * @param {string} organization 
         * @param {string} project 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rulesProxyList(organization: string, project: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<V2RuleProxy>> {
            return localVarFp.rulesProxyList(organization, project, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get details of a proxy rule
         * @param {string} organization 
         * @param {string} project 
         * @param {string} rule 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rulesProxyRead(organization: string, project: string, rule: string, options?: RawAxiosRequestConfig): AxiosPromise<V2RuleProxy> {
            return localVarFp.rulesProxyRead(organization, project, rule, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update a proxy rule
         * @param {string} organization 
         * @param {string} project 
         * @param {string} rule 
         * @param {V2RuleProxyRequest} v2RuleProxyRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rulesProxyUpdate(organization: string, project: string, rule: string, v2RuleProxyRequest: V2RuleProxyRequest, options?: RawAxiosRequestConfig): AxiosPromise<V2RuleProxy> {
            return localVarFp.rulesProxyUpdate(organization, project, rule, v2RuleProxyRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create a redirect rule
         * @param {string} organization 
         * @param {string} project 
         * @param {V2RuleRedirectRequest} v2RuleRedirectRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rulesRedirectCreate(organization: string, project: string, v2RuleRedirectRequest: V2RuleRedirectRequest, options?: RawAxiosRequestConfig): AxiosPromise<V2RuleRedirect> {
            return localVarFp.rulesRedirectCreate(organization, project, v2RuleRedirectRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete a redirect rule
         * @param {string} organization 
         * @param {string} project 
         * @param {string} rule 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rulesRedirectDelete(organization: string, project: string, rule: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.rulesRedirectDelete(organization, project, rule, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List redirect rules
         * @param {string} organization 
         * @param {string} project 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rulesRedirectList(organization: string, project: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<V2RuleRedirect>> {
            return localVarFp.rulesRedirectList(organization, project, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get details of a redirect rule
         * @param {string} organization 
         * @param {string} project 
         * @param {string} rule 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rulesRedirectRead(organization: string, project: string, rule: string, options?: RawAxiosRequestConfig): AxiosPromise<V2RuleRedirect> {
            return localVarFp.rulesRedirectRead(organization, project, rule, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update a redirect rule
         * @param {string} organization 
         * @param {string} project 
         * @param {string} rule 
         * @param {V2RuleRedirectRequest} v2RuleRedirectRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rulesRedirectUpdate(organization: string, project: string, rule: string, v2RuleRedirectRequest: V2RuleRedirectRequest, options?: RawAxiosRequestConfig): AxiosPromise<V2RuleRedirect> {
            return localVarFp.rulesRedirectUpdate(organization, project, rule, v2RuleRedirectRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create a serve static rule
         * @param {string} organization Organization identifier
         * @param {string} project Project identifier
         * @param {V2RuleServeStaticRequest} v2RuleServeStaticRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rulesServeStaticCreate(organization: string, project: string, v2RuleServeStaticRequest: V2RuleServeStaticRequest, options?: RawAxiosRequestConfig): AxiosPromise<V2RuleServeStatic> {
            return localVarFp.rulesServeStaticCreate(organization, project, v2RuleServeStaticRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete a serve static rule
         * @param {string} organization Organization identifier
         * @param {string} project Project identifier
         * @param {string} rule Rule identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rulesServeStaticDelete(organization: string, project: string, rule: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.rulesServeStaticDelete(organization, project, rule, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List serve static rules
         * @param {string} organization Organization identifier
         * @param {string} project Project identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rulesServeStaticList(organization: string, project: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<V2RuleServeStatic>> {
            return localVarFp.rulesServeStaticList(organization, project, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get details of a serve static rule
         * @param {string} organization Organization identifier
         * @param {string} project Project identifier
         * @param {string} rule Rule identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rulesServeStaticRead(organization: string, project: string, rule: string, options?: RawAxiosRequestConfig): AxiosPromise<V2RuleServeStatic> {
            return localVarFp.rulesServeStaticRead(organization, project, rule, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update a serve static rule
         * @param {string} organization Organization identifier
         * @param {string} project Project identifier
         * @param {string} rule Rule identifier
         * @param {V2RuleServeStaticRequest} v2RuleServeStaticRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rulesServeStaticUpdate(organization: string, project: string, rule: string, v2RuleServeStaticRequest: V2RuleServeStaticRequest, options?: RawAxiosRequestConfig): AxiosPromise<V2RuleServeStatic> {
            return localVarFp.rulesServeStaticUpdate(organization, project, rule, v2RuleServeStaticRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * RulesApi - object-oriented interface
 * @export
 * @class RulesApi
 * @extends {BaseAPI}
 */
export class RulesApi extends BaseAPI {
    /**
     * 
     * @summary Create an authentication rule
     * @param {string} organization Organization identifier
     * @param {string} project Project identifier
     * @param {V2RuleAuthRequest} v2RuleAuthRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RulesApi
     */
    public rulesAuthCreate(organization: string, project: string, v2RuleAuthRequest: V2RuleAuthRequest, options?: RawAxiosRequestConfig) {
        return RulesApiFp(this.configuration).rulesAuthCreate(organization, project, v2RuleAuthRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete an authentication rule
     * @param {string} organization Organization identifier
     * @param {string} project Project identifier
     * @param {string} rule Rule identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RulesApi
     */
    public rulesAuthDelete(organization: string, project: string, rule: string, options?: RawAxiosRequestConfig) {
        return RulesApiFp(this.configuration).rulesAuthDelete(organization, project, rule, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List authentication rules
     * @param {string} organization Organization identifier
     * @param {string} project Project identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RulesApi
     */
    public rulesAuthList(organization: string, project: string, options?: RawAxiosRequestConfig) {
        return RulesApiFp(this.configuration).rulesAuthList(organization, project, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get details of an authentication rule
     * @param {string} organization Organization identifier
     * @param {string} project Project identifier
     * @param {string} rule Rule identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RulesApi
     */
    public rulesAuthRead(organization: string, project: string, rule: string, options?: RawAxiosRequestConfig) {
        return RulesApiFp(this.configuration).rulesAuthRead(organization, project, rule, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update an authentication rule
     * @param {string} organization Organization identifier
     * @param {string} project Project identifier
     * @param {string} rule Rule identifier
     * @param {V2RuleAuthRequest} v2RuleAuthRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RulesApi
     */
    public rulesAuthUpdate(organization: string, project: string, rule: string, v2RuleAuthRequest: V2RuleAuthRequest, options?: RawAxiosRequestConfig) {
        return RulesApiFp(this.configuration).rulesAuthUpdate(organization, project, rule, v2RuleAuthRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create a bot challenge rule
     * @param {string} organization Organization identifier
     * @param {string} project Project identifier
     * @param {V2RuleBotChallengeRequest} v2RuleBotChallengeRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RulesApi
     */
    public rulesBotChallengeCreate(organization: string, project: string, v2RuleBotChallengeRequest: V2RuleBotChallengeRequest, options?: RawAxiosRequestConfig) {
        return RulesApiFp(this.configuration).rulesBotChallengeCreate(organization, project, v2RuleBotChallengeRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete a bot challenge rule
     * @param {string} organization Organization identifier
     * @param {string} project Project identifier
     * @param {string} rule Rule identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RulesApi
     */
    public rulesBotChallengeDelete(organization: string, project: string, rule: string, options?: RawAxiosRequestConfig) {
        return RulesApiFp(this.configuration).rulesBotChallengeDelete(organization, project, rule, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List bot challenge rules
     * @param {string} organization Organization identifier
     * @param {string} project Project identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RulesApi
     */
    public rulesBotChallengeList(organization: string, project: string, options?: RawAxiosRequestConfig) {
        return RulesApiFp(this.configuration).rulesBotChallengeList(organization, project, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get details of a bot challenge rule
     * @param {string} organization Organization identifier
     * @param {string} project Project identifier
     * @param {string} rule Rule identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RulesApi
     */
    public rulesBotChallengeRead(organization: string, project: string, rule: string, options?: RawAxiosRequestConfig) {
        return RulesApiFp(this.configuration).rulesBotChallengeRead(organization, project, rule, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update a bot challenge rule
     * @param {string} organization Organization identifier
     * @param {string} project Project identifier
     * @param {string} rule Rule identifier
     * @param {V2RuleBotChallengeRequest} v2RuleBotChallengeRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RulesApi
     */
    public rulesBotChallengeUpdate(organization: string, project: string, rule: string, v2RuleBotChallengeRequest: V2RuleBotChallengeRequest, options?: RawAxiosRequestConfig) {
        return RulesApiFp(this.configuration).rulesBotChallengeUpdate(organization, project, rule, v2RuleBotChallengeRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create a content filter rule
     * @param {string} organization Organization identifier
     * @param {string} project Project identifier
     * @param {V2RuleContentFilterRequest} v2RuleContentFilterRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RulesApi
     */
    public rulesContentFilterCreate(organization: string, project: string, v2RuleContentFilterRequest: V2RuleContentFilterRequest, options?: RawAxiosRequestConfig) {
        return RulesApiFp(this.configuration).rulesContentFilterCreate(organization, project, v2RuleContentFilterRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete a content filter rule
     * @param {string} organization Organization identifier
     * @param {string} project Project identifier
     * @param {string} rule Rule identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RulesApi
     */
    public rulesContentFilterDelete(organization: string, project: string, rule: string, options?: RawAxiosRequestConfig) {
        return RulesApiFp(this.configuration).rulesContentFilterDelete(organization, project, rule, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List content filter rules
     * @param {string} organization Organization identifier
     * @param {string} project Project identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RulesApi
     */
    public rulesContentFilterList(organization: string, project: string, options?: RawAxiosRequestConfig) {
        return RulesApiFp(this.configuration).rulesContentFilterList(organization, project, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get details of a content filter rule
     * @param {string} organization Organization identifier
     * @param {string} project Project identifier
     * @param {string} rule Rule identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RulesApi
     */
    public rulesContentFilterRead(organization: string, project: string, rule: string, options?: RawAxiosRequestConfig) {
        return RulesApiFp(this.configuration).rulesContentFilterRead(organization, project, rule, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update a content filter rule
     * @param {string} organization Organization identifier
     * @param {string} project Project identifier
     * @param {string} rule Rule identifier
     * @param {V2RuleContentFilterRequest} v2RuleContentFilterRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RulesApi
     */
    public rulesContentFilterUpdate(organization: string, project: string, rule: string, v2RuleContentFilterRequest: V2RuleContentFilterRequest, options?: RawAxiosRequestConfig) {
        return RulesApiFp(this.configuration).rulesContentFilterUpdate(organization, project, rule, v2RuleContentFilterRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create a custom response rule
     * @param {string} organization Organization identifier
     * @param {string} project Project identifier
     * @param {V2RuleCustomResponseRequest} v2RuleCustomResponseRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RulesApi
     */
    public rulesCustomResponseCreate(organization: string, project: string, v2RuleCustomResponseRequest: V2RuleCustomResponseRequest, options?: RawAxiosRequestConfig) {
        return RulesApiFp(this.configuration).rulesCustomResponseCreate(organization, project, v2RuleCustomResponseRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete a custom response rule
     * @param {string} organization Organization identifier
     * @param {string} project Project identifier
     * @param {string} rule Rule identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RulesApi
     */
    public rulesCustomResponseDelete(organization: string, project: string, rule: string, options?: RawAxiosRequestConfig) {
        return RulesApiFp(this.configuration).rulesCustomResponseDelete(organization, project, rule, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List custom response rules
     * @param {string} organization Organization identifier
     * @param {string} project Project identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RulesApi
     */
    public rulesCustomResponseList(organization: string, project: string, options?: RawAxiosRequestConfig) {
        return RulesApiFp(this.configuration).rulesCustomResponseList(organization, project, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get details of a custom response rule
     * @param {string} organization Organization identifier
     * @param {string} project Project identifier
     * @param {string} rule Rule identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RulesApi
     */
    public rulesCustomResponseRead(organization: string, project: string, rule: string, options?: RawAxiosRequestConfig) {
        return RulesApiFp(this.configuration).rulesCustomResponseRead(organization, project, rule, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update a custom response rule
     * @param {string} organization Organization identifier
     * @param {string} project Project identifier
     * @param {string} rule Rule identifier
     * @param {V2RuleCustomResponseRequest} v2RuleCustomResponseRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RulesApi
     */
    public rulesCustomResponseUpdate(organization: string, project: string, rule: string, v2RuleCustomResponseRequest: V2RuleCustomResponseRequest, options?: RawAxiosRequestConfig) {
        return RulesApiFp(this.configuration).rulesCustomResponseUpdate(organization, project, rule, v2RuleCustomResponseRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create an edge function rule
     * @param {string} organization Organization identifier
     * @param {string} project Project identifier
     * @param {V2RuleFunctionRequest} v2RuleFunctionRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RulesApi
     */
    public rulesFunctionCreate(organization: string, project: string, v2RuleFunctionRequest: V2RuleFunctionRequest, options?: RawAxiosRequestConfig) {
        return RulesApiFp(this.configuration).rulesFunctionCreate(organization, project, v2RuleFunctionRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete an edge function rule
     * @param {string} organization Organization identifier
     * @param {string} project Project identifier
     * @param {string} rule Rule identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RulesApi
     */
    public rulesFunctionDelete(organization: string, project: string, rule: string, options?: RawAxiosRequestConfig) {
        return RulesApiFp(this.configuration).rulesFunctionDelete(organization, project, rule, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List edge function rules
     * @param {string} organization Organization identifier
     * @param {string} project Project identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RulesApi
     */
    public rulesFunctionList(organization: string, project: string, options?: RawAxiosRequestConfig) {
        return RulesApiFp(this.configuration).rulesFunctionList(organization, project, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get details of an edge function rule
     * @param {string} organization Organization identifier
     * @param {string} project Project identifier
     * @param {string} rule Rule identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RulesApi
     */
    public rulesFunctionRead(organization: string, project: string, rule: string, options?: RawAxiosRequestConfig) {
        return RulesApiFp(this.configuration).rulesFunctionRead(organization, project, rule, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update an edge function rule
     * @param {string} organization Organization identifier
     * @param {string} project Project identifier
     * @param {string} rule Rule identifier
     * @param {V2RuleFunctionRequest} v2RuleFunctionRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RulesApi
     */
    public rulesFunctionUpdate(organization: string, project: string, rule: string, v2RuleFunctionRequest: V2RuleFunctionRequest, options?: RawAxiosRequestConfig) {
        return RulesApiFp(this.configuration).rulesFunctionUpdate(organization, project, rule, v2RuleFunctionRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create a header rule
     * @param {string} organization Organization identifier
     * @param {string} project Project identifier
     * @param {V2RuleHeaderRequest} v2RuleHeaderRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RulesApi
     */
    public rulesHeadersCreate(organization: string, project: string, v2RuleHeaderRequest: V2RuleHeaderRequest, options?: RawAxiosRequestConfig) {
        return RulesApiFp(this.configuration).rulesHeadersCreate(organization, project, v2RuleHeaderRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete a header rule
     * @param {string} organization Organization identifier
     * @param {string} project Project identifier
     * @param {string} rule Rule identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RulesApi
     */
    public rulesHeadersDelete(organization: string, project: string, rule: string, options?: RawAxiosRequestConfig) {
        return RulesApiFp(this.configuration).rulesHeadersDelete(organization, project, rule, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List header rules
     * @param {string} organization Organization identifier
     * @param {string} project Project identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RulesApi
     */
    public rulesHeadersList(organization: string, project: string, options?: RawAxiosRequestConfig) {
        return RulesApiFp(this.configuration).rulesHeadersList(organization, project, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get details of a header rule
     * @param {string} organization Organization identifier
     * @param {string} project Project identifier
     * @param {string} rule Rule identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RulesApi
     */
    public rulesHeadersRead(organization: string, project: string, rule: string, options?: RawAxiosRequestConfig) {
        return RulesApiFp(this.configuration).rulesHeadersRead(organization, project, rule, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update a header rule
     * @param {string} organization Organization identifier
     * @param {string} project Project identifier
     * @param {string} rule Rule identifier
     * @param {V2RuleHeaderRequest} v2RuleHeaderRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RulesApi
     */
    public rulesHeadersUpdate(organization: string, project: string, rule: string, v2RuleHeaderRequest: V2RuleHeaderRequest, options?: RawAxiosRequestConfig) {
        return RulesApiFp(this.configuration).rulesHeadersUpdate(organization, project, rule, v2RuleHeaderRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create a proxy rule
     * @param {string} organization 
     * @param {string} project 
     * @param {V2RuleProxyRequest} v2RuleProxyRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RulesApi
     */
    public rulesProxyCreate(organization: string, project: string, v2RuleProxyRequest: V2RuleProxyRequest, options?: RawAxiosRequestConfig) {
        return RulesApiFp(this.configuration).rulesProxyCreate(organization, project, v2RuleProxyRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete a proxy rule
     * @param {string} organization 
     * @param {string} project 
     * @param {string} rule 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RulesApi
     */
    public rulesProxyDelete(organization: string, project: string, rule: string, options?: RawAxiosRequestConfig) {
        return RulesApiFp(this.configuration).rulesProxyDelete(organization, project, rule, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List proxy rules
     * @param {string} organization 
     * @param {string} project 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RulesApi
     */
    public rulesProxyList(organization: string, project: string, options?: RawAxiosRequestConfig) {
        return RulesApiFp(this.configuration).rulesProxyList(organization, project, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get details of a proxy rule
     * @param {string} organization 
     * @param {string} project 
     * @param {string} rule 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RulesApi
     */
    public rulesProxyRead(organization: string, project: string, rule: string, options?: RawAxiosRequestConfig) {
        return RulesApiFp(this.configuration).rulesProxyRead(organization, project, rule, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update a proxy rule
     * @param {string} organization 
     * @param {string} project 
     * @param {string} rule 
     * @param {V2RuleProxyRequest} v2RuleProxyRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RulesApi
     */
    public rulesProxyUpdate(organization: string, project: string, rule: string, v2RuleProxyRequest: V2RuleProxyRequest, options?: RawAxiosRequestConfig) {
        return RulesApiFp(this.configuration).rulesProxyUpdate(organization, project, rule, v2RuleProxyRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create a redirect rule
     * @param {string} organization 
     * @param {string} project 
     * @param {V2RuleRedirectRequest} v2RuleRedirectRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RulesApi
     */
    public rulesRedirectCreate(organization: string, project: string, v2RuleRedirectRequest: V2RuleRedirectRequest, options?: RawAxiosRequestConfig) {
        return RulesApiFp(this.configuration).rulesRedirectCreate(organization, project, v2RuleRedirectRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete a redirect rule
     * @param {string} organization 
     * @param {string} project 
     * @param {string} rule 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RulesApi
     */
    public rulesRedirectDelete(organization: string, project: string, rule: string, options?: RawAxiosRequestConfig) {
        return RulesApiFp(this.configuration).rulesRedirectDelete(organization, project, rule, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List redirect rules
     * @param {string} organization 
     * @param {string} project 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RulesApi
     */
    public rulesRedirectList(organization: string, project: string, options?: RawAxiosRequestConfig) {
        return RulesApiFp(this.configuration).rulesRedirectList(organization, project, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get details of a redirect rule
     * @param {string} organization 
     * @param {string} project 
     * @param {string} rule 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RulesApi
     */
    public rulesRedirectRead(organization: string, project: string, rule: string, options?: RawAxiosRequestConfig) {
        return RulesApiFp(this.configuration).rulesRedirectRead(organization, project, rule, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update a redirect rule
     * @param {string} organization 
     * @param {string} project 
     * @param {string} rule 
     * @param {V2RuleRedirectRequest} v2RuleRedirectRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RulesApi
     */
    public rulesRedirectUpdate(organization: string, project: string, rule: string, v2RuleRedirectRequest: V2RuleRedirectRequest, options?: RawAxiosRequestConfig) {
        return RulesApiFp(this.configuration).rulesRedirectUpdate(organization, project, rule, v2RuleRedirectRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create a serve static rule
     * @param {string} organization Organization identifier
     * @param {string} project Project identifier
     * @param {V2RuleServeStaticRequest} v2RuleServeStaticRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RulesApi
     */
    public rulesServeStaticCreate(organization: string, project: string, v2RuleServeStaticRequest: V2RuleServeStaticRequest, options?: RawAxiosRequestConfig) {
        return RulesApiFp(this.configuration).rulesServeStaticCreate(organization, project, v2RuleServeStaticRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete a serve static rule
     * @param {string} organization Organization identifier
     * @param {string} project Project identifier
     * @param {string} rule Rule identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RulesApi
     */
    public rulesServeStaticDelete(organization: string, project: string, rule: string, options?: RawAxiosRequestConfig) {
        return RulesApiFp(this.configuration).rulesServeStaticDelete(organization, project, rule, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List serve static rules
     * @param {string} organization Organization identifier
     * @param {string} project Project identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RulesApi
     */
    public rulesServeStaticList(organization: string, project: string, options?: RawAxiosRequestConfig) {
        return RulesApiFp(this.configuration).rulesServeStaticList(organization, project, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get details of a serve static rule
     * @param {string} organization Organization identifier
     * @param {string} project Project identifier
     * @param {string} rule Rule identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RulesApi
     */
    public rulesServeStaticRead(organization: string, project: string, rule: string, options?: RawAxiosRequestConfig) {
        return RulesApiFp(this.configuration).rulesServeStaticRead(organization, project, rule, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update a serve static rule
     * @param {string} organization Organization identifier
     * @param {string} project Project identifier
     * @param {string} rule Rule identifier
     * @param {V2RuleServeStaticRequest} v2RuleServeStaticRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RulesApi
     */
    public rulesServeStaticUpdate(organization: string, project: string, rule: string, v2RuleServeStaticRequest: V2RuleServeStaticRequest, options?: RawAxiosRequestConfig) {
        return RulesApiFp(this.configuration).rulesServeStaticUpdate(organization, project, rule, v2RuleServeStaticRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * SSHAccessApi - axios parameter creator
 * @export
 */
export const SSHAccessApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get SSH access credentials for an environment
         * @param {string} organisation The organisation machine name
         * @param {string} application The application name
         * @param {string} environment The environment name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSshAccessCredentials: async (organisation: string, application: string, environment: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organisation' is not null or undefined
            assertParamExists('getSshAccessCredentials', 'organisation', organisation)
            // verify required parameter 'application' is not null or undefined
            assertParamExists('getSshAccessCredentials', 'application', application)
            // verify required parameter 'environment' is not null or undefined
            assertParamExists('getSshAccessCredentials', 'environment', environment)
            const localVarPath = `/api/v3/organizations/{organisation}/applications/{application}/environments/{environment}/ssh-access`
                .replace(`{${"organisation"}}`, encodeURIComponent(String(organisation)))
                .replace(`{${"application"}}`, encodeURIComponent(String(application)))
                .replace(`{${"environment"}}`, encodeURIComponent(String(environment)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SSHAccessApi - functional programming interface
 * @export
 */
export const SSHAccessApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SSHAccessApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Get SSH access credentials for an environment
         * @param {string} organisation The organisation machine name
         * @param {string} application The application name
         * @param {string} environment The environment name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSshAccessCredentials(organisation: string, application: string, environment: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetSshAccessCredentials200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSshAccessCredentials(organisation, application, environment, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SSHAccessApi.getSshAccessCredentials']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * SSHAccessApi - factory interface
 * @export
 */
export const SSHAccessApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SSHAccessApiFp(configuration)
    return {
        /**
         * 
         * @summary Get SSH access credentials for an environment
         * @param {string} organisation The organisation machine name
         * @param {string} application The application name
         * @param {string} environment The environment name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSshAccessCredentials(organisation: string, application: string, environment: string, options?: RawAxiosRequestConfig): AxiosPromise<GetSshAccessCredentials200Response> {
            return localVarFp.getSshAccessCredentials(organisation, application, environment, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * SSHAccessApi - object-oriented interface
 * @export
 * @class SSHAccessApi
 * @extends {BaseAPI}
 */
export class SSHAccessApi extends BaseAPI {
    /**
     * 
     * @summary Get SSH access credentials for an environment
     * @param {string} organisation The organisation machine name
     * @param {string} application The application name
     * @param {string} environment The environment name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SSHAccessApi
     */
    public getSshAccessCredentials(organisation: string, application: string, environment: string, options?: RawAxiosRequestConfig) {
        return SSHAccessApiFp(this.configuration).getSshAccessCredentials(organisation, application, environment, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ScalingPolicyApi - axios parameter creator
 * @export
 */
export const ScalingPolicyApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Delete the scaling policy for an environment
         * @param {string} organisation The organisation ID
         * @param {string} application The application ID
         * @param {string} environment The environment ID
         * @param {string} policyName The policy name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteScalingPolicy: async (organisation: string, application: string, environment: string, policyName: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organisation' is not null or undefined
            assertParamExists('deleteScalingPolicy', 'organisation', organisation)
            // verify required parameter 'application' is not null or undefined
            assertParamExists('deleteScalingPolicy', 'application', application)
            // verify required parameter 'environment' is not null or undefined
            assertParamExists('deleteScalingPolicy', 'environment', environment)
            // verify required parameter 'policyName' is not null or undefined
            assertParamExists('deleteScalingPolicy', 'policyName', policyName)
            const localVarPath = `/api/v3/organizations/{organisation}/applications/{application}/environments/{environment}/scaling-policies/{policyName}`
                .replace(`{${"organisation"}}`, encodeURIComponent(String(organisation)))
                .replace(`{${"application"}}`, encodeURIComponent(String(application)))
                .replace(`{${"environment"}}`, encodeURIComponent(String(environment)))
                .replace(`{${"policyName"}}`, encodeURIComponent(String(policyName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get the scaling policies for an environment
         * @param {string} organisation The organisation ID
         * @param {string} application The application ID
         * @param {string} environment The environment ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getScalingPolicies: async (organisation: string, application: string, environment: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organisation' is not null or undefined
            assertParamExists('getScalingPolicies', 'organisation', organisation)
            // verify required parameter 'application' is not null or undefined
            assertParamExists('getScalingPolicies', 'application', application)
            // verify required parameter 'environment' is not null or undefined
            assertParamExists('getScalingPolicies', 'environment', environment)
            const localVarPath = `/api/v3/organizations/{organisation}/applications/{application}/environments/{environment}/scaling-policies`
                .replace(`{${"organisation"}}`, encodeURIComponent(String(organisation)))
                .replace(`{${"application"}}`, encodeURIComponent(String(application)))
                .replace(`{${"environment"}}`, encodeURIComponent(String(environment)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update the scaling policy for an environment
         * @param {string} organisation The organisation ID
         * @param {string} application The application ID
         * @param {string} environment The environment ID
         * @param {ScalingPolicy} scalingPolicy 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateScalingPolicy: async (organisation: string, application: string, environment: string, scalingPolicy: ScalingPolicy, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organisation' is not null or undefined
            assertParamExists('updateScalingPolicy', 'organisation', organisation)
            // verify required parameter 'application' is not null or undefined
            assertParamExists('updateScalingPolicy', 'application', application)
            // verify required parameter 'environment' is not null or undefined
            assertParamExists('updateScalingPolicy', 'environment', environment)
            // verify required parameter 'scalingPolicy' is not null or undefined
            assertParamExists('updateScalingPolicy', 'scalingPolicy', scalingPolicy)
            const localVarPath = `/api/v3/organizations/{organisation}/applications/{application}/environments/{environment}/scaling-policies`
                .replace(`{${"organisation"}}`, encodeURIComponent(String(organisation)))
                .replace(`{${"application"}}`, encodeURIComponent(String(application)))
                .replace(`{${"environment"}}`, encodeURIComponent(String(environment)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(scalingPolicy, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ScalingPolicyApi - functional programming interface
 * @export
 */
export const ScalingPolicyApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ScalingPolicyApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Delete the scaling policy for an environment
         * @param {string} organisation The organisation ID
         * @param {string} application The application ID
         * @param {string} environment The environment ID
         * @param {string} policyName The policy name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteScalingPolicy(organisation: string, application: string, environment: string, policyName: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteScalingPolicy(organisation, application, environment, policyName, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ScalingPolicyApi.deleteScalingPolicy']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get the scaling policies for an environment
         * @param {string} organisation The organisation ID
         * @param {string} application The application ID
         * @param {string} environment The environment ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getScalingPolicies(organisation: string, application: string, environment: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getScalingPolicies(organisation, application, environment, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ScalingPolicyApi.getScalingPolicies']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update the scaling policy for an environment
         * @param {string} organisation The organisation ID
         * @param {string} application The application ID
         * @param {string} environment The environment ID
         * @param {ScalingPolicy} scalingPolicy 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateScalingPolicy(organisation: string, application: string, environment: string, scalingPolicy: ScalingPolicy, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateScalingPolicy(organisation, application, environment, scalingPolicy, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ScalingPolicyApi.updateScalingPolicy']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ScalingPolicyApi - factory interface
 * @export
 */
export const ScalingPolicyApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ScalingPolicyApiFp(configuration)
    return {
        /**
         * 
         * @summary Delete the scaling policy for an environment
         * @param {string} organisation The organisation ID
         * @param {string} application The application ID
         * @param {string} environment The environment ID
         * @param {string} policyName The policy name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteScalingPolicy(organisation: string, application: string, environment: string, policyName: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteScalingPolicy(organisation, application, environment, policyName, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get the scaling policies for an environment
         * @param {string} organisation The organisation ID
         * @param {string} application The application ID
         * @param {string} environment The environment ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getScalingPolicies(organisation: string, application: string, environment: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.getScalingPolicies(organisation, application, environment, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update the scaling policy for an environment
         * @param {string} organisation The organisation ID
         * @param {string} application The application ID
         * @param {string} environment The environment ID
         * @param {ScalingPolicy} scalingPolicy 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateScalingPolicy(organisation: string, application: string, environment: string, scalingPolicy: ScalingPolicy, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.updateScalingPolicy(organisation, application, environment, scalingPolicy, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ScalingPolicyApi - object-oriented interface
 * @export
 * @class ScalingPolicyApi
 * @extends {BaseAPI}
 */
export class ScalingPolicyApi extends BaseAPI {
    /**
     * 
     * @summary Delete the scaling policy for an environment
     * @param {string} organisation The organisation ID
     * @param {string} application The application ID
     * @param {string} environment The environment ID
     * @param {string} policyName The policy name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ScalingPolicyApi
     */
    public deleteScalingPolicy(organisation: string, application: string, environment: string, policyName: string, options?: RawAxiosRequestConfig) {
        return ScalingPolicyApiFp(this.configuration).deleteScalingPolicy(organisation, application, environment, policyName, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get the scaling policies for an environment
     * @param {string} organisation The organisation ID
     * @param {string} application The application ID
     * @param {string} environment The environment ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ScalingPolicyApi
     */
    public getScalingPolicies(organisation: string, application: string, environment: string, options?: RawAxiosRequestConfig) {
        return ScalingPolicyApiFp(this.configuration).getScalingPolicies(organisation, application, environment, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update the scaling policy for an environment
     * @param {string} organisation The organisation ID
     * @param {string} application The application ID
     * @param {string} environment The environment ID
     * @param {ScalingPolicy} scalingPolicy 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ScalingPolicyApi
     */
    public updateScalingPolicy(organisation: string, application: string, environment: string, scalingPolicy: ScalingPolicy, options?: RawAxiosRequestConfig) {
        return ScalingPolicyApiFp(this.configuration).updateScalingPolicy(organisation, application, environment, scalingPolicy, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * VariablesApi - axios parameter creator
 * @export
 */
export const VariablesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Bulk set/replace environment variables
         * @param {string} apiOrganisation The organisation ID
         * @param {string} apiApplication The application ID
         * @param {string} apiEnvironment The environment ID
         * @param {BulkSetEnvironmentVariablesRequest} bulkSetEnvironmentVariablesRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bulkSetEnvironmentVariables: async (apiOrganisation: string, apiApplication: string, apiEnvironment: string, bulkSetEnvironmentVariablesRequest: BulkSetEnvironmentVariablesRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'apiOrganisation' is not null or undefined
            assertParamExists('bulkSetEnvironmentVariables', 'apiOrganisation', apiOrganisation)
            // verify required parameter 'apiApplication' is not null or undefined
            assertParamExists('bulkSetEnvironmentVariables', 'apiApplication', apiApplication)
            // verify required parameter 'apiEnvironment' is not null or undefined
            assertParamExists('bulkSetEnvironmentVariables', 'apiEnvironment', apiEnvironment)
            // verify required parameter 'bulkSetEnvironmentVariablesRequest' is not null or undefined
            assertParamExists('bulkSetEnvironmentVariables', 'bulkSetEnvironmentVariablesRequest', bulkSetEnvironmentVariablesRequest)
            const localVarPath = `/api/v3/organizations/{api_organisation}/applications/{api_application}/environments/{api_environment}/variables`
                .replace(`{${"api_organisation"}}`, encodeURIComponent(String(apiOrganisation)))
                .replace(`{${"api_application"}}`, encodeURIComponent(String(apiApplication)))
                .replace(`{${"api_environment"}}`, encodeURIComponent(String(apiEnvironment)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(bulkSetEnvironmentVariablesRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a variable
         * @param {string} apiOrganisation The organisation ID
         * @param {string} apiApplication The application ID
         * @param {string} apiEnvironment The environment ID
         * @param {string} apiVariable The variable key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteEnvironmentVariable: async (apiOrganisation: string, apiApplication: string, apiEnvironment: string, apiVariable: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'apiOrganisation' is not null or undefined
            assertParamExists('deleteEnvironmentVariable', 'apiOrganisation', apiOrganisation)
            // verify required parameter 'apiApplication' is not null or undefined
            assertParamExists('deleteEnvironmentVariable', 'apiApplication', apiApplication)
            // verify required parameter 'apiEnvironment' is not null or undefined
            assertParamExists('deleteEnvironmentVariable', 'apiEnvironment', apiEnvironment)
            // verify required parameter 'apiVariable' is not null or undefined
            assertParamExists('deleteEnvironmentVariable', 'apiVariable', apiVariable)
            const localVarPath = `/api/v3/organizations/{api_organisation}/applications/{api_application}/environments/{api_environment}/variables/{api_variable}`
                .replace(`{${"api_organisation"}}`, encodeURIComponent(String(apiOrganisation)))
                .replace(`{${"api_application"}}`, encodeURIComponent(String(apiApplication)))
                .replace(`{${"api_environment"}}`, encodeURIComponent(String(apiEnvironment)))
                .replace(`{${"api_variable"}}`, encodeURIComponent(String(apiVariable)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get all variables for an environment
         * @param {string} apiOrganisation The organisation ID
         * @param {string} apiApplication The application ID
         * @param {string} apiEnvironment The environment ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listEnvironmentVariables: async (apiOrganisation: string, apiApplication: string, apiEnvironment: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'apiOrganisation' is not null or undefined
            assertParamExists('listEnvironmentVariables', 'apiOrganisation', apiOrganisation)
            // verify required parameter 'apiApplication' is not null or undefined
            assertParamExists('listEnvironmentVariables', 'apiApplication', apiApplication)
            // verify required parameter 'apiEnvironment' is not null or undefined
            assertParamExists('listEnvironmentVariables', 'apiEnvironment', apiEnvironment)
            const localVarPath = `/api/v3/organizations/{api_organisation}/applications/{api_application}/environments/{api_environment}/variables`
                .replace(`{${"api_organisation"}}`, encodeURIComponent(String(apiOrganisation)))
                .replace(`{${"api_application"}}`, encodeURIComponent(String(apiApplication)))
                .replace(`{${"api_environment"}}`, encodeURIComponent(String(apiEnvironment)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update a variable
         * @param {string} apiOrganisation The organisation ID
         * @param {string} apiApplication The application ID
         * @param {string} apiEnvironment The environment ID
         * @param {string} apiVariable The variable key
         * @param {UpdateEnvironmentVariableRequest} updateEnvironmentVariableRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateEnvironmentVariable: async (apiOrganisation: string, apiApplication: string, apiEnvironment: string, apiVariable: string, updateEnvironmentVariableRequest: UpdateEnvironmentVariableRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'apiOrganisation' is not null or undefined
            assertParamExists('updateEnvironmentVariable', 'apiOrganisation', apiOrganisation)
            // verify required parameter 'apiApplication' is not null or undefined
            assertParamExists('updateEnvironmentVariable', 'apiApplication', apiApplication)
            // verify required parameter 'apiEnvironment' is not null or undefined
            assertParamExists('updateEnvironmentVariable', 'apiEnvironment', apiEnvironment)
            // verify required parameter 'apiVariable' is not null or undefined
            assertParamExists('updateEnvironmentVariable', 'apiVariable', apiVariable)
            // verify required parameter 'updateEnvironmentVariableRequest' is not null or undefined
            assertParamExists('updateEnvironmentVariable', 'updateEnvironmentVariableRequest', updateEnvironmentVariableRequest)
            const localVarPath = `/api/v3/organizations/{api_organisation}/applications/{api_application}/environments/{api_environment}/variables/{api_variable}`
                .replace(`{${"api_organisation"}}`, encodeURIComponent(String(apiOrganisation)))
                .replace(`{${"api_application"}}`, encodeURIComponent(String(apiApplication)))
                .replace(`{${"api_environment"}}`, encodeURIComponent(String(apiEnvironment)))
                .replace(`{${"api_variable"}}`, encodeURIComponent(String(apiVariable)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateEnvironmentVariableRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * VariablesApi - functional programming interface
 * @export
 */
export const VariablesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = VariablesApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Bulk set/replace environment variables
         * @param {string} apiOrganisation The organisation ID
         * @param {string} apiApplication The application ID
         * @param {string} apiEnvironment The environment ID
         * @param {BulkSetEnvironmentVariablesRequest} bulkSetEnvironmentVariablesRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async bulkSetEnvironmentVariables(apiOrganisation: string, apiApplication: string, apiEnvironment: string, bulkSetEnvironmentVariablesRequest: BulkSetEnvironmentVariablesRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.bulkSetEnvironmentVariables(apiOrganisation, apiApplication, apiEnvironment, bulkSetEnvironmentVariablesRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['VariablesApi.bulkSetEnvironmentVariables']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete a variable
         * @param {string} apiOrganisation The organisation ID
         * @param {string} apiApplication The application ID
         * @param {string} apiEnvironment The environment ID
         * @param {string} apiVariable The variable key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteEnvironmentVariable(apiOrganisation: string, apiApplication: string, apiEnvironment: string, apiVariable: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteEnvironmentVariable(apiOrganisation, apiApplication, apiEnvironment, apiVariable, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['VariablesApi.deleteEnvironmentVariable']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get all variables for an environment
         * @param {string} apiOrganisation The organisation ID
         * @param {string} apiApplication The application ID
         * @param {string} apiEnvironment The environment ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listEnvironmentVariables(apiOrganisation: string, apiApplication: string, apiEnvironment: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listEnvironmentVariables(apiOrganisation, apiApplication, apiEnvironment, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['VariablesApi.listEnvironmentVariables']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update a variable
         * @param {string} apiOrganisation The organisation ID
         * @param {string} apiApplication The application ID
         * @param {string} apiEnvironment The environment ID
         * @param {string} apiVariable The variable key
         * @param {UpdateEnvironmentVariableRequest} updateEnvironmentVariableRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateEnvironmentVariable(apiOrganisation: string, apiApplication: string, apiEnvironment: string, apiVariable: string, updateEnvironmentVariableRequest: UpdateEnvironmentVariableRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateEnvironmentVariable(apiOrganisation, apiApplication, apiEnvironment, apiVariable, updateEnvironmentVariableRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['VariablesApi.updateEnvironmentVariable']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * VariablesApi - factory interface
 * @export
 */
export const VariablesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = VariablesApiFp(configuration)
    return {
        /**
         * 
         * @summary Bulk set/replace environment variables
         * @param {string} apiOrganisation The organisation ID
         * @param {string} apiApplication The application ID
         * @param {string} apiEnvironment The environment ID
         * @param {BulkSetEnvironmentVariablesRequest} bulkSetEnvironmentVariablesRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bulkSetEnvironmentVariables(apiOrganisation: string, apiApplication: string, apiEnvironment: string, bulkSetEnvironmentVariablesRequest: BulkSetEnvironmentVariablesRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.bulkSetEnvironmentVariables(apiOrganisation, apiApplication, apiEnvironment, bulkSetEnvironmentVariablesRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete a variable
         * @param {string} apiOrganisation The organisation ID
         * @param {string} apiApplication The application ID
         * @param {string} apiEnvironment The environment ID
         * @param {string} apiVariable The variable key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteEnvironmentVariable(apiOrganisation: string, apiApplication: string, apiEnvironment: string, apiVariable: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteEnvironmentVariable(apiOrganisation, apiApplication, apiEnvironment, apiVariable, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get all variables for an environment
         * @param {string} apiOrganisation The organisation ID
         * @param {string} apiApplication The application ID
         * @param {string} apiEnvironment The environment ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listEnvironmentVariables(apiOrganisation: string, apiApplication: string, apiEnvironment: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.listEnvironmentVariables(apiOrganisation, apiApplication, apiEnvironment, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update a variable
         * @param {string} apiOrganisation The organisation ID
         * @param {string} apiApplication The application ID
         * @param {string} apiEnvironment The environment ID
         * @param {string} apiVariable The variable key
         * @param {UpdateEnvironmentVariableRequest} updateEnvironmentVariableRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateEnvironmentVariable(apiOrganisation: string, apiApplication: string, apiEnvironment: string, apiVariable: string, updateEnvironmentVariableRequest: UpdateEnvironmentVariableRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.updateEnvironmentVariable(apiOrganisation, apiApplication, apiEnvironment, apiVariable, updateEnvironmentVariableRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * VariablesApi - object-oriented interface
 * @export
 * @class VariablesApi
 * @extends {BaseAPI}
 */
export class VariablesApi extends BaseAPI {
    /**
     * 
     * @summary Bulk set/replace environment variables
     * @param {string} apiOrganisation The organisation ID
     * @param {string} apiApplication The application ID
     * @param {string} apiEnvironment The environment ID
     * @param {BulkSetEnvironmentVariablesRequest} bulkSetEnvironmentVariablesRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VariablesApi
     */
    public bulkSetEnvironmentVariables(apiOrganisation: string, apiApplication: string, apiEnvironment: string, bulkSetEnvironmentVariablesRequest: BulkSetEnvironmentVariablesRequest, options?: RawAxiosRequestConfig) {
        return VariablesApiFp(this.configuration).bulkSetEnvironmentVariables(apiOrganisation, apiApplication, apiEnvironment, bulkSetEnvironmentVariablesRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete a variable
     * @param {string} apiOrganisation The organisation ID
     * @param {string} apiApplication The application ID
     * @param {string} apiEnvironment The environment ID
     * @param {string} apiVariable The variable key
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VariablesApi
     */
    public deleteEnvironmentVariable(apiOrganisation: string, apiApplication: string, apiEnvironment: string, apiVariable: string, options?: RawAxiosRequestConfig) {
        return VariablesApiFp(this.configuration).deleteEnvironmentVariable(apiOrganisation, apiApplication, apiEnvironment, apiVariable, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get all variables for an environment
     * @param {string} apiOrganisation The organisation ID
     * @param {string} apiApplication The application ID
     * @param {string} apiEnvironment The environment ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VariablesApi
     */
    public listEnvironmentVariables(apiOrganisation: string, apiApplication: string, apiEnvironment: string, options?: RawAxiosRequestConfig) {
        return VariablesApiFp(this.configuration).listEnvironmentVariables(apiOrganisation, apiApplication, apiEnvironment, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update a variable
     * @param {string} apiOrganisation The organisation ID
     * @param {string} apiApplication The application ID
     * @param {string} apiEnvironment The environment ID
     * @param {string} apiVariable The variable key
     * @param {UpdateEnvironmentVariableRequest} updateEnvironmentVariableRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VariablesApi
     */
    public updateEnvironmentVariable(apiOrganisation: string, apiApplication: string, apiEnvironment: string, apiVariable: string, updateEnvironmentVariableRequest: UpdateEnvironmentVariableRequest, options?: RawAxiosRequestConfig) {
        return VariablesApiFp(this.configuration).updateEnvironmentVariable(apiOrganisation, apiApplication, apiEnvironment, apiVariable, updateEnvironmentVariableRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * VolumesApi - axios parameter creator
 * @export
 */
export const VolumesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create a new volume
         * @param {string} organisation The organisation ID
         * @param {string} application The application ID
         * @param {string} environment The environment ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createVolume: async (organisation: string, application: string, environment: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organisation' is not null or undefined
            assertParamExists('createVolume', 'organisation', organisation)
            // verify required parameter 'application' is not null or undefined
            assertParamExists('createVolume', 'application', application)
            // verify required parameter 'environment' is not null or undefined
            assertParamExists('createVolume', 'environment', environment)
            const localVarPath = `/api/v3/organizations/{organisation}/applications/{application}/environments/{environment}/volumes`
                .replace(`{${"organisation"}}`, encodeURIComponent(String(organisation)))
                .replace(`{${"application"}}`, encodeURIComponent(String(application)))
                .replace(`{${"environment"}}`, encodeURIComponent(String(environment)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a volume
         * @param {string} organisation The organisation ID
         * @param {string} application The application ID
         * @param {string} environment The environment ID
         * @param {string} volume The volume ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteVolume: async (organisation: string, application: string, environment: string, volume: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organisation' is not null or undefined
            assertParamExists('deleteVolume', 'organisation', organisation)
            // verify required parameter 'application' is not null or undefined
            assertParamExists('deleteVolume', 'application', application)
            // verify required parameter 'environment' is not null or undefined
            assertParamExists('deleteVolume', 'environment', environment)
            // verify required parameter 'volume' is not null or undefined
            assertParamExists('deleteVolume', 'volume', volume)
            const localVarPath = `/api/v3/organizations/{organisation}/applications/{application}/environments/{environment}/volumes/{volume}`
                .replace(`{${"organisation"}}`, encodeURIComponent(String(organisation)))
                .replace(`{${"application"}}`, encodeURIComponent(String(application)))
                .replace(`{${"environment"}}`, encodeURIComponent(String(environment)))
                .replace(`{${"volume"}}`, encodeURIComponent(String(volume)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a volume
         * @param {string} organisation The organisation ID
         * @param {string} application The application ID
         * @param {string} environment The environment ID
         * @param {string} volume The volume ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVolume: async (organisation: string, application: string, environment: string, volume: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organisation' is not null or undefined
            assertParamExists('getVolume', 'organisation', organisation)
            // verify required parameter 'application' is not null or undefined
            assertParamExists('getVolume', 'application', application)
            // verify required parameter 'environment' is not null or undefined
            assertParamExists('getVolume', 'environment', environment)
            // verify required parameter 'volume' is not null or undefined
            assertParamExists('getVolume', 'volume', volume)
            const localVarPath = `/api/v3/organizations/{organisation}/applications/{application}/environments/{environment}/volumes/{volume}`
                .replace(`{${"organisation"}}`, encodeURIComponent(String(organisation)))
                .replace(`{${"application"}}`, encodeURIComponent(String(application)))
                .replace(`{${"environment"}}`, encodeURIComponent(String(environment)))
                .replace(`{${"volume"}}`, encodeURIComponent(String(volume)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get all volumes for an environment
         * @param {string} organisation The organisation ID
         * @param {string} application The application ID
         * @param {string} environment The environment ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listVolumes: async (organisation: string, application: string, environment: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organisation' is not null or undefined
            assertParamExists('listVolumes', 'organisation', organisation)
            // verify required parameter 'application' is not null or undefined
            assertParamExists('listVolumes', 'application', application)
            // verify required parameter 'environment' is not null or undefined
            assertParamExists('listVolumes', 'environment', environment)
            const localVarPath = `/api/v3/organizations/{organisation}/applications/{application}/environments/{environment}/volumes`
                .replace(`{${"organisation"}}`, encodeURIComponent(String(organisation)))
                .replace(`{${"application"}}`, encodeURIComponent(String(application)))
                .replace(`{${"environment"}}`, encodeURIComponent(String(environment)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * VolumesApi - functional programming interface
 * @export
 */
export const VolumesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = VolumesApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Create a new volume
         * @param {string} organisation The organisation ID
         * @param {string} application The application ID
         * @param {string} environment The environment ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createVolume(organisation: string, application: string, environment: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Volume>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createVolume(organisation, application, environment, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['VolumesApi.createVolume']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete a volume
         * @param {string} organisation The organisation ID
         * @param {string} application The application ID
         * @param {string} environment The environment ID
         * @param {string} volume The volume ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteVolume(organisation: string, application: string, environment: string, volume: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteVolume(organisation, application, environment, volume, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['VolumesApi.deleteVolume']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get a volume
         * @param {string} organisation The organisation ID
         * @param {string} application The application ID
         * @param {string} environment The environment ID
         * @param {string} volume The volume ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getVolume(organisation: string, application: string, environment: string, volume: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Volume>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getVolume(organisation, application, environment, volume, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['VolumesApi.getVolume']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get all volumes for an environment
         * @param {string} organisation The organisation ID
         * @param {string} application The application ID
         * @param {string} environment The environment ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listVolumes(organisation: string, application: string, environment: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Volume>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listVolumes(organisation, application, environment, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['VolumesApi.listVolumes']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * VolumesApi - factory interface
 * @export
 */
export const VolumesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = VolumesApiFp(configuration)
    return {
        /**
         * 
         * @summary Create a new volume
         * @param {string} organisation The organisation ID
         * @param {string} application The application ID
         * @param {string} environment The environment ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createVolume(organisation: string, application: string, environment: string, options?: RawAxiosRequestConfig): AxiosPromise<Volume> {
            return localVarFp.createVolume(organisation, application, environment, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete a volume
         * @param {string} organisation The organisation ID
         * @param {string} application The application ID
         * @param {string} environment The environment ID
         * @param {string} volume The volume ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteVolume(organisation: string, application: string, environment: string, volume: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteVolume(organisation, application, environment, volume, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a volume
         * @param {string} organisation The organisation ID
         * @param {string} application The application ID
         * @param {string} environment The environment ID
         * @param {string} volume The volume ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVolume(organisation: string, application: string, environment: string, volume: string, options?: RawAxiosRequestConfig): AxiosPromise<Volume> {
            return localVarFp.getVolume(organisation, application, environment, volume, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get all volumes for an environment
         * @param {string} organisation The organisation ID
         * @param {string} application The application ID
         * @param {string} environment The environment ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listVolumes(organisation: string, application: string, environment: string, options?: RawAxiosRequestConfig): AxiosPromise<Volume> {
            return localVarFp.listVolumes(organisation, application, environment, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * VolumesApi - object-oriented interface
 * @export
 * @class VolumesApi
 * @extends {BaseAPI}
 */
export class VolumesApi extends BaseAPI {
    /**
     * 
     * @summary Create a new volume
     * @param {string} organisation The organisation ID
     * @param {string} application The application ID
     * @param {string} environment The environment ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VolumesApi
     */
    public createVolume(organisation: string, application: string, environment: string, options?: RawAxiosRequestConfig) {
        return VolumesApiFp(this.configuration).createVolume(organisation, application, environment, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete a volume
     * @param {string} organisation The organisation ID
     * @param {string} application The application ID
     * @param {string} environment The environment ID
     * @param {string} volume The volume ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VolumesApi
     */
    public deleteVolume(organisation: string, application: string, environment: string, volume: string, options?: RawAxiosRequestConfig) {
        return VolumesApiFp(this.configuration).deleteVolume(organisation, application, environment, volume, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a volume
     * @param {string} organisation The organisation ID
     * @param {string} application The application ID
     * @param {string} environment The environment ID
     * @param {string} volume The volume ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VolumesApi
     */
    public getVolume(organisation: string, application: string, environment: string, volume: string, options?: RawAxiosRequestConfig) {
        return VolumesApiFp(this.configuration).getVolume(organisation, application, environment, volume, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get all volumes for an environment
     * @param {string} organisation The organisation ID
     * @param {string} application The application ID
     * @param {string} environment The environment ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VolumesApi
     */
    public listVolumes(organisation: string, application: string, environment: string, options?: RawAxiosRequestConfig) {
        return VolumesApiFp(this.configuration).listVolumes(organisation, application, environment, options).then((request) => request(this.axios, this.basePath));
    }
}



